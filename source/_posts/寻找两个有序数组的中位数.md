---
title: 寻找两个有序数组的中位数
copyright: true
date: 2019-06-10 21:58:46
categories:
- 算法
- 寻找两个有序数组的中位数
tags:
- 算法
---

给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。

请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。

你可以假设 nums1 和 nums2 不会同时为空。

    nums1 = [1, 3]
    nums2 = [2]

中位数是：2.0

<!--more-->

我自己的解法是用的归并排序，先把两个有序数组排好序放到另一个数组中，再用位运算找到中位，求解，然后结果是运行速度极慢。

就去看了官方的结题思路

因为官方有直接的答案，我就在这写写我的理解(ps：其中一些公式什么的是直接从官网复制黏贴来的，图片也是直接截的，手打太费事了)【简要概述】：

# 结题思路

把nums1和nums2都分成两个部分，然后nums1左边的部分和nums2左边的部分，nums1右边的部分nums2右边的部分放在一块，最后左边的部分总数要和右边部分的总数一样多,如下图：

<center>{% qnimg 寻找两个有序数组的中位数/part.png%}</center>

根据这张图里面的左边和右边的部分，我们假设已知$\,i\,$和$\,m\,$还有$\,n\,$的值，然后用公式把$\,j\,$表示出来,其中：

- $len(left_part)=len(right_part)$
- $\max(\text{left\_part}) \leq \min(\text{right\_part})max(left_part)≤min(right_part)$

为了保证数据不溢出，所以要保证nums1的长度要小于nums2，这样先对nums1选中i的指向位置后，根据公式算出j的时候就不会发生j指向的nums2数据溢出了。

这个题目的本质就是，把这两个数组统一分成两部分，前面那个部分都要比后面的部分小，所以，我们必须确保：

B[j−1]≤A[i] 以及 \text{A}[i-1] \leq \text{B}[j]A[i−1]≤B[j]

然后i和j的算法公式：

$ i=0∼m, j=\frac{m+n+1}{2}−i$

所以，得出i和j之后，我们就可以根据nums1[]和nums2[]这两个有序数组的大小去寻找中位数了。

其中m+n+1是为了保证中位数落在分割线的左边，如果中位数在中位线的右边的话，很容易因为数据溢出而报错。

因为很多时候，i会等于nums1[].lenth()，或者j会等于nums2[].lenth()，所以我们在循环保证i的指向是我们想要的地方之后（或者刚好溢出后），进入判断环节。

如果i等于nums1[].lenth()，那么则意味着j的指向的数字是我们所需要的中位数之一（之所以说是之一，是因为这两个数组长度加在一起是奇数，不然i是不会等于nums1[].lenth()），j也是这样。

如果i等于0的时候，那么意味着j现在指向的就是中位数，而不需要继续去寻找中位数了。j等于0的时候也是如此。（i或者j指向0，这种情况在两个数组长度为奇数或者偶数的情况下都会出现）

讲的有点零散，所以我决定直接把代码连接放出来！
[见官网](https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/xun-zhao-liang-ge-you-xu-shu-zu-de-zhong-wei-shu-b/)

# 题目来源

[力扣（LeetCode）](https://leetcode-cn.com/problems/median-of-two-sorted-arrays)


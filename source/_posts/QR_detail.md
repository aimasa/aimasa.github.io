---
title: 了解二维码(二):二维码的编码方式
copyright: true
date: 2019-01-21 14:57:33
categories:
- QR
- 了解二维码
- 了解二维码(二):二维码的编码方式
tags:
- QR
---
# 了解二维码的编码方式
***
> QR Code码(Quick Response Code)有自动纠错功能，具有超高速识读特点。用CCD二维条码识读设备，每秒可识读30个含有100个字符的QR Code码符号。[参考博文链接](http://www.labelmx.com/tech/CodeKown/Code/201207/4637.html)

<!--more-->

## QR码支持的编码内容
[参考博文链接](https://blog.csdn.net/dekko/article/details/6121899 "虽然该博客的图看不到，只有这段话值得看一看")，[参考博文链接](https://www.cnblogs.com/magicsoar/p/4483032.html)：该链接中有很详细讲二维码的各部分和它的原理，也有很详细的根据一串字符串生成二维码的算法

## 数据编码

针对不同的数据，QR码设计了** 不同的数据编码编码方式 **，我们可以根据数据的种类选择合适的编码方式进行编码。

* 数字编码（Numeric）        ：可编码0-9，10个数字，如果需要编码的数字的个数不是3的倍数，最后剩下的1或2位数会被转成4或7bits，其它的每3位数字会根据不同版本被编成 10，12，14bits（编成多长还得看二维码的尺寸）
 
* 字符编码（Alphanumeric) ：可编码0-9,大写的A-Z（没有小写）,以及9个其他的字符(space $ % * + – . / :)编码的过程是把字符两两分组，然后转成下表的45进制，然后转成11bits的二进制，如果最后有一个落单(说明该字符串长度为奇数)的，那就转成6bits的二进制。而编码模式和字符的个数需要根据不同的Version尺寸编成9, 11或13个二进制
<center>{% qnimg QR_detail/Alphanumeric-mode.png %}</center>

* 8位字节模式(8-bit Byte)：可编码JIS X 0201的8位Latin/Kana字符集

除此之外，QR还提供了其他的编码方式，每一个编码方式都有其独有的id进行标识，这些标识会记录在数据区的前端，使得解码器可以根据二维码使用的编码方式对数据进行解码

<center>{% qnimg QR_detail/encodeList.png %}</center>

---

QR码支持编码的内容包括纯数字、数字和字符混合编码、8位字节码和包含汉字在内的多字节字符。其中：

+ 数字：每三个为一组压缩成10bit。

+ 字母数字混合:每两个为一组，压缩成11bit。                                  

+ 8bit字节数据：无压缩直接保存。

+ 多字节字符：每一个字符被压缩成13bit。

在QR的[图像介绍](https://aimasa.github.io/2019/01/21/QR_infor)中说过关于QR数据存储有关的知识，在QR中1码字对应8比特。
以下是QR码中总比特的计算方法

<center>{% qnimg QR_detail/bit_count.png %}</center>

## 补齐码

补齐码不同版本和不同纠错级，所容纳的比特数也不同，不同版本和不同纠错级所容纳的比特数见附录四。而补齐码就是在我们确定好QR码的版本和纠错级后，判断数据编码的比特数在此版本和纠错级下能够容纳的数据编码比特数是否相等。不是的话，那么就补11101100  00010001进行填充，如果一次填充还不足的话，可循环再次填充。直到其与比特数相同

数据编码=编码模式+字符长度+编码的数据+结束码+凑8bits整+补齐码。

[摘自简书(稍做修改，便于我理解)](https://www.jianshu.com/p/8a0dcb2e0427)


## 纠错码

纠错码的等级越高，纠错能力也会越高，这样就会需要更多的纠错码，就会导致能够存储的数据变少。纠错码一共有四个等级，L(7%) 01,M(15%) 00,Q(25%) 11,R(35%) 10  **括号里的百分比是能够修正的字符比例**

因为变脏，变破损的部位不一定只是码字部位，还有别的地方，所以，在QR码中，还是用相对于全部码字的比率来描述纠错率。

纠错级别的比率，是指全部码字与可以纠错的码字的比率。 

纠错码可以纠正两种错误：

+ （错误码位置已知）拒读错误：就是扫描二维码时候有的字符没扫到或者扫描到了却读取不出来，就需要纠错码上场了，这种错误需要一个纠错码
+ （错误位置未知）替代错误：就是有的字符输入错误，但是不知道是哪个字符，所以就需要纠错码的帮助，需要两个纠错码。

---
> [记笔记](https://en.wikiversity.org/wiki/Reed%E2%80%93Solomon_codes_for_coders)：虽然纠错码在数学上可能看起来令人生畏，但大多数数学运算都是高等级的（Galois Fields除外，但事实上对于任何程序员来说都是简单和通用的：它只是对整数模运算操作数）。 然而，纠错码背后的数学智慧的复杂性隐藏了非常直观的目标和机制。

> 让我们以一种我们可以“猜测”数据是否被破坏的方式构建数据，只需“修复”结构就可以了。在数学上，我们使用来自伽罗瓦域的多项式来实现这种结构。（get corrupted：被破坏）

> 纠错码的主要思路是，我们可以使用较小的一组精心挑选的单词，而不是使用整个单词词典，一个“简化的词典”，这样的每个单词都和别的单词都不一样。（我的理解是，这一组单词是没有重复的词汇，所以每个单词都是独一无二的），我们只需在我们的简化字典中查找

> + 检测哪些单词被破坏（因为它们不在我们的简化字典中）
> + 通过查找字典中最相似的单词来纠正损坏的单词。

---

这部分我的理解是可以把需要放进去的消息去掉重复的字符，做成一个简易词典，然后在一些词因为破损而没法顺利读取出来时候，就用这个简易词典里面的字符和这些词进行比对，其中差异最小的词就被自动认定为这个词破损前的样子

但是如果简化词典里面有this和that两个单词，但是被损坏只能读取出来的部分是th**(precisely:准确的；separability:分离性)

这个差异，或者更准确地说是我们字典的任何2个单词之间的不同字母的最小数量，被称为我们字典的最大汉明距离。 确保字典的任何2个单词在同一位置仅共享最少数量的字母称为最大可分离性。

最大可分离性：两个单词之间极少部分相同

比如：

请注意，如果词典中的每个单词与其他单词的差异至少为5个字符，因此距离为5.这允许在已知位置中最多4个错误，这些错误称为擦除或未知位置中的2个错误需要更正。【因为如果位置错误有五个的话，就会出现没法用简化词典比对出这个破损的词是什么】

8字符中6个字符的子集有28个[C(8,6)]，所以遍历28个6字符的子集，因为距离为5，所以只有一个能匹配（在被损坏的单词少于或者等于2的时候）

---
> 可以看到冗余在恢复丢失信息方面的优势：冗余字符可帮助您恢复原始数据。 前面的例子显示了粗略的纠错方案如何起作用。 Reed-Solomon的核心思想是类似的，将冗余数据附加到基于Galois Field数学的消息中。 原始纠错解码器类似于上面的错误示例，搜索对应于有效消息的接收消息的子集，并选择具有最多匹配的子集作为纠正消息。 这对于较大的消息是不实际的，因此开发了数学算法以在合理的时间内执行纠错。

## 格式信息

### 掩码

掩码过程是被用来避免可能会让扫描器混乱的标志特征出现（比如大区域的黑块，让扫描器无法识别其中内容），所以用掩码反转某些模块（让白色变成黑色，黑色变成白色），而那些特定功能的模块则单独存在，不受掩码的影响。

红色的区域编码了格式信息，并使用了一个固定的掩码模式

<center>{% qnimg QR_detail/masking.png %}</center>

使用异或操作可以轻松应用（或者删除）掩码转换（很多编程语言里面用插入符
号^表示）逆时针读取二维码中的左上角的定位器模式，我们能够得到下面的比特序列，白色表示0，黑色表示1。（校正图形盖住的部位不需要读取二进制数）

所以：
Input：101101101001011
Mask ：101010000010010
output：000111101011001

### 格式信息

格式信息有两个相同的副本，所以即使其中一份被损坏还是能够有机会识别出来的。第二份副本被分成两部分，放在另外两个定位器周围，并且都还是以逆时针方向读取。

格式信息的前两比特是用来给出用于消息数据的纠错码的纠错等级信息。

<center>{% qnimg QR_detail/纠错码.png %}</center>



格式信息接下来的三位是选择要在数据区中使用的掩码模式，接下来的这张图把这些掩码模式列出来了，包括了根据位置算出的模块为黑色的数学公式（i和j分别是行号和列号，左上角以0开头）。
<center>{% qnimg QR_detail/Mask_num.png %}</center>

剩下的十位格式化信息用于对格式信息本身的错误校验。

（duplicate：更正）

从右下角开始读取数据位，并以Z字形图案向上移动两个右侧列。 前三个字节是01000000 11010010 01110101.接下来的两列是向下读取的，因此下一个字节是01000111.到达底部后，向上读取后面的两列。 以这种上下方式一直到符号的左侧（必要时跳过定位模式）。 这是用十六进制表示法表示出来的完整信息。

<center>{% qnimg QR_detail/unmask.png %}</center>

Message data bytes: 40 d2 75 47 76 17 32 06 27 26 96 c6 c6 96 70 ec
Error correction bytes: bc 2a 90 13 6b af ef fd 4b e0

## 解码

最后的步骤是把解读信息比特，把它变成可读的信息。前四个比特指示信息应该怎么解码。QR码使用几种不同的编码模式，以至于不同种类的信息能够有效的被存储。（summarize：总结）在模式指示码之后的是长度字段，告诉解码器有多少字符被存储。这个字符的长度取决于指定的编码方案。

<center>{% qnimg QR_detail/lenth.png %}</center>

[8 bits per character==每个字符八位]上面的长度字段大小仅适用于较小的QR码

所以可以根据上图得出紧跟着0100后面的8个比特的字符串0000 1101是讲的是该存储信息的长度，表明有十三个字符，所以后面跟的00100111和01010100（分别是"'"和"T"的ascii码）等等十三个字符。

在最后一个数据位之后是另一个4位模式指示符，它可以和第一个4位模式指示符不一样，从而允许在一个QR码中混合多个编码方案，如果没有其他数据了，用0000结尾（如果存储空间不够，可以省略这个标记）

为了使我们的QR码解码器**可靠**，我们需要能够**纠正**错误。 本文的下一部分将描述如何通过构造BCH解码器，更具体地说是Reed-Solomon解码器来纠正错误。

[二维码之解码器](https://aimasa.github.io/2019/01/23/BCH/)
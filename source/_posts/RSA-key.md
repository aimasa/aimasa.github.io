---
title: RSA算法
copyright: true
date: 2019-02-21 14:16:45
categories:
- RSA公钥加密
- RSA算法
tags:
- RSA算法
---
RSA公钥算法是现在非常普遍的存在，因为它的高运算量所以导致难破解，其实最主要的原因是现有的计算机的运算能力还没有那么强，没办法对巨大的加密数进行因式分解。

目前公开破译的位数是768位，实际使用一般是1024位或是2048位，所以理论上特别的安全。
<!--more-->
[证明方法](https://blog.csdn.net/u014044812/article/details/80866759)

[公私钥生成步骤](https://www.zhihu.com/question/25038691)

# 公钥私钥生成

先选取两个质数q,p
> n = p * q

然后算出n的 [欧拉函数](https://aimasa.github.io/2019/02/22/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/) φ(n)
> φ(n)=(p-1)(q-1)

从1-φ(n)中选出一个质数e，这个e要和φ(n)互质

对e取反模

> ed ≡ 1 (mod φ(n))

根据同余的定义，这个式子可以延展为：

> ed - 1 = kφ(n)

根据已知的φ(n)和e得出d的值(会有很多组值，取其一即可)
以此得出公钥(n,e) 私钥(n,d)

# 加密解密

## 加密

 m为需要被加密的信息
 c为会生成的信息

m^e ≡ c(mod n)

## 解密

c^d ≡ m(mod n)

## 证明

### 验证解密公式成立

对解密公式c^d ≡ m(mod n)进行验证

根据加密公式 
> m^e ≡ c(mod n) => m^e - c =kn =>c = m^e -kn

把c代入我们要证明的解密公式
> (m^e - kn)^d ≡ m(mod n) 
 
因为kn能被n整除，所以在拆这种多项式的时候，能被n整除的数可以留下，因为只有不能被n整除的数才能够产生余数。所以得出下面的公式
> m^ed ≡ m(mod n)
 
又因为ed等于kφ(n)+1，故得出如下公式
>m^(kφ(n)+1) ≡ m(mod n)

所以，我们只要证明这个公式成立，就证明解密公式的成立，也就证明了RSA算法的成立。

#### 两部分证明

##### m与n互质

根据[欧拉定理](https://aimasa.github.io/2019/02/22/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/)得出如下公式
> m^φ(n) ≡ 1(mod n) => m^φ(n)-1 = kn =>m^φ(n) = kn + 1
> (m^φ(n))^h = (kn + 1)^h 

而对(kn + 1)^h 对n取模为1，可以推出
> (kn + 1)^h ≡ 1(mod n) => (m^φ(n))^h ≡ 1(mod n) 
> => m^(kφ(n)+1) ≡ m(mod n)

该式子成立


##### m与n不互质

m和n不互质时候，所以n和m一定有除1以外的公因子，又因为n等于质数p和质数q的乘积(**两个质数之积是合数，但该合数只有四个因子，因数除了1和它本身外还有这两个质数因子。**)所以，m必然等于kq或kp。

以m=kq为例，那么m一定和p互质(**一个素数，另一个数不为它的倍数，那么两个数一定互质**)---->根据[欧拉定理](https://aimasa.github.io/2019/02/22/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/)可得出如下公式：
> (kq)^φ(p) ≡ 1 (mod p)

因为p为质数，所以

> φ(p)= p - 1

可以得出

> (kq)^(p - 1) ≡ 1 (mod p)  

> ((kq)^(p - 1))^h(q - 1) x kq ≡ kq (mod p) 

> (kq)^(hφ(n) + 1) ≡ kq (mod p)

又因为(因为上式中的h可以为任意数字，所以假定h为下式中的h)

> ed ≡ 1(modφ(n)) → ed = hφ(n)+1 → ed = h(p−1)(q−1)+1 

故

> (kq)^ed ≡ kq (mod p)

> (kq)^ed - kq = tp

因为等式左边对q取模为零，所以右边一定也为零，所以tp中t一定是q的倍数，令t=uq

> (kq)^ed - kq = uqp

又因为n = pq, m = kq，所以

> m^ed -m = un

> m^ed ≡m(modn)

又因为生成密钥的第五步中我们取e并求了他对φ(n)的模反元素d：

> ed≡1(modφ(n))→ed=hφ(n)+1

将ed代入上式得：

> m^(hφ(n)+1) ≡ m(modn)

故当m与n不互质时候，证明原式成功。
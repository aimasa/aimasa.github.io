---
title: 最长回文串
copyright: true
date: 2019-06-18 20:08:52
categories:
- 算法
- 最长回文串
tags:
- 算法
---

终于弄懂了最长回文串，在做题的时候，总是在暴力破解的思路里出不去，总想着两个for循环，空间复杂度为o($n^{2}$)然后解题思路里面讲了Manacher's algorithm这个算法，把复杂度降低到了o(n)。

<!--more-->

首先看张图（我为了图方便，都先预处理了字符串，不是按官方给的判断回文子串的奇偶方法）

<center>{% qnimg 最长回文串/time.png%}</center>

上面那行是我用暴力破解用的时间，下面那行是用Manacher's algorithm这个算法花的时间，可以很明显的看到emm差距。

（想说一点[题外话]：记得老师说以空间换时间和以时间换空间的这句话，所以我们需要在时间和空间中找到一个平衡点以达到我们想要的效率）

# 暴力破解

这个算法很简单，就是简单粗暴的双循环，接着判断是不是回文串，再判断是不是最长的回文串。

我用的是先预处理字符串，在字符串中间加入"#"号，字符串首尾也加上这个

eg：abcd  =====> #a#b#c#d#

这样就能保证字符串长度一定为奇数了（如果字符串原长3，那么就需要插入4个"#"，那么奇数加偶数一定是奇数了）

然后根据循环到的位置，扩散开来判断是否是回文串，是的话同时记录长度和下标，就能够寻找到最长的回文串了。

# Manacher's algorithm

## 预处理

首先预处理字符串，让字符串保证长度为奇数
eg：aba  =====> #a#b#a#

## 主要思路

先假设**当前最长回文串**

<center>{%qnimg 最长回文串/table.png %}</center>

 
里面的p[i]是指当前回文串的半径（其实p[i] - 1就是当前回文串的真实长度）

所以，p[j]是最后得出最长回文串的关键。

所以我们需要求出p[j]（ci的位置就是为p[i]服务的）

先假设ci是**当前**最长回文串的中心点，那么由它开始往外扩展，判断这个最长回文串里面是否有新的回文串，如果有的话，首先判断新的回文串是不是被这个最大回文串包含了。

从j=0开始往后遍历，同时开始判断当前最长的回文串，然后ci的位置根据最长回文串的最右边界的位置而开始发生改变。

接着就要开始讨论关于j的位置处于最长回文串的笼罩范围内的情况了：

<center>{%qnimg 最长回文串/lenth.png %}</center>

这里列举的是j存在的回文串**处于最长回文串笼罩的范围内的情况**。

在这里我们没有必要去一个个比较去判断在最长回文串内的i的情况，我们可以直接对j对应ci的另一边的j的映射（我们称为i，i = 2* ci - j）i的p[i]的长度，如果p[i]的回文串长度如上图所示的话，那么p[j]=p[i],然后跳出循环，去遍历下一个j

除了刚刚那种情况，那就还有剩下的一种情况了：j存在的回文串**长于最长回文串笼罩的范围内的情况**

<center>{%qnimg 最长回文串/overLenth.png %}</center>

其中j的回文子串的右边比ci所对应的回文串的最右边长（如图），那么我们就需要判断一下j对应的i的回文字符串有多长，所以首先我们要知道l的长度，因为对应的i的那个部分是回文字符串，所以在没有超出ci的最长回文串的最右边界的部分，j的那段一定是回文字符串，所以我们就需要在基于l长度的回文字符串的基础下，继续往后比较。

<center>{%qnimg 最长回文串/final.png %}</center>

如果j的回文串的最右边界超出了ci原本对应的最长回文串的边界

<center>{%qnimg 最长回文串/realFinal.png %}</center>

那么就令ci的值变成j的值。

当然，在对ci做改变时候，要记住随时记录p[j]的值，并且随时记录p[j]里面的最大值。

## 结尾

所以最后就根据p[j]的最大值找到对应的字符子串，这个子串就是最大回文串


# 参考资料

[参考官方资料](https://leetcode-cn.com/problems/longest-palindromic-substring/solution/zhong-xin-kuo-san-dong-tai-gui-hua-by-liweiwei1419/)

[本文代码](https://github.com/aimasa/exercise_demo/tree/master/src/exercise/demo/longestpalindrome)



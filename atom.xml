<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>aimasa的个人博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://aimasa.github.io/"/>
  <updated>2019-06-13T09:27:48.609Z</updated>
  <id>http://aimasa.github.io/</id>
  
  <author>
    <name>ZHY</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>寻找两个有序数组的中位数</title>
    <link href="http://aimasa.github.io/2019/06/10/%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/"/>
    <id>http://aimasa.github.io/2019/06/10/寻找两个有序数组的中位数/</id>
    <published>2019-06-10T13:58:46.000Z</published>
    <updated>2019-06-13T09:27:48.609Z</updated>
    
    <content type="html"><![CDATA[<p>给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。</p><p>请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。</p><p>你可以假设 nums1 和 nums2 不会同时为空。</p><pre><code>nums1 = [1, 3]nums2 = [2]</code></pre><p>中位数是：2.0</p><a id="more"></a><p>我自己的解法是用的归并排序，先把两个有序数组排好序放到另一个数组中，再用位运算找到中位，求解，然后结果是运行速度极慢。</p><p>就去看了官方的结题思路</p><p>因为官方有直接的答案，我就在这写写我的理解(ps：其中一些公式什么的是直接从官网复制黏贴来的，图片也是直接截的，手打太费事了)【简要概述】：</p><h1 id="结题思路"><a href="#结题思路" class="headerlink" title="结题思路"></a>结题思路</h1><p>把nums1和nums2都分成两个部分，然后nums1左边的部分和nums2左边的部分，nums1右边的部分nums2右边的部分放在一块，最后左边的部分总数要和右边部分的总数一样多,如下图：</p><center><img src="http://pictures.aimasa.club/static/images/寻找两个有序数组的中位数/part.png"></center><p>根据这张图里面的左边和右边的部分，我们假设已知$\,i\,$和$\,m\,$还有$\,n\,$的值，然后用公式把$\,j\,$表示出来,其中：</p><ul><li>$len(left_part)=len(right_part)$</li><li>$\max(\text{left_part}) \leq \min(\text{right_part})max(left_part)≤min(right_part)$</li></ul><p>为了保证数据不溢出，所以要保证nums1的长度要小于nums2，这样先对nums1选中i的指向位置后，根据公式算出j的时候就不会发生j指向的nums2数据溢出了。</p><p>这个题目的本质就是，把这两个数组统一分成两部分，前面那个部分都要比后面的部分小，所以，我们必须确保：</p><p>B[j−1]≤A[i] 以及 \text{A}[i-1] \leq \text{B}[j]A[i−1]≤B[j]</p><p>然后i和j的算法公式：</p><p>$ i=0∼m, j=\frac{m+n+1}{2}−i$</p><p>所以，得出i和j之后，我们就可以根据nums1[]和nums2[]这两个有序数组的大小去寻找中位数了。</p><p>其中m+n+1是为了保证中位数落在分割线的左边，如果中位数在中位线的右边的话，很容易因为数据溢出而报错。</p><p>因为很多时候，i会等于nums1[].lenth()，或者j会等于nums2[].lenth()，所以我们在循环保证i的指向是我们想要的地方之后（或者刚好溢出后），进入判断环节。</p><p>如果i等于nums1[].lenth()，那么则意味着j的指向的数字是我们所需要的中位数之一（之所以说是之一，是因为这两个数组长度加在一起是奇数，不然i是不会等于nums1[].lenth()），j也是这样。</p><p>如果i等于0的时候，那么意味着j现在指向的就是中位数，而不需要继续去寻找中位数了。j等于0的时候也是如此。（i或者j指向0，这种情况在两个数组长度为奇数或者偶数的情况下都会出现）</p><p>讲的有点零散，所以我决定直接把代码连接放出来！<br><a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/xun-zhao-liang-ge-you-xu-shu-zu-de-zhong-wei-shu-b/" target="_blank" rel="noopener">见官网</a></p><h1 id="题目来源"><a href="#题目来源" class="headerlink" title="题目来源"></a>题目来源</h1><p><a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays" target="_blank" rel="noopener">力扣（LeetCode）</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。&lt;/p&gt;
&lt;p&gt;请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。&lt;/p&gt;
&lt;p&gt;你可以假设 nums1 和 nums2 不会同时为空。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;nums1 = [1, 3]
nums2 = [2]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;中位数是：2.0&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://aimasa.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="寻找两个有序数组的中位数" scheme="http://aimasa.github.io/categories/%E7%AE%97%E6%B3%95/%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/"/>
    
    
      <category term="算法" scheme="http://aimasa.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>SpringCloud学习</title>
    <link href="http://aimasa.github.io/2019/06/05/SpringCloud%E5%AD%A6%E4%B9%A0/"/>
    <id>http://aimasa.github.io/2019/06/05/SpringCloud学习/</id>
    <published>2019-06-05T06:28:23.000Z</published>
    <updated>2019-06-05T08:33:47.760Z</updated>
    
    <content type="html"><![CDATA[<p>之前我写的代码都是单架构模式，就是把多个功能放在同一个应用里面，就像之前写的小程序后台一样</p><p>修改了部分代码，就得整体再重新打包编译，没有修改的部分，甚至不需要使用到这部分代码的功能也因为重新打包编译而全部不能使用……</p><p>所以要通过分布式和集群的方式把单架构模式改造一下</p><a id="more"></a><h1 id="微服务概念"><a href="#微服务概念" class="headerlink" title="微服务概念"></a>微服务概念</h1><p>一个springboot就是一个微服务，而且这个springboot做的事情很单一。在我的理解里面，就是把之前的一个整体的分层架构的springboot分成controller、service、dao这三个部分，</p><h1 id="微服务注册"><a href="#微服务注册" class="headerlink" title="微服务注册"></a>微服务注册</h1><p>虽然把springboot分了三部分，但这三部分应该怎么建立连接，相互之间应该怎么进行联络，所以就要引入一个微服务注册中心的概念了。这个微服务注册中心在 springcloud 里就叫做 eureka server, 通过它把就可以把微服务注册起来，以供将来调用。</p><h1 id="微服务访问"><a href="#微服务访问" class="headerlink" title="微服务访问"></a>微服务访问</h1><p>一个服务通过微服务注册中心定位并访问另外一个微服务。</p><h1 id="分布式概念"><a href="#分布式概念" class="headerlink" title="分布式概念"></a>分布式概念</h1><p>博客里介绍：本来一个spring boot就能完成的任务现在分布在多个spring boot里面做。<br>就是不同的部分的微服务可以由不同的团队去开发，耦合度低。</p><h1 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h1><p>就是同样的功能，但是用的端口不一样，如果8080挂了，我可以用8081这个端口的这个功能的微服务，这叫高可用==。</p><h1 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h1><p><a href="http://how2j.cn/k/springcloud/springcloud-distribution/2037.html" target="_blank" rel="noopener">Spring Cloud入门（对这篇博客做的笔记）</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前我写的代码都是单架构模式，就是把多个功能放在同一个应用里面，就像之前写的小程序后台一样&lt;/p&gt;
&lt;p&gt;修改了部分代码，就得整体再重新打包编译，没有修改的部分，甚至不需要使用到这部分代码的功能也因为重新打包编译而全部不能使用……&lt;/p&gt;
&lt;p&gt;所以要通过分布式和集群的方式把单架构模式改造一下&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Cloud学习（一）" scheme="http://aimasa.github.io/categories/Spring-Cloud%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    
      <category term="微服务的概念" scheme="http://aimasa.github.io/categories/Spring-Cloud%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%A6%82%E5%BF%B5/"/>
    
    
      <category term="Spring Cloud" scheme="http://aimasa.github.io/tags/Spring-Cloud/"/>
    
  </entry>
  
  <entry>
    <title>springBootTest注入失败</title>
    <link href="http://aimasa.github.io/2019/06/05/springBootTest%E6%B3%A8%E5%85%A5%E5%A4%B1%E8%B4%A5/"/>
    <id>http://aimasa.github.io/2019/06/05/springBootTest注入失败/</id>
    <published>2019-06-05T01:26:51.000Z</published>
    <updated>2019-06-05T01:41:11.417Z</updated>
    
    <content type="html"><![CDATA[<p>在用测试测dao层时候，虽然都有用注解:dao层用注解@Repository标记，Test类里面注入用@Autowired标记。</p><p>但是还是显示注入失败。</p><a id="more"></a><p>查了半天方法，最后去了spring boot的运行类里面加上了指定包扫描@ComponentScan(basePackages = {“扫描的包的共有的包名部分”})</p><p>然后刚刚发现，之所以扫不出来是因为我包名的命名错误</p><img src="http://pictures.aimasa.club/static/images/springBootTest注入失败/package.png">]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在用测试测dao层时候，虽然都有用注解:dao层用注解@Repository标记，Test类里面注入用@Autowired标记。&lt;/p&gt;
&lt;p&gt;但是还是显示注入失败。&lt;/p&gt;
    
    </summary>
    
      <category term="spring相关" scheme="http://aimasa.github.io/categories/spring%E7%9B%B8%E5%85%B3/"/>
    
      <category term="Test" scheme="http://aimasa.github.io/categories/spring%E7%9B%B8%E5%85%B3/Test/"/>
    
      <category term="SpringBootTest注入失败" scheme="http://aimasa.github.io/categories/spring%E7%9B%B8%E5%85%B3/Test/SpringBootTest%E6%B3%A8%E5%85%A5%E5%A4%B1%E8%B4%A5/"/>
    
    
      <category term="运行error" scheme="http://aimasa.github.io/tags/%E8%BF%90%E8%A1%8Cerror/"/>
    
  </entry>
  
  <entry>
    <title>态势感知</title>
    <link href="http://aimasa.github.io/2019/05/31/%E6%80%81%E5%8A%BF%E6%84%9F%E7%9F%A5/"/>
    <id>http://aimasa.github.io/2019/05/31/态势感知/</id>
    <published>2019-05-31T09:31:11.000Z</published>
    <updated>2019-05-31T09:31:11.351Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>文件上传到mongdb的方法</title>
    <link href="http://aimasa.github.io/2019/05/23/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%88%B0mongdb%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>http://aimasa.github.io/2019/05/23/文件上传到mongdb的方法/</id>
    <published>2019-05-23T08:38:02.000Z</published>
    <updated>2019-05-24T06:03:48.951Z</updated>
    
    <content type="html"><![CDATA[<p>思路：先构造一个请求体，然后获取文件类型，进行比对，如果不是excel类型拒绝，是则存入请求体.</p><p>把文件内容转成输入流，再从输入流中读取转成二进制byteArray类型</p><p>对这个二进制数组做哈希</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;思路：先构造一个请求体，然后获取文件类型，进行比对，如果不是excel类型拒绝，是则存入请求体.&lt;/p&gt;
&lt;p&gt;把文件内容转成输入流，再从输入流中读取转成二进制byteArray类型&lt;/p&gt;
&lt;p&gt;对这个二进制数组做哈希&lt;/p&gt;

      
    
    </summary>
    
      <category term="spring相关" scheme="http://aimasa.github.io/categories/spring%E7%9B%B8%E5%85%B3/"/>
    
      <category term="mongodb存储" scheme="http://aimasa.github.io/categories/spring%E7%9B%B8%E5%85%B3/mongodb%E5%AD%98%E5%82%A8/"/>
    
    
      <category term="mongodb" scheme="http://aimasa.github.io/tags/mongodb/"/>
    
  </entry>
  
  <entry>
    <title>一种基于结构划分概率的口令攻击方法</title>
    <link href="http://aimasa.github.io/2019/05/10/%E4%B8%80%E7%A7%8D%E5%9F%BA%E4%BA%8E%E7%BB%93%E6%9E%84%E5%88%92%E5%88%86%E6%A6%82%E7%8E%87%E7%9A%84%E5%8F%A3%E4%BB%A4%E6%94%BB%E5%87%BB%E6%96%B9%E6%B3%95/"/>
    <id>http://aimasa.github.io/2019/05/10/一种基于结构划分概率的口令攻击方法/</id>
    <published>2019-05-10T12:26:08.000Z</published>
    <updated>2019-06-12T09:16:48.178Z</updated>
    
    <content type="html"><![CDATA[<p>这是一种基于结构划分概率的口令攻击方法研究，里面牵涉到了上下文无关文法</p><p>它分析了现在存储用户口令的方法，然后优化了对口令的攻击方法，节约了很多时间</p><a id="more"></a><h1 id="论文大体介绍"><a href="#论文大体介绍" class="headerlink" title="论文大体介绍"></a>论文大体介绍</h1><p>现在的系统大部分是保存口令的Hash值，用户登录时候，会通过<strong>单向函数</strong>（单向函数给定输入值进行输出很简单，但是很难从输出值去推算回输入值）对输入的口令进行运算，再把得到的Hash值去和存储的哈希值进行对比，如果相等，那么就登录成功了。</p><p>也有一些系统是采用加盐值（就是给你的密码加一串随机数，然后再进行哈希运算，得出一串哈希值，这样对于去破解密码的人来说，运算量很大，很难被破解）的方法去进一步保证系统的安全性。</p><p>因为攻击难度提高了，所以攻击者换了个角度，开始从人对口令的记忆方面去思考攻击方法，提高攻击效率。</p><p>这篇论文是重在考虑基于口令划分概率的口令攻击方法。它和另一个方法相比提高了百分之二十到百分之三十的命中率</p><p>这个方法也具有学习功能，能够根据攻击结果更新使用的字典，提高攻击效率。</p><h1 id="近来口令分析简介"><a href="#近来口令分析简介" class="headerlink" title="近来口令分析简介"></a>近来口令分析简介</h1><ul><li><p>结合词典，根据刚开始定义的变形规则去改变刚开始的单词，生成口令。</p><ul><li>但是变形规则简单，数量有限，要人工自己编写</li><li>口令搜索空间有限，它依赖于已经有的字典和变形规则，变形规则简单，虽然可以根据攻击者自己想变形规则去形成复杂口令，但效率不高。</li></ul></li><li><p>基于马尔科夫链的时间存储折中攻击</p><ul><li>（没看）</li></ul></li><li><p>基于概率上下文无关文法口令攻击方法</p><ul><li>用概率上下文无关文法去定义口令结构，就分块定义，然后对每个块的密码内容进行概率排序，然后产生半终端结构（就是比如我分块是A、B、C、D三个块，A概率最大的值是1，那么按A概率排的半终端结构就是1BCD）</li><li>各个块进行概率排序，然后各个按概率大小组合在一起，形成的结构再按概率插入队列</li><li>有了更多的变形规则，搜索空间更大了</li><li>据统计，高概率的具体结构长度大部分都小于等于3（就分的块小于等于分出了三个块）</li><li>命中率低（但相对于前面的，已经提高了命中率）</li></ul></li></ul><h1 id="口令结构分析"><a href="#口令结构分析" class="headerlink" title="口令结构分析"></a>口令结构分析</h1><p>详细数据表明，大部分人都会把口令只划分为一个部分（也就是比较单一）当然还有少部分会使用其他结构</p><p>对口令按具体结构进行初次划分时候，不会把口令结构划分的很小。</p><p>根据数据分析，虽然结构长的口令比较难被攻击者猜测出来，但是很少有用户会选择结构长的口令。</p><h1 id="基于结构划分概率的方法"><a href="#基于结构划分概率的方法" class="headerlink" title="基于结构划分概率的方法"></a>基于结构划分概率的方法</h1><p>所以该文决定对高概率的口令组合结构根据用户习惯进行再次划分</p><p>主要步骤：</p><ul><li>预处理</li><li>口令攻击阶段</li></ul><h2 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h2><ul><li>具体结构：就是根据用户设置的口令而划分的结构（没有被处理过的那种）</li><li>抽取子结构：就是从具体结构中划分出来的小结构再分类别归类，从而形成了抽取子结构。eg:A（字母）、D（数字），具体结构是：ADAD =&gt; {AA，DD}（分类别归类），其中抽取子结构为：$\bar{A}\, =\, AA\,$</li><li>再对具体结构根据它对应的抽取子结构进行归类，再计算该结构的使用概率。</li></ul><p>论文中使用了一种概率统计方法：</p><p>$p\, =\frac{NUM_{ss_{i}}} {NUM_{es_{j}}}$ </p><p>其中分母表示的是具有这个抽取子结构的数目，分子是对应的具有此划分子结构数目（就是对具体子结构分类别归类后，不同结构组成同一抽取子结构的结构）</p><p>$\,ss_{i}\,$表示第i个划分子结构,$\,es_{j}\,$表示二对应的第j个抽取子结构.</p><p>由论文总结的数据可以得知：用户口令单一结构的组成占大多数。</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1] 邹静,林东岱,郝春辉.一种基于结构划分概率的口令攻击方法[J].计算机学报,2014,37(05):1206-1215.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是一种基于结构划分概率的口令攻击方法研究，里面牵涉到了上下文无关文法&lt;/p&gt;
&lt;p&gt;它分析了现在存储用户口令的方法，然后优化了对口令的攻击方法，节约了很多时间&lt;/p&gt;
    
    </summary>
    
      <category term="数学导论" scheme="http://aimasa.github.io/categories/%E6%95%B0%E5%AD%A6%E5%AF%BC%E8%AE%BA/"/>
    
      <category term="上下文无关文法" scheme="http://aimasa.github.io/categories/%E6%95%B0%E5%AD%A6%E5%AF%BC%E8%AE%BA/%E4%B8%8A%E4%B8%8B%E6%96%87%E6%97%A0%E5%85%B3%E6%96%87%E6%B3%95/"/>
    
      <category term="论文赏析（只有赏）" scheme="http://aimasa.github.io/categories/%E6%95%B0%E5%AD%A6%E5%AF%BC%E8%AE%BA/%E4%B8%8A%E4%B8%8B%E6%96%87%E6%97%A0%E5%85%B3%E6%96%87%E6%B3%95/%E8%AE%BA%E6%96%87%E8%B5%8F%E6%9E%90%EF%BC%88%E5%8F%AA%E6%9C%89%E8%B5%8F%EF%BC%89/"/>
    
    
      <category term="数学导论" scheme="http://aimasa.github.io/tags/%E6%95%B0%E5%AD%A6%E5%AF%BC%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>学习爬虫（一）：安装selenium和ChromeDriver</title>
    <link href="http://aimasa.github.io/2019/05/10/%E5%AD%A6%E4%B9%A0%E7%88%AC%E8%99%AB%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%AE%89%E8%A3%85selenium%E5%92%8CChromeDriver/"/>
    <id>http://aimasa.github.io/2019/05/10/学习爬虫（一）：安装selenium和ChromeDriver/</id>
    <published>2019-05-10T09:33:44.000Z</published>
    <updated>2019-06-12T09:14:44.057Z</updated>
    
    <content type="html"><![CDATA[<p>关于爬虫的学习，先从selenium这个库开始学。</p><a id="more"></a><h1 id="关于selenium"><a href="#关于selenium" class="headerlink" title="关于selenium"></a>关于selenium</h1><p>先是</p><pre><code>pip install selenium</code></pre><p>安装完这个，我以为就odk了，然后在pycharm编译器里面跟着网上给的代码敲了一段</p><pre><code>from selenium import webdriverbrowser = webdriver.Chrome()browser.get(&#39;https://www.baidu.com&#39;)</code></pre><p>结果报错了</p><pre><code>This inspection detects names that should resolve but don&#39;t. Due to dynamic dispatch and duck typing, this is possible in a limited but useful number of cases. Top-level and class-level items are supported better than instance items.</code></pre><p>大体意思就是模块不存在，然后我以为是pip install时候出错了，就回去再pip install一遍，结果发现，还是没有用。</p><p>然后上网找解决方案，跟着网上的教程去看了pycharm这个IDE里面设置的python环境的路径：</p><ul><li><strong>File &gt; settings &gt; project:xxxxxxx(你导入pycharm的文件夹)  &gt; project Interpreter</strong></li></ul><p>就发现我pip install下载下来的selenium库地址和之前设置在IDE里面python环境的地址不一样，所以没法找到selenium这个模块。</p><p>然后去对这个IDE里面的python路径进行更改。</p><h2 id="更改"><a href="#更改" class="headerlink" title="更改"></a>更改</h2><center><img src="http://pictures.aimasa.club/static/images/学习爬虫（一）：安装selenium和ChromeDriver/pycharm.png"></center><p>点<strong>show all……</strong></p><p>接着</p><center><img src="http://pictures.aimasa.club/static/images/学习爬虫（一）：安装selenium和ChromeDriver/add.png"></center><p>找到对应python-pip的相关python目录所在地，然后更改IDE依赖环境目录。</p><h2 id="查找目录所在地"><a href="#查找目录所在地" class="headerlink" title="查找目录所在地"></a>查找目录所在地</h2><p>我是再次pip install selenium，然后看到了selenium存的位置，再根据这个位置找到相关信息。</p><h1 id="ChromeDriver"><a href="#ChromeDriver" class="headerlink" title="ChromeDriver"></a>ChromeDriver</h1><p>我弄好了，发现不再显示该模块不存在的信息了之后，运行了一遍，发现还是报错了。</p><pre><code>Service chromedriver unexpectedly exited</code></pre><p>出现了这个报错信息。</p><h2 id="装插件"><a href="#装插件" class="headerlink" title="装插件"></a>装插件</h2><p>所以我去安装chromedriver驱动<a href="http://npm.taobao.org/mirrors/chromedriver/" target="_blank" rel="noopener">下载地址</a></p><p>下载好了之后，解压，再新建一个文件夹，里面只放解压出来的exe文件，再去控制面板里面配置环境path</p><p>然后再运行，成功调出了Chrome浏览器，并且让它自动进入百度搜索页面。</p><h1 id="browser-get"><a href="#browser-get" class="headerlink" title="browser.get()"></a>browser.get()</h1><p>browser.get()括号里面的字符串必须填写完整的网址，不然会显示无效网址的错误提示。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://blog.csdn.net/qq_41188944/article/details/79039690" target="_blank" rel="noopener">参考资料</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于爬虫的学习，先从selenium这个库开始学。&lt;/p&gt;
    
    </summary>
    
      <category term="爬虫、python" scheme="http://aimasa.github.io/categories/%E7%88%AC%E8%99%AB%E3%80%81python/"/>
    
      <category term="安装selenium和ChromeDriver" scheme="http://aimasa.github.io/categories/%E7%88%AC%E8%99%AB%E3%80%81python/%E5%AE%89%E8%A3%85selenium%E5%92%8CChromeDriver/"/>
    
    
      <category term="爬虫" scheme="http://aimasa.github.io/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>git出错（一）</title>
    <link href="http://aimasa.github.io/2019/05/09/git%E5%87%BA%E9%94%99%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://aimasa.github.io/2019/05/09/git出错（一）/</id>
    <published>2019-05-09T03:25:38.000Z</published>
    <updated>2019-05-09T03:33:09.375Z</updated>
    
    <content type="html"><![CDATA[<p>报错：src refspec master does not match any</p><a id="more"></a><h1 id="操作过程"><a href="#操作过程" class="headerlink" title="操作过程"></a>操作过程</h1><pre><code>git initgit commit -m &quot;first commit&quot;git remote add origin git@github.com:aimasa/xxxxxxxxgit push -u origin master</code></pre><p>然后再回车的时候，git bash就报错了</p><pre><code>src refspec master does not match any</code></pre><h1 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h1><p>我没有提交任何内容，我的本地库（.git）是空的，所以第一次push是提交一个空项目，里面没有任何东西，所以报错了</p><h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p>把代码提交到本地，然后再推送一次</p><pre><code>git add .git commit -m &quot;xxxx&quot;git push -u origin master</code></pre><p>推送成功</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;报错：src refspec master does not match any&lt;/p&gt;
    
    </summary>
    
      <category term="git" scheme="http://aimasa.github.io/categories/git/"/>
    
      <category term="git出错" scheme="http://aimasa.github.io/categories/git/git%E5%87%BA%E9%94%99/"/>
    
      <category term="src refspec master does not match any." scheme="http://aimasa.github.io/categories/git/git%E5%87%BA%E9%94%99/src-refspec-master-does-not-match-any/"/>
    
    
      <category term="git出错" scheme="http://aimasa.github.io/tags/git%E5%87%BA%E9%94%99/"/>
    
  </entry>
  
  <entry>
    <title>背包问题</title>
    <link href="http://aimasa.github.io/2019/05/09/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
    <id>http://aimasa.github.io/2019/05/09/背包问题/</id>
    <published>2019-05-09T01:39:13.000Z</published>
    <updated>2019-05-10T12:22:16.940Z</updated>
    
    <content type="html"><![CDATA[<p>背包问题（Knapsack problem）典型的KP问题描述是：从n个具有价值与重量的物品中选择若干个装入一个具有载重限制的背包,如何选择物品使得装入物品的重量之和在不超过背包载重前提下价值之和达到最大。</p><a id="more"></a><p>有空再看把，暂时搁着，笔记等看完了再来记</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;背包问题（Knapsack problem）典型的KP问题描述是：从n个具有价值与重量的物品中选择若干个装入一个具有载重限制的背包,如何选择物品使得装入物品的重量之和在不超过背包载重前提下价值之和达到最大。&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://aimasa.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="KP(背包问题)" scheme="http://aimasa.github.io/categories/%E7%AE%97%E6%B3%95/KP-%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
    
    
      <category term="算法" scheme="http://aimasa.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>七牛云把测试域名替换成已备份域名</title>
    <link href="http://aimasa.github.io/2019/05/08/%E4%B8%83%E7%89%9B%E4%BA%91%E6%8A%8A%E6%B5%8B%E8%AF%95%E5%9F%9F%E5%90%8D%E6%9B%BF%E6%8D%A2%E6%88%90%E5%B7%B2%E5%A4%87%E4%BB%BD%E5%9F%9F%E5%90%8D/"/>
    <id>http://aimasa.github.io/2019/05/08/七牛云把测试域名替换成已备份域名/</id>
    <published>2019-05-08T07:55:51.000Z</published>
    <updated>2019-05-08T08:43:10.885Z</updated>
    
    <content type="html"><![CDATA[<p>之前把图片放在七牛云的图床上，结果因为我的测试域名到期了，一定要绑定一个域名，才能继续用。接着我去阿里云买了个服务器，绑定了一个域名，并且去做了备案【千万考虑清楚，因为我买的是学生机，所以比较便宜。然后开始在思考我为什么那么冲动，买了服务器不知道干啥用，好浪费,所以打算开始学爬虫……】</p><a id="more"></a><h1 id="step"><a href="#step" class="headerlink" title="step"></a>step</h1><p>进入控制台去对域名进行绑定</p><center><img src="http://pictures.aimasa.club/static/images/七牛云把测试域名替换成已备份域名/one.png"></center><p>进入了控制台，然后点击绑定域名。</p><center><img src="http://pictures.aimasa.club/static/images/七牛云把测试域名替换成已备份域名/two.png"></center><p>输入已经备案好了的域名，选择http协议，如果选择https的话就要花钱（购买证书把大概）</p><center><img src="http://pictures.aimasa.club/static/images/七牛云把测试域名替换成已备份域名/three.png"></center><p><strong>提示</strong>：里面已备份域名填你的二级域名就好了。</p><p>然后其他的我都是默认设置，最后点创建。</p><p>创建完了之后，点进融合SDN去找管理域名</p><center><img src="http://pictures.aimasa.club/static/images/七牛云把测试域名替换成已备份域名/four.png"></center><p>然后把鼠标移到我标红的这块会有“复制CNAME”，点击。</p><center><img src="http://pictures.aimasa.club/static/images/七牛云把测试域名替换成已备份域名/five.png"></center><p>接着就去购买的服务器那里对这个二级域名进行解析</p><p>登录进阿里云，点进管理控制台，进入域名，点击域名列表</p><center><img src="http://pictures.aimasa.club/static/images/七牛云把测试域名替换成已备份域名/six.png"></center><p>然后在你购买的那个域名旁边点解析</p><center><img src="http://pictures.aimasa.club/static/images/七牛云把测试域名替换成已备份域名/seven.png"></center><p>点击添加记录</p><center><img src="http://pictures.aimasa.club/static/images/七牛云把测试域名替换成已备份域名/add.png"></center><p>按照图示填写信息。</p><p>再然后就等你的</p><center><img src="http://pictures.aimasa.club/static/images/七牛云把测试域名替换成已备份域名/five.png"></center><p>状态变成成功了。</p><p>再然后去你博客配置文件里面更改之前的配置：</p><center><img src="http://pictures.aimasa.club/static/images/七牛云把测试域名替换成已备份域名/final.png"></center><p>把我马克了的地方改成你二级域名，就好了。</p><h1 id="二级域名"><a href="#二级域名" class="headerlink" title="二级域名"></a>二级域名</h1><p>比如你购买的域名是aimasa.com，那么你的二级域名就可以是：{自定义}.aimasa.com。但是这只是一般称谓，一般叫它子域名，因为按维基百科上来说，一级域名是顶级域名，是域名的最后一个部分，二级域名是靠近顶级域名的左边一个部分。然后以此类推可以推出三级域名，四级域名等等。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.jianshu.com/p/88c8ba682ac7" target="_blank" rel="noopener">二级域名是什么的博客，我觉得解释的比大多数博客好太多了</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前把图片放在七牛云的图床上，结果因为我的测试域名到期了，一定要绑定一个域名，才能继续用。接着我去阿里云买了个服务器，绑定了一个域名，并且去做了备案【千万考虑清楚，因为我买的是学生机，所以比较便宜。然后开始在思考我为什么那么冲动，买了服务器不知道干啥用，好浪费,所以打算开始学爬虫……】&lt;/p&gt;
    
    </summary>
    
      <category term="hexo更新配置" scheme="http://aimasa.github.io/categories/hexo%E6%9B%B4%E6%96%B0%E9%85%8D%E7%BD%AE/"/>
    
      <category term="七牛云把测试域名替换成已备份域名" scheme="http://aimasa.github.io/categories/hexo%E6%9B%B4%E6%96%B0%E9%85%8D%E7%BD%AE/%E4%B8%83%E7%89%9B%E4%BA%91%E6%8A%8A%E6%B5%8B%E8%AF%95%E5%9F%9F%E5%90%8D%E6%9B%BF%E6%8D%A2%E6%88%90%E5%B7%B2%E5%A4%87%E4%BB%BD%E5%9F%9F%E5%90%8D/"/>
    
    
      <category term="hexo" scheme="http://aimasa.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>关于接口</title>
    <link href="http://aimasa.github.io/2019/05/05/%E5%85%B3%E4%BA%8E%E6%8E%A5%E5%8F%A3/"/>
    <id>http://aimasa.github.io/2019/05/05/关于接口/</id>
    <published>2019-05-05T06:41:31.000Z</published>
    <updated>2019-05-05T06:41:31.343Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>java打包供maven使用</title>
    <link href="http://aimasa.github.io/2019/04/28/java%E6%89%93%E5%8C%85%E4%BE%9Bmaven%E4%BD%BF%E7%94%A8/"/>
    <id>http://aimasa.github.io/2019/04/28/java打包供maven使用/</id>
    <published>2019-04-28T12:36:08.000Z</published>
    <updated>2019-04-29T09:08:47.598Z</updated>
    
    <content type="html"><![CDATA[<p>因为之前老师说好的说让我自己试试怎么对项目打包，然后把包封装成相关依赖，这样可以直接在maven里面添加依赖，然后对包进行调用。</p><a id="more"></a><h1 id="把项目打包"><a href="#把项目打包" class="headerlink" title="把项目打包"></a>把项目打包</h1><p>用的是fatjar对项目进行的打包，又快又方便。</p><p>我用的是eclipse4.4版本，对项目右键会有build FatJar的选项，然后点进去，选择好生成jar包的位置【注意：包存放的文件夹名中间不能有空格，不然包转成依赖语句会报错】，然后jar包就生成了。</p><h1 id="把包转换成依赖"><a href="#把包转换成依赖" class="headerlink" title="把包转换成依赖"></a>把包转换成依赖</h1><p>首先win+R进入cmd命令行，然后cd到该jar包存放的位置，再然后输入以下命令行</p><pre><code>mvn install:install-file -Dfile=jar包的位置 -DgroupId=上面的groupId -DartifactId=上面的artifactId -Dversion=上面的version -Dpackaging=jar</code></pre><p>—————————————————-<a href="https://blog.csdn.net/u012759397/article/details/53437502" target="_blank" rel="noopener">摘自博客</a></p><p>然后回车，一顿操作猛如虎，再新建一个项目，添加：</p><pre><code>&lt;dependency&gt;&lt;groupId&gt;com.qrcode&lt;/groupId&gt;&lt;!--DgroupId等于的参数值--&gt;&lt;artifactId&gt;qr&lt;/artifactId&gt;&lt;!--DartifactId等于的参数值--&gt;&lt;version&gt;0.1&lt;/version&gt;&lt;!--Dversion等于的参数值--&gt;&lt;/dependency&gt;</code></pre><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://blog.csdn.net/u012759397/article/details/53437502" target="_blank" rel="noopener">博客</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;因为之前老师说好的说让我自己试试怎么对项目打包，然后把包封装成相关依赖，这样可以直接在maven里面添加依赖，然后对包进行调用。&lt;/p&gt;
    
    </summary>
    
      <category term="java语法" scheme="http://aimasa.github.io/categories/java%E8%AF%AD%E6%B3%95/"/>
    
      <category term="java打包供maven使用" scheme="http://aimasa.github.io/categories/java%E8%AF%AD%E6%B3%95/java%E6%89%93%E5%8C%85%E4%BE%9Bmaven%E4%BD%BF%E7%94%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>java版本太低</title>
    <link href="http://aimasa.github.io/2019/04/28/java%E7%89%88%E6%9C%AC%E5%A4%AA%E4%BD%8E/"/>
    <id>http://aimasa.github.io/2019/04/28/java版本太低/</id>
    <published>2019-04-28T11:32:56.000Z</published>
    <updated>2019-04-28T12:35:05.900Z</updated>
    
    <content type="html"><![CDATA[<p>导入一个本来是没有语法错误的项目，然后IDE到处报错，说是jdk版本太高，要更改成低版本。</p><a id="more"></a><p>对着被导入的项目点击右键-&gt; properties-&gt;java build path</p><p>然后双击JRE System Library，然后更换jre的版本号（和本地装的jre的版本号一致）</p><center><img src="http://pictures.aimasa.club/static/images/java版本太低/confi.png"></center><p>然后成功</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;导入一个本来是没有语法错误的项目，然后IDE到处报错，说是jdk版本太高，要更改成低版本。&lt;/p&gt;
    
    </summary>
    
      <category term="运行error" scheme="http://aimasa.github.io/categories/%E8%BF%90%E8%A1%8Cerror/"/>
    
      <category term="java版本太低" scheme="http://aimasa.github.io/categories/%E8%BF%90%E8%A1%8Cerror/java%E7%89%88%E6%9C%AC%E5%A4%AA%E4%BD%8E/"/>
    
    
      <category term="运行error" scheme="http://aimasa.github.io/tags/%E8%BF%90%E8%A1%8Cerror/"/>
    
  </entry>
  
  <entry>
    <title>vim的使用心得</title>
    <link href="http://aimasa.github.io/2019/04/23/vim%E7%9A%84%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97/"/>
    <id>http://aimasa.github.io/2019/04/23/vim的使用心得/</id>
    <published>2019-04-23T08:20:24.000Z</published>
    <updated>2019-04-23T12:16:45.053Z</updated>
    
    <content type="html"><![CDATA[<p>因为最近不是b站后台源码被泄露了嘛，然后它用的是go语言，我又不想在windows系统里面装go语言的IDE，然后就在虚拟机里面配置go语言的环境，过程中在里面我用到了一些对vim的操作，在这里特地记录一下。</p><a id="more"></a><h1 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h1><p>直接按<strong>s</strong>键，然后又可以插入，也可以对其中的内容进行修改。</p><h1 id="保存并且推出"><a href="#保存并且推出" class="headerlink" title="保存并且推出"></a>保存并且推出</h1><ul><li>保存：按住esc键，然后输入<strong>:w</strong></li><li>退出：按住esc键，然后输入<strong>:q</strong></li><li>保存且退出：按住esc键，然后输入<strong>:wq</strong></li></ul><h1 id="目前只用到了这些操作方法，所以暂时如此记录"><a href="#目前只用到了这些操作方法，所以暂时如此记录" class="headerlink" title="目前只用到了这些操作方法，所以暂时如此记录"></a>目前只用到了这些操作方法，所以暂时如此记录</h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;因为最近不是b站后台源码被泄露了嘛，然后它用的是go语言，我又不想在windows系统里面装go语言的IDE，然后就在虚拟机里面配置go语言的环境，过程中在里面我用到了一些对vim的操作，在这里特地记录一下。&lt;/p&gt;
    
    </summary>
    
      <category term="ubuntu的使用" scheme="http://aimasa.github.io/categories/ubuntu%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    
      <category term="vim的使用心得" scheme="http://aimasa.github.io/categories/ubuntu%E7%9A%84%E4%BD%BF%E7%94%A8/vim%E7%9A%84%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97/"/>
    
    
      <category term="关于ubuntu" scheme="http://aimasa.github.io/tags/%E5%85%B3%E4%BA%8Eubuntu/"/>
    
  </entry>
  
  <entry>
    <title>eclipse调字体大小</title>
    <link href="http://aimasa.github.io/2019/04/23/eclipse%E8%B0%83%E5%AD%97%E4%BD%93%E5%A4%A7%E5%B0%8F/"/>
    <id>http://aimasa.github.io/2019/04/23/eclipse调字体大小/</id>
    <published>2019-04-23T07:19:48.000Z</published>
    <updated>2019-04-23T07:19:48.632Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>关于maven</title>
    <link href="http://aimasa.github.io/2019/04/18/%E5%85%B3%E4%BA%8Emaven/"/>
    <id>http://aimasa.github.io/2019/04/18/关于maven/</id>
    <published>2019-04-18T07:07:41.000Z</published>
    <updated>2019-04-30T08:32:30.650Z</updated>
    
    <content type="html"><![CDATA[<p>之前一直只是单纯的知道maven是用来加载库的，然后去代码里面调用它。里面<dependencies>&lt;/dependencies&gt;这里面是存放需要被调用的库的依赖。但是maven里面包括的内容除了<dependencies></dependencies>还有别的，所以就去查了一些资料，然后总结在这。</dependencies></p><a id="more"></a><p>Maven 主要帮助用户完成以下 3 个方面的工作：</p><ul><li>生命周期管理，便捷的构建过程；</li><li>依赖管理，方便引入所需依赖 Jar 包；</li><li>仓库管理，提供统一管理所有 Jar 包的工具；</li></ul><p>————-(<a href="https://www.jianshu.com/p/b4ef9978d85d" target="_blank" rel="noopener">摘自博客</a>)</p><p>在建了一个maven项目之后，会发现在项目里面有一个pom.xml文档</p><h1 id="什么是pom"><a href="#什么是pom" class="headerlink" title="什么是pom"></a>什么是pom</h1><p>项目对象模型或POM是Maven的基本工作单元。 它是一个XML文件，其中包含有关Maven用于构建项目的项目和配置详细信息的信息。 它包含大多数项目的默认值。 这方面的例子是：target是构建目录;构建源目录是src / main / java; src / test / java是测试源目录。执行任务时，Maven在当前目录中查找POM。 它读取POM，获取所需的配置信息，然后执行目标。</p><p>maven install时候，会自动把pom里面添加的依赖下载下来。</p><h1 id="maven的生命周期"><a href="#maven的生命周期" class="headerlink" title="maven的生命周期"></a>maven的生命周期</h1><p>maven内部有三个构建生命周期：分别是：clean, default, site</p><p>我在那个博客里面找到了这张展示default构建生命周期核心阶段的图：</p><center><img src="http://pictures.aimasa.club/static/images/关于maven/life.png"></center><p>当执行mvn install时候，maven就会自动执行生命周期中的validate, compile, test, package, verify, install这些阶段，并将 package 生成的包发布到本地仓库中。</p><p>Maven 将构建过程定义为 default lifecycle</p><h2 id="阶段和插件的关系"><a href="#阶段和插件的关系" class="headerlink" title="阶段和插件的关系"></a>阶段和插件的关系</h2><p>就像上面说的那样，maven把构建过程定义成default lifecycle，并且将它里面的一个个阶段划分为phase，但是这些phase只是规定执行顺序，对于每个阶段做什么工作，就要看pom.xml里面的插件（plugins）了。</p><p>pom.xml里面有这么个元素叫<plugins>，它是用来把phase和做的目标<goal>绑定在一起，当要执行某个<phase>时候，就会调用插件来完成绑定的目标，一个阶段里面可以绑定好多个目标，也可以不绑定目标。</phase></goal></plugins></p><p>但是不配置<plugins>也可以，因为maven有默认的<plugins>。</plugins></plugins></p><p>在输出日志里面，会有一系列的 插件(plugin):版本号:<goal>(phase) 输出，可以根据日志里面的这种输出去观察哪些阶段会调用插件去完成那些<goal>了。</goal></goal></p><h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><p>在<dependencies></dependencies>里面的依赖一般都是这种形式出现：</p><pre><code>    &lt;dependency&gt;    &lt;groupId&gt;mysql&lt;/groupId&gt;    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;    &lt;scope&gt;runtime&lt;/scope&gt;    &lt;/dependency&gt;</code></pre><h2 id="关于maven整体"><a href="#关于maven整体" class="headerlink" title="关于maven整体"></a>关于maven整体</h2><p>| groupId|一般用该项目的组织或团体的域名来标识，例如:org.apache.maven.plugins  |</p><p>| artifactId | 代表唯一的工程名 |</p><p>|version| 版本号|</p><p>|packaging| 标识打包的类型，例如有:jar, war, tar |</p><p>|dependencies| 该工程内依赖的其他 jar 包|</p><h2 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h2><p>如果 Maven 在中央仓库中也找不到依赖的库文件，它会停止构建过程并输出错误信息到控制台。为避免这种情况，Maven 提供了远程仓库的概念，它是开发人员自己定制仓库，包含了所需要的代码库或者其他工程中用到的 jar 文件。</p><h2 id=""><a href="#" class="headerlink" title=""></a><respositories></respositories></h2><p>我的理解就是可以通过这个repositories节点，去访问给出的url地址上的这个仓库，去下载自己需要的库，因为这个库在可能是自己的远程仓库里面，就没法从中央仓库里面下载到这个库，所以就使用这个节点，里面配置各种你可能需要用到的远程库。</p><pre><code>&lt;repositories&gt;    &lt;repository&gt;        &lt;id&gt;spring-snapshots&lt;/id&gt;        &lt;name&gt;Spring Snapshots&lt;/name&gt;        &lt;url&gt;https://repo.spring.io/snapshot&lt;/url&gt;        &lt;snapshots&gt;            &lt;enabled&gt;true&lt;/enabled&gt;        &lt;/snapshots&gt;    &lt;/repository&gt;</code></pre><h2 id="Maven-依赖搜索顺序"><a href="#Maven-依赖搜索顺序" class="headerlink" title="Maven 依赖搜索顺序"></a>Maven 依赖搜索顺序</h2><p>当我们执行 Maven 构建命令时，Maven 开始按照以下顺序查找依赖的库：</p><ul><li>步骤 1 － 在本地仓库中搜索，如果找不到，执行步骤 2，如果找到了则执行其他操作。</li><li>步骤 2 － 在中央仓库中搜索，如果找不到，并且有一个或多个远程仓库已经设置，则执行步骤 4，如果找到了则下载到本地仓库中已被将来引用。</li><li>步骤 3 － 如果远程仓库没有被设置，Maven 将简单的停滞处理并抛出错误（无法找到依赖的文件）。</li><li>步骤 4 － 在一个或多个远程仓库中搜索依赖的文件，如果找到则下载到本地仓库已被将来引用，否则 Maven 将停止处理并抛出错误（无法找到依赖的文件）。</li></ul><p>———————————<a href="https://wiki.jikexueyuan.com/project/maven/repositories.html" target="_blank" rel="noopener">摘自极客学院maven教程</a></p><h1 id="关于-xxx-version"><a href="#关于-xxx-version" class="headerlink" title="关于${xxx.version}"></a>关于${xxx.version}</h1><p>一般，会经常看到官网上放出的写maven依赖中有个语句是</p><pre><code>&lt;version&gt;${xxx.version}&lt;version&gt;</code></pre><p>但是maven总是报错，是因为你这里没有指明这个添加的依赖的版本，maven是不会自动给你找到相关依赖的最新版本的包并且去下载的，所以你需要在<properties></properties>里面加上  </p><pre><code>&lt;xxx.version&gt;1.3.0.Final&lt;/xxx.version&gt;</code></pre><p>这样的话，就是<strong>${xxx.version}</strong>的值就是对应给出的<strong>1.3.0.Final</strong>了。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.jianshu.com/p/b4ef9978d85d" target="_blank" rel="noopener">maven入门</a></p><p><a href="https://www.jianshu.com/p/fd43b3d0fdb0" target="_blank" rel="noopener">maven生命周期</a></p><p><a href="https://wiki.jikexueyuan.com/project/maven/repositories.html" target="_blank" rel="noopener">极客学院maven教程</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前一直只是单纯的知道maven是用来加载库的，然后去代码里面调用它。里面&lt;dependencies&gt;&amp;lt;/dependencies&amp;gt;这里面是存放需要被调用的库的依赖。但是maven里面包括的内容除了&lt;dependencies&gt;&lt;/dependencies&gt;还有别的，所以就去查了一些资料，然后总结在这。&lt;/dependencies&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="maven" scheme="http://aimasa.github.io/categories/maven/"/>
    
    
      <category term="maven" scheme="http://aimasa.github.io/tags/maven/"/>
    
  </entry>
  
  <entry>
    <title>开始学习spring（五）：连接数据库</title>
    <link href="http://aimasa.github.io/2019/04/17/%E5%BC%80%E5%A7%8B%E5%AD%A6%E4%B9%A0spring%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9A%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>http://aimasa.github.io/2019/04/17/开始学习spring（五）：连接数据库/</id>
    <published>2019-04-17T03:01:44.000Z</published>
    <updated>2019-05-25T11:26:18.516Z</updated>
    
    <content type="html"><![CDATA[<p>因为这边都用的是jooq框架来对数据库进行操作，然后我就开始学jooq框架惹==。我暑假还是想好好的活着，不想再像上个暑假一样痛苦。</p><p>不过刚开始接触这个框架，坑也没少踩，我会在下面分别列出来。</p><p>用的是maven</p><a id="more"></a><h1 id="第一步：装依赖"><a href="#第一步：装依赖" class="headerlink" title="第一步：装依赖"></a>第一步：装依赖</h1><p>在jooq的官网看，首先第一步，在pom中要加上这三个依赖</p><pre><code>    &lt;dependency&gt;        &lt;groupId&gt;org.jooq&lt;/groupId&gt;        &lt;artifactId&gt;jooq&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.jooq&lt;/groupId&gt;        &lt;artifactId&gt;jooq-meta&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.jooq&lt;/groupId&gt;        &lt;artifactId&gt;jooq-codegen&lt;/artifactId&gt;    &lt;/dependency&gt;</code></pre><ul><li>jooq ：核心包，CRUD（增删查改）核心类所在大本营。</li><li>jooq-meta ：数据管理和操作的核心代码。</li><li>jooq-codegen ：负责数据库代码生成，主要负责JOOQ的代码生成功能。</li></ul><h1 id="第二步：加插件"><a href="#第二步：加插件" class="headerlink" title="第二步：加插件"></a>第二步：加插件</h1><pre><code>        &lt;plugin&gt;            &lt;groupId&gt;org.jooq&lt;/groupId&gt;            &lt;artifactId&gt;jooq-codegen-maven&lt;/artifactId&gt;            &lt;executions&gt;                &lt;execution&gt;                    &lt;goals&gt;                        &lt;goal&gt;generate&lt;/goal&gt;                    &lt;/goals&gt;                &lt;/execution&gt;            &lt;/executions&gt;            &lt;dependencies&gt;                &lt;dependency&gt;                    &lt;groupId&gt;mysql&lt;/groupId&gt;                    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;                    &lt;version&gt;5.1.39&lt;/version&gt;                &lt;/dependency&gt;            &lt;/dependencies&gt;            &lt;configuration&gt;                &lt;jdbc&gt;                    &lt;driver&gt;com.mysql.jdbc.Driver&lt;/driver&gt;                    &lt;url&gt;jdbc:mysql://localhost:3306/exercise_test?useSSL=true&lt;/url&gt;                    &lt;user&gt;root&lt;/user&gt;                    &lt;password&gt;&lt;/password&gt;                &lt;/jdbc&gt;                &lt;generator&gt;                    &lt;database&gt;                        &lt;name&gt;org.jooq.util.mysql.MySQLDatabase&lt;/name&gt;                        &lt;includes&gt;.*&lt;/includes&gt;                        &lt;excludes&gt;&lt;/excludes&gt;                        &lt;inputSchema&gt;exercise_test&lt;/inputSchema&gt;                        &lt;forcedTypes&gt;                            &lt;forcedType&gt;                                &lt;userType&gt;java.util.Date&lt;/userType&gt;                                &lt;converter&gt;com.example.util.DateConverter&lt;/converter&gt;                                &lt;types&gt;datetime&lt;/types&gt;                            &lt;/forcedType&gt;                        &lt;/forcedTypes&gt;                    &lt;/database&gt;                    &lt;target&gt;                        &lt;!-- The destination package of your generated classes (within the                             destination directory) --&gt;                        &lt;packageName&gt;com.example.pojo&lt;/packageName&gt;                        &lt;!-- The destination directory of your generated classes --&gt;                        &lt;directory&gt;/src/main/java&lt;/directory&gt;                    &lt;/target&gt;                    &lt;generate&gt;                        &lt;pojos&gt;true&lt;/pojos&gt;                        &lt;daos&gt;true&lt;/daos&gt;                        &lt;deprecated&gt;false&lt;/deprecated&gt;                    &lt;/generate&gt;                &lt;/generator&gt;            &lt;/configuration&gt;        &lt;/plugin&gt;</code></pre><p>这一部分是用来生成数据库映射代码的插件。</p><p>里面是对数据库的信息进行配置：</p><pre><code>            &lt;configuration&gt;                &lt;jdbc&gt;                    &lt;driver&gt;com.mysql.jdbc.Driver&lt;/driver&gt;                    &lt;url&gt;jdbc:mysql://localhost:3306/exercise_test?useSSL=true&lt;/url&gt;                    &lt;user&gt;root&lt;/user&gt;                    &lt;password&gt;&lt;/password&gt;                &lt;/jdbc&gt;                &lt;generator&gt;                    &lt;database&gt;                        &lt;name&gt;org.jooq.util.mysql.MySQLDatabase&lt;/name&gt;                        &lt;includes&gt;.*&lt;/includes&gt;&lt;!--点后面的所有文件--&gt;                        &lt;excludes&gt;&lt;/excludes&gt;                        &lt;!--映射的数据库的架构名（就是你的表是放在哪个架构下的）--&gt;                        &lt;inputSchema&gt;exercise_test&lt;/inputSchema&gt;                        &lt;forcedTypes&gt;                            &lt;forcedType&gt;                                &lt;userType&gt;java.util.Date&lt;/userType&gt;                                &lt;converter&gt;com.example.util.DateConverter&lt;/converter&gt;                                &lt;types&gt;datetime&lt;/types&gt;                            &lt;/forcedType&gt;                        &lt;/forcedTypes&gt;                    &lt;/database&gt;                    &lt;target&gt;                        &lt;!-- 你数据库映射出来的表打算放在代码里面的哪个包下 --&gt;                        &lt;packageName&gt;com.example.pojo&lt;/packageName&gt;                        &lt;!-- 这个包是应该在哪个class下面 --&gt;                        &lt;directory&gt;/src/main/java&lt;/directory&gt;                    &lt;/target&gt;                    &lt;generate&gt;                        &lt;pojos&gt;true&lt;/pojos&gt;                        &lt;daos&gt;true&lt;/daos&gt;                        &lt;deprecated&gt;false&lt;/deprecated&gt;                    &lt;/generate&gt;                &lt;/generator&gt;            &lt;/configuration&gt;</code></pre><p>这里面配置这段就是把数据库中的表映射出来的。</p><pre><code>                         &lt;forcedTypes&gt;                            &lt;forcedType&gt;                                &lt;userType&gt;java.util.Date&lt;/userType&gt;                                &lt;converter&gt;com.example.util.DateConverter&lt;/converter&gt;                                &lt;types&gt;datetime&lt;/types&gt;                            &lt;/forcedType&gt;                        &lt;/forcedTypes&gt;</code></pre><p>这段代码是用来映射时间戳的，其中</p><pre><code>&lt;converter&gt;com.example.util.DateConverter&lt;/converter&gt;</code></pre><p>是放有映射方法的包，没有放映射方法的话，那这段无效==。可以按ctrl进去，查看这个包，如果无法查看的话，那么说明这个包不是需要的。</p><h1 id="数据库的架构"><a href="#数据库的架构" class="headerlink" title="数据库的架构"></a>数据库的架构</h1><p>放张图就很详细了：</p><center><img src="http://pictures.aimasa.club/static/images/开始学习spring（五）：连接数据库/schema.jpg"></center><h1 id="出错地方"><a href="#出错地方" class="headerlink" title="出错地方"></a>出错地方</h1><p>这样配置完成后，我的这个项目名旁边跟了一个红<strong>×</strong>，所以就右键项目，选中<strong>maven</strong>，出现子目录，选中<strong>update project</strong>，点击，如果配置没有错误的话，红<strong>×</strong>会自然消失。</p><p>然后就是maven install的问题了，显示BUILD FAILED失败，里面有一句话，翻译过来是问我有没有配置错jdk，所以我就去perferences里面的 java-&gt;install JREs看了看里面的包是不是配置的jdk包，如果不是，点击add-&gt;Standard VM-&gt;next-&gt;选择jdk的包</p><p>再然后maven install就没有再出问题了，同时，也将我数据库里的表转换成了pojo的包里的java类了。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="http://www.mysunshinedreams.com/orm%E7%9A%84%E5%B0%8F%E6%B8%85%E6%96%B0-jooq/" target="_blank" rel="noopener">参考博客</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;因为这边都用的是jooq框架来对数据库进行操作，然后我就开始学jooq框架惹==。我暑假还是想好好的活着，不想再像上个暑假一样痛苦。&lt;/p&gt;
&lt;p&gt;不过刚开始接触这个框架，坑也没少踩，我会在下面分别列出来。&lt;/p&gt;
&lt;p&gt;用的是maven&lt;/p&gt;
    
    </summary>
    
      <category term="spring相关" scheme="http://aimasa.github.io/categories/spring%E7%9B%B8%E5%85%B3/"/>
    
      <category term="连接数据库" scheme="http://aimasa.github.io/categories/spring%E7%9B%B8%E5%85%B3/%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="spring相关" scheme="http://aimasa.github.io/tags/spring%E7%9B%B8%E5%85%B3/"/>
    
  </entry>
  
  <entry>
    <title>开始学习spring（四）：Junit测试</title>
    <link href="http://aimasa.github.io/2019/04/10/%E5%BC%80%E5%A7%8B%E5%AD%A6%E4%B9%A0spring%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9AJunit%E6%B5%8B%E8%AF%95/"/>
    <id>http://aimasa.github.io/2019/04/10/开始学习spring（四）：Junit测试/</id>
    <published>2019-04-10T03:11:31.000Z</published>
    <updated>2019-04-12T07:51:27.480Z</updated>
    
    <content type="html"><![CDATA[<p>跟着<a href="http://blog.didispace.com/spring-boot-learning-1/" target="_blank" rel="noopener">博客</a>开始学怎么用Junit对写出的部分代码进行单元测试。</p><a id="more"></a><h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><p>跟着它给的代码：</p><pre><code>@RunWith(SpringJUnit4ClassRunner.class)@SpringBootTest(classes=MockServletContext.class)@WebAppConfigurationpublic class DemoApplicationTests {    private MockMvc mvc;    @Before    public void Setup() throws Exception {        mvc = MockMvcBuilders.standaloneSetup(new exampleController()).build();    }    @Test    public void contextLoads() throws Exception{        mvc.perform(MockMvcRequestBuilders.get(&quot;/&quot;).accept(MediaType.APPLICATION_JSON))                .andExpect(status().isOk())                .andExpect(content().string(equalTo(&quot;index&quot;))).andDo(print());    }}</code></pre><p>但是很奇怪的是一直在</p><pre><code> .andExpect(content().string(equalTo(&quot;index&quot;))).andDo(print());</code></pre><p>这个部分报错，说<strong>The method content()/equalTo() is ambiguous for the type DemoApplicationTests</strong></p><p>结果我发现在我直接敲入这段代码时候，eclipse会直接帮忙自动导入对应的包：</p><pre><code>import static org.hamcrest.CoreMatchers.equalTo;import static org.hamcrest.Matchers.equalTo;import static org.springframework.test.web.client.match.MockRestRequestMatchers.content;import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;</code></pre><p>里面会有不同包里面的同名称的类文件，在这里我们选用：</p><pre><code>import static org.hamcrest.Matchers.equalTo;import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;</code></pre><h1 id="讲解"><a href="#讲解" class="headerlink" title="讲解"></a>讲解</h1><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><h3 id="MockMvcBuilders"><a href="#MockMvcBuilders" class="headerlink" title="MockMvcBuilders"></a>MockMvcBuilders</h3><p>这个是用来构造MockMvc的构造器，主要是有两种实现，分别是StandaloneMockMvcBuilder和DefaultMockMvcBuilder一种是独立安装和集成Web环境测试（此种方式并不会集成真正的web环境，而是通过相应的Mock API进行模拟测试，无须启动服务器）。</p><p>较新版的Spring Boot取消了@SpringApplicationConfiguration这个注解，用@SpringBootTest就可以了</p><h3 id="集成web环境测试"><a href="#集成web环境测试" class="headerlink" title="集成web环境测试"></a>集成web环境测试</h3><p>MockMvcBuilders.webAppContextSetup(WebAppContext webAppContext):指定的webAPPContext会从<strong>上下文中去获取相应的控制器</strong>并得到相应的MockMvc</p><p>怎么获取呢？所以就在测试的程序前面加上@ContextConfiguration(classes = xxx.class)（xxx.class是自己定义的配置类，继承WebMvcConfigurerAdapter 这个类的类，新版spring boot不用继承这类再去使用了，会报错，它改成直接用接口形式implements这个类，并且去使用，还有一个方法来着去使用这个类，但是我忘了，可以直接谷歌一下，WebMvcConfigurerAdapter配置类其实是Spring内部的一种配置方式，采用JavaBean的形式来代替传统的xml配置文件形式进行针对框架个性化定制，它是对需要进行拦截的地方是要使用的拦截器配好对）。</p><p>（拦截器是什么：拦截器相当于把一部分会需要经常改动的代码提取出来，然后对一些固有操作执行前进行拦截，去运行在不同情况下需要运行的代码。减少代码的冗余度，提高重用率。也就是AOP的一种运用。）</p><p>如果没有@ContextConfiguration是会报错的。</p><p>@WebAppConfiguration：测试环境使用，用来表示测试环境使用的ApplicationContext将是WebApplicationContext类型的；value指定web应用的根；</p><p>@Autowired WebApplicationContext wac:注入web环境的applicationContext容器；</p><p>然后通过MockMvcBuilders.webAppContextSetup(this.wac).build();创建一个MockMvc去测试。</p><h3 id="独立测试方式"><a href="#独立测试方式" class="headerlink" title="独立测试方式"></a>独立测试方式</h3><p>这个MockMvcBuilders.standaloneSetup(Object… controllers)可以通过参数去指定一组或者一个控制器，而不需要上下文获取了。</p><p>只需两个步骤：创建相应的控制器，然后注入相应的依赖；通过MockMvcBuilders.standaloneSetup(Object… controllers).bulid()去获取一个MockMvc去测试。</p><h2 id="RequestBuilder"><a href="#RequestBuilder" class="headerlink" title="RequestBuilder"></a>RequestBuilder</h2><p>RequestBuilder这个是用来存放模拟输入的命令的。比如在这里我要测试控制层的输出结果是不是我想要的，然后我会用RequestBuilder.get/post/put…(/网址/).param()…这样去模拟数据输入，进而测试程序有没有错误。</p><pre><code>        request = get(&quot;/users/&quot;);</code></pre><p>RequestBuilder执行完这一步之后，里面会存放如下参数：</p><center><img src="http://pictures.aimasa.club/static/images/开始学习spring（四）：Junit测试/RequestBuilder.png"></center><p>可以从图中看到里面有我刚开始设置进去的网址”/users”,然后其他值设置之类地方都是显示null，或者[]或者{}。</p><h1 id="关于content-string-equalTo-xxx"><a href="#关于content-string-equalTo-xxx" class="headerlink" title="关于content().string(equalTo(xxx))"></a>关于content().string(equalTo(xxx))</h1><p>跟着敲完对控制层的测试类之后，一直报错，我debug发现，不是程序里面的问题，是我参数出的问题。</p><p>我里面的参数不是少了对字符串的外标的双引号，就是字符串的排列顺序不对</p><p>我设置的返回值是对User实例化后的字符串的值的返回</p><pre><code>public class User {    private String name;    private long id;    private Integer age;}</code></pre><p>里面按照顺序需要：name 、 id 、 age这个顺序返回值，然后碰到字符串时候，需要上标双引号，但是因为本身我就是设置它需要根据我给出的字符串去比较是不是我想要的结果，所以在content().string(equalTo(xxx))里面，xxx这个字符串中的双引号需要转义字符：\”</p><pre><code>content().string(equalTo(&quot;[{\&quot;name\&quot;:\&quot;nana\&quot;,\&quot;id\&quot;:1,\&quot;age\&quot;:12}]&quot;))).andDo(print())</code></pre><h2 id="测试部分"><a href="#测试部分" class="headerlink" title="测试部分"></a>测试部分</h2><p>perform：执行一个RequestBuilder请求，会自动执行SpringMVC的流程并映射到相应的控制器执行处理；</p><p>andExpect：添加ResultMatcher验证规则，验证控制器执行完成后结果是否正确；</p><p>andDo：添加ResultHandler结果处理器，比如调试时打印结果到控制台；</p><p>andReturn：最后返回相应的MvcResult；然后进行自定义验证/进行下一步的异步处理；</p><p>accept：接收的返回的信息格式，这里是接收的是json类型数据。</p><p>ContentResultMatchers content()：得到响应内容验证器；</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://blog.csdn.net/cankingapp/article/details/7626566" target="_blank" rel="noopener">关于拦截器讲解比较详细的博客</a></p><p><a href="https://www.cnblogs.com/lyy-2016/p/6122144.html" target="_blank" rel="noopener">关于测试部分讲解详细的博客</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;跟着&lt;a href=&quot;http://blog.didispace.com/spring-boot-learning-1/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;博客&lt;/a&gt;开始学怎么用Junit对写出的部分代码进行单元测试。&lt;/p&gt;
    
    </summary>
    
      <category term="spring相关" scheme="http://aimasa.github.io/categories/spring%E7%9B%B8%E5%85%B3/"/>
    
      <category term="Junit测试" scheme="http://aimasa.github.io/categories/spring%E7%9B%B8%E5%85%B3/Junit%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="spring相关" scheme="http://aimasa.github.io/tags/spring%E7%9B%B8%E5%85%B3/"/>
    
  </entry>
  
  <entry>
    <title>开始学习spring（三）：注解2</title>
    <link href="http://aimasa.github.io/2019/04/08/%E5%BC%80%E5%A7%8B%E5%AD%A6%E4%B9%A0spring%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E6%B3%A8%E8%A7%A32/"/>
    <id>http://aimasa.github.io/2019/04/08/开始学习spring（三）：注解2/</id>
    <published>2019-04-08T13:14:34.000Z</published>
    <updated>2019-05-24T01:56:35.433Z</updated>
    
    <content type="html"><![CDATA[<p>虽然明白注解是怎么一回事了，但是还是好奇它的反射机制是怎么实现的，所以谷歌了一下，之后可能会试着自己看看源码。</p><p>注：在 Spring 中，构成应用程序主干并由Spring IoC容器管理的对象称为bean。bean是一个由Spring IoC容器实例化、组装和管理的对象。</p><p><a href="https://www.awaimai.com/2596.html" target="_blank" rel="noopener">关于IoC(控制反转)</a></p><a id="more"></a><h1 id="RequestMapping"><a href="#RequestMapping" class="headerlink" title="RequestMapping"></a>RequestMapping</h1><p>这个是用来处理请求地址映射的注解，它的注解有六个属性：</p><h2 id="value"><a href="#value" class="headerlink" title="value"></a>value</h2><p><strong>value</strong>：指定请求的实际地址</p><p><strong>method</strong>： 指定请求的method类型， GET、POST、PUT、DELETE等；</p><center><img src="http://pictures.aimasa.club/static/images/开始学习spring（三）：注解2/method.png"></center><p><strong>consumes</strong>：指定处理请求的提交内容类型（Content-Type），例如application/json, text/html;</p><p><strong>produces</strong>: 指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回；</p><p><strong>params</strong>： 指定request中必须包含某些参数值是，才让该方法处理。</p><p><strong>headers</strong>： 指定request中必须包含某些指定的header值，才能让该方法处理请求。</p><h2 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h2><p>对服务类进行注解标记，让@componentScan将这些类装载注入到Spring的bean容器中，或者如果没有@ComponentScan这个注解的话，spring会自动去扫描Application这个类所在的包列表下面的类，如果含有@Service标注，那么被看做是服务类被装入spring的bean容器里面。</p><h2 id="Repository"><a href="#Repository" class="headerlink" title="Repository"></a>Repository</h2><p>@Repository标记该类为数据层，Dao层。</p><h2 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h2><p>@Controller层用于标记该类为控制层。</p><h2 id="Autowired"><a href="#Autowired" class="headerlink" title="Autowired"></a>Autowired</h2><p>———————-<a href="https://blog.csdn.net/walkerJong/article/details/7994326" target="_blank" rel="noopener">摘自博客</a>等我用了一遍再回来补充。</p><h2 id="ResponseStatus"><a href="#ResponseStatus" class="headerlink" title="@ResponseStatus"></a>@ResponseStatus</h2><p>@ResponseStatus这个注解是做异常处理的，然后可以自定义异常。当我们的Controller抛出异常，并且没有被处理的时候，他将返回HTTP STATUS 为指定值的 HTTP RESPONSE.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;虽然明白注解是怎么一回事了，但是还是好奇它的反射机制是怎么实现的，所以谷歌了一下，之后可能会试着自己看看源码。&lt;/p&gt;
&lt;p&gt;注：在 Spring 中，构成应用程序主干并由Spring IoC容器管理的对象称为bean。bean是一个由Spring IoC容器实例化、组装和管理的对象。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.awaimai.com/2596.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;关于IoC(控制反转)&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="spring相关" scheme="http://aimasa.github.io/categories/spring%E7%9B%B8%E5%85%B3/"/>
    
      <category term="注解" scheme="http://aimasa.github.io/categories/spring%E7%9B%B8%E5%85%B3/%E6%B3%A8%E8%A7%A3/"/>
    
      <category term="spring注解" scheme="http://aimasa.github.io/categories/spring%E7%9B%B8%E5%85%B3/%E6%B3%A8%E8%A7%A3/spring%E6%B3%A8%E8%A7%A3/"/>
    
    
      <category term="spring相关" scheme="http://aimasa.github.io/tags/spring%E7%9B%B8%E5%85%B3/"/>
    
  </entry>
  
  <entry>
    <title>开始学习spring（三）：注解</title>
    <link href="http://aimasa.github.io/2019/04/04/%E5%BC%80%E5%A7%8B%E5%AD%A6%E4%B9%A0spring%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E6%B3%A8%E8%A7%A3/"/>
    <id>http://aimasa.github.io/2019/04/04/开始学习spring（三）：注解/</id>
    <published>2019-04-04T06:49:42.000Z</published>
    <updated>2019-05-24T01:55:59.421Z</updated>
    
    <content type="html"><![CDATA[<p>因为spring Boot项目里面一直要用到注解，所以我特地开了一篇文章来介绍元注解和自定义注解。关于@ResponseMapping这类经常用到的注解可能会零开一篇去写。</p><p>现有的spring提供了大量的注解，而且点进去会发现它的源码很短，注解中用到的Annotations元注解其实只是元数据，和业务逻辑一点关系都没有，既然和业务逻辑没有关系，那么就必须有人来实现这些逻辑。Annotations仅仅提供它定义的属性(类/方法/包/域)的信息.</p><p>当我们使用Java的标注Annotations(例如@Override)时，JVM就是一个用户，它在字节码层面工作。</p><p>bean 是组件的意思。</p><a id="more"></a><h1 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h1><p>一共有以下个元注解</p><ul><li>@Document</li><li>@Target</li><li>@Retention</li><li>@Inherited</li></ul><h2 id="Target"><a href="#Target" class="headerlink" title="@Target"></a>@Target</h2><p>它是用来约束注解的使用范围的，可以用ElementType类型去给它定义使用范围，一下是它的源代码：</p><pre><code>public enum ElementType {    /** Class, interface (including annotation type), or enum declaration */    TYPE,    /** Field declaration (includes enum constants) */    FIELD,    /** Method declaration */    METHOD,    /** Formal parameter declaration */    PARAMETER,    /** Constructor declaration */    CONSTRUCTOR,    /** Local variable declaration */    LOCAL_VARIABLE,    /** 用于另外一个注解上 */    ANNOTATION_TYPE,    /** Package declaration */    PACKAGE,    /**     * Type parameter declaration     *     * @since 1.8     */    TYPE_PARAMETER,    /**     * Use of a type     *     * @since 1.8     */    TYPE_USE}</code></pre><p>如果这个注解中@Target没有被申明，那么意思是它可以被应用在任何元素之上。</p><h1 id="Retention"><a href="#Retention" class="headerlink" title="@Retention"></a>@Retention</h1><p>这个元注解是用来约束注解的生命周期的。里面有三个状态，一个是源码级别（source）、一个是类文件级别（class）、还一个是运行时级别（runtime）</p><ul><li>source ： 注解将被编译器丢弃（这个类型的注解信息只保留在源码里面，源码经过编译后，注解信息会被丢弃，不会保留在编译好的class里面。）如java内置注解：@Override、@SuppressWarnning等</li><li>class ： 注解在class文件里可用，但是会被vm（虚拟机）抛弃（这个类型的注解信息只会保存在源码里面和class文件里面，在运行时候，不会载入虚拟机里面），<strong>当注解没有定义Retention的时候，会默认是class</strong>，如java内置注解：</li><li>runtime ： 注解信息将在运行期（JVM）中也保留，因此可以通过反射机制读取注解的信息。（源码、class文件和虚拟机中都有注解的信息。）如SpringMvc中的@Controller、@Autowired、@RequestMapping等，如java内置注解：@Deprecated(用于标明已经过时的方法或类)等。</li></ul><h1 id="Documented"><a href="#Documented" class="headerlink" title="@Documented"></a>@Documented</h1><p>@Documented 被修饰的注解会生成到javadoc中</p><h1 id="Inherited"><a href="#Inherited" class="headerlink" title="@Inherited"></a>@Inherited</h1><p>可以让注解被继承，但这并不是真的继承，只是通过使用@Inherited，可以让子类Class对象使用getAnnotations()获取父类被@Inherited修饰的注解。</p><h1 id="关于自定义注解里面的一些语句"><a href="#关于自定义注解里面的一些语句" class="headerlink" title="关于自定义注解里面的一些语句"></a>关于自定义注解里面的一些语句</h1><pre><code>String name() default &quot;&quot;;//指定义了name这个属性，默认是空字符串。</code></pre><p>声明注解类型时候，不能用包装类型，只能用基本类型去声明</p><pre><code>@Target({ElementType.TYPE})@Retention(RetentionPolicy.RUNTIME)@Documented@Componentpublic @interface Controller {    @AliasFor(annotation = Component.class)    String value() default &quot;&quot;;}</code></pre><p>因为上面除掉元注解外还有@component，说明@controller这个注解属于@component这个注解</p><p>我们定义了自己的注解并将其应用在业务逻辑的方法上。所以就需要我们写一个用户程序调用我们的注解。这里需要使用<strong>反射机制</strong>。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://blog.csdn.net/javazejian/article/details/71860633" target="_blank" rel="noopener">我觉得写得很详细的</a></p><p><a href="http://www.importnew.com/10294.html" target="_blank" rel="noopener">注解是什么</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;因为spring Boot项目里面一直要用到注解，所以我特地开了一篇文章来介绍元注解和自定义注解。关于@ResponseMapping这类经常用到的注解可能会零开一篇去写。&lt;/p&gt;
&lt;p&gt;现有的spring提供了大量的注解，而且点进去会发现它的源码很短，注解中用到的Annotations元注解其实只是元数据，和业务逻辑一点关系都没有，既然和业务逻辑没有关系，那么就必须有人来实现这些逻辑。Annotations仅仅提供它定义的属性(类/方法/包/域)的信息.&lt;/p&gt;
&lt;p&gt;当我们使用Java的标注Annotations(例如@Override)时，JVM就是一个用户，它在字节码层面工作。&lt;/p&gt;
&lt;p&gt;bean 是组件的意思。&lt;/p&gt;
    
    </summary>
    
      <category term="spring相关" scheme="http://aimasa.github.io/categories/spring%E7%9B%B8%E5%85%B3/"/>
    
      <category term="注解" scheme="http://aimasa.github.io/categories/spring%E7%9B%B8%E5%85%B3/%E6%B3%A8%E8%A7%A3/"/>
    
      <category term="注解大体简介" scheme="http://aimasa.github.io/categories/spring%E7%9B%B8%E5%85%B3/%E6%B3%A8%E8%A7%A3/%E6%B3%A8%E8%A7%A3%E5%A4%A7%E4%BD%93%E7%AE%80%E4%BB%8B/"/>
    
    
      <category term="spring相关" scheme="http://aimasa.github.io/tags/spring%E7%9B%B8%E5%85%B3/"/>
    
  </entry>
  
</feed>

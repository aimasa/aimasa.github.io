<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>aimasa的个人博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://aimasa.github.io/"/>
  <updated>2019-08-23T14:15:40.389Z</updated>
  <id>http://aimasa.github.io/</id>
  
  <author>
    <name>ZHY</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>python语法记录</title>
    <link href="http://aimasa.github.io/2019/08/21/python%E8%AF%AD%E6%B3%95%E8%AE%B0%E5%BD%95/"/>
    <id>http://aimasa.github.io/2019/08/21/python语法记录/</id>
    <published>2019-08-21T03:17:19.000Z</published>
    <updated>2019-08-23T14:15:40.389Z</updated>
    
    <content type="html"><![CDATA[<p>这是在学习kmeans时候碰到的一些语法问题，先记下来，方便日后使用</p><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">power(vector2 - vector1, <span class="number">2</span>)</span><br></pre></td></tr></table></figure><p><code>power</code>是<code>numpy</code>这个类的一个运算函数，是用来计算次方的，上面那行代码意思是计算$(vector2 - vector1)^{2}$,所以<code>power(x,y)</code>是计算$\,x^{y}\,$这个公式的.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sum(power(vector2 - vector1, <span class="number">2</span>))</span><br></pre></td></tr></table></figure><p><code>sum</code>也是<code>numpy</code>这个类的一个运算函数，但是在上式中vector是一个二维数组（可以这样说，是n行两列的矩阵中取的第一行），<code>num(x,y)</code>运算是$x + y$，所以里面就是<code>power(vector2 - vector1, 2)</code>计算出来的数组里面的第一行第一列和第二行第二列的数值相加。（等有机会试试<code>sum</code>的括号里放多行两列数组）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是在学习kmeans时候碰到的一些语法问题，先记下来，方便日后使用&lt;/p&gt;
    
    </summary>
    
      <category term="python语法" scheme="http://aimasa.github.io/categories/python%E8%AF%AD%E6%B3%95/"/>
    
      <category term="numpy语法记录" scheme="http://aimasa.github.io/categories/python%E8%AF%AD%E6%B3%95/numpy%E8%AF%AD%E6%B3%95%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="python语法" scheme="http://aimasa.github.io/tags/python%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>toString()和new String()</title>
    <link href="http://aimasa.github.io/2019/08/19/java%E7%9A%84%E8%BD%AC%E6%8D%A2String/"/>
    <id>http://aimasa.github.io/2019/08/19/java的转换String/</id>
    <published>2019-08-19T02:38:25.000Z</published>
    <updated>2019-08-21T06:53:46.498Z</updated>
    
    <content type="html"><![CDATA[<p>用byte[]转换成String类型的时候，我用了(byte[]).toString()去转换，然后返回的结果居然是xxx@xxxx这个字符串，然后我很懵，点进源码才明白原因。</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getClass().getName() + <span class="string">"@"</span> + Integer.toHexString(hashCode());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是把类的类名加上“@”加上做的hashcode值转换成字符串返回输出，byte[]是个数组，是一个对象，所有的对象都是object的子类，所以数组可以使用object的方法，在object的方法里有toString()这个方法，但在没有被复写的情况下使用它，就会生成<code>getClass().getName() + &quot;@&quot; + Integer.toHexString(hashCode())</code>这个字符串。</p><p>所以我们用new String()的方式去转换byte[]值，将其变成String字符串输出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">byte</span> bytes[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(bytes, <span class="number">0</span>, bytes.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">byte</span> bytes[], <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    checkBounds(bytes, offset, length);</span><br><span class="line">    <span class="keyword">this</span>.value = StringCoding.decode(bytes, offset, length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是这两种方法的输出结果</p><center><img src="http://pictures.aimasa.club/static/images/java的转换String/example.png"></center><h1 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h1><p><a href="https://blog.csdn.net/mrbacker/article/details/81638331" target="_blank" rel="noopener">数组相关概念</a></p><p><a href="https://zhidao.baidu.com/question/267505870.html" target="_blank" rel="noopener">关于object的子类</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;用byte[]转换成String类型的时候，我用了(byte[]).toString()去转换，然后返回的结果居然是xxx@xxxx这个字符串，然后我很懵，点进源码才明白原因。&lt;/p&gt;
    
    </summary>
    
      <category term="java语法" scheme="http://aimasa.github.io/categories/java%E8%AF%AD%E6%B3%95/"/>
    
      <category term="toString()和new String()" scheme="http://aimasa.github.io/categories/java%E8%AF%AD%E6%B3%95/toString-%E5%92%8Cnew-String/"/>
    
    
      <category term="java语法" scheme="http://aimasa.github.io/tags/java%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>电话号码的字母组合</title>
    <link href="http://aimasa.github.io/2019/08/05/%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/"/>
    <id>http://aimasa.github.io/2019/08/05/电话号码的字母组合/</id>
    <published>2019-08-05T03:09:32.000Z</published>
    <updated>2019-08-07T12:31:29.495Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个仅包含数字 <code>2-9</code> 的字符串，返回所有它能表示的字母组合。</p><p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p><center><img src="http://pictures.aimasa.club/static/images/电话号码的字母组合/problem.png"></center><p><a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/" target="_blank" rel="noopener">题目来源</a></p><a id="more"></a><h1 id="解答方法"><a href="#解答方法" class="headerlink" title="解答方法"></a>解答方法</h1><p>这个题目暴力破解的话至少要双重循环，更甚，然后我在这题里面学习了一下怎么用递归。</p><h2 id="关于递归"><a href="#关于递归" class="headerlink" title="关于递归"></a>关于递归</h2><p>递归的话就是把一个庞大的问题细化成一个细小的问题，当然，这个庞大的问题的必须是可以重复的，机械的问题。</p><p>我特地去找了一下递归的说明：</p><ol><li><strong>明确递归终止条件</strong>：就是让递归及时终止，这样递归就不会一直一直执行下去</li><li><strong>给出递归终止时的处理办法</strong>：终止时候需要执行什么，这也是需要写的。</li><li><strong>提取重复的逻辑，缩小问题规模</strong></li></ol><p>里面重要的还是对递归问题进行提取重复逻辑。</p><p>因为我对递归不是很了解，所以我打算在这记一下我跟着官方题解弄懂的怎么缩小大的问题规模</p><h2 id="分析逻辑"><a href="#分析逻辑" class="headerlink" title="分析逻辑"></a>分析逻辑</h2><center><img src="http://pictures.aimasa.club/static/images/电话号码的字母组合/tree.png"></center><p>假设输入的数字是“23“，然后”2“分支出去”abc“，三个支，再由”abc“分支，每个支都会连接到3里面的每个分支。</p><p>这就是可以被提取出来的重复逻辑。</p><p>可以从“2”中的分支递归。我们先把重复逻辑提取出来，重复的逻辑就是把数字对应的字母分支开来，然后继续分支下去，如此循环往复。</p><p>所以就用到了for循环，先对分支的顶端进行处理，也就是“2”分出来的“abc”三个分支。</p><p>我们要把结果存储到list列表里面，那么在递归结束后，要把输出的结果add进list中</p><p>流程就变成了这样：</p><center><img src="http://pictures.aimasa.club/static/images/电话号码的字母组合/info.png"></center><p>【注：里面有错别字：是==第一个循环==】</p><p>这样就能把这个分支用递归的办法全部遍历一遍了。</p><p>也就是：我从第一层开始就对“2”指向的全部字母进行一个循环，循环中我再对跟在“2”后面的“3”指向的字母再次进行一个循环（也就是循环中进行递归），在循环的过程中，如果“3”后面还跟有其他数字的话，那我继续对“3”后面跟着的数字指向的字母进行循环，但如果“3”是最后一个数字的话，我把“3”指向的字母遍历完就可以返回上一层递归了，直到最后返回到最顶层，返回最终的结果。</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://blog.csdn.net/HD243608836/article/details/79973010" target="_blank" rel="noopener">关于递归的特点以及注意点</a></p><p><a href="">代码实现</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个仅包含数字 &lt;code&gt;2-9&lt;/code&gt; 的字符串，返回所有它能表示的字母组合。&lt;/p&gt;
&lt;p&gt;给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;http://pictures.aimasa.club/static/images/电话号码的字母组合/problem.png&quot;&gt;&lt;/center&gt;



&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目来源&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://aimasa.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="电话号码的字母组合" scheme="http://aimasa.github.io/categories/%E7%AE%97%E6%B3%95/%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/"/>
    
    
      <category term="算法" scheme="http://aimasa.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>三数之和</title>
    <link href="http://aimasa.github.io/2019/07/22/%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <id>http://aimasa.github.io/2019/07/22/三数之和/</id>
    <published>2019-07-22T06:14:29.000Z</published>
    <updated>2019-08-15T05:47:06.163Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。</p><p>注意：答案中不可以包含重复的三元组。</p><p>例如, 给定数组 <code>nums = [-1, 0, 1, 2, -1, -4]</code>，</p><p>满足要求的三元组集合为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [-1, 0, 1],</span><br><span class="line">  [-1, -1, 2]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/3sum" target="_blank" rel="noopener">力扣（LeetCode）</a></p><a id="more"></a><p>先排序（<code>java</code>里面有<code>Arrays.sort()</code>这个方法进行排序，不过我自己用的是自己写的二分排序对这个数组进行的排序）</p><p>排完序，就能够更方便的去查找满足条件并且不重复的三元组了。</p><p>我们对三元组进行与两元组查找相似的操作，不过三元组多了一个元素而已。</p><p>所以先介绍两元组的和的查找办法</p><h2 id="两元组相加办法"><a href="#两元组相加办法" class="headerlink" title="两元组相加办法"></a>两元组相加办法</h2><p><center><img src="http://pictures.aimasa.club/static/images/三数之和\first.png"></center><br>因为现在这个数组是经过排序预处理的数组，所以接下来的查找中，left指向的数字和right指向的数字相加，比预计和要大的话，那么left就要向左边移动一位，就是<code>left--</code>；如果比预计和小的话，那么right要往右边移动一位，就是<code>right++</code>。</p><p>因为题目中要求的二元组是不能有重复的元素存在，所以在指针移动的过程中，我们要去对指针指向的数据进行判断，如果<code>right</code>和<code>left</code>指向的下一个元素与自己指向的上一个元素相同的时候，可以直接跳过，无需再次进行计算。（两点确定一条直线）</p><p><a href="https://github.com/aimasa/exercise_demo/tree/master/src/exercise/demo/twosun" target="_blank" rel="noopener">代码示例</a></p><h2 id="三元组相加办法"><a href="#三元组相加办法" class="headerlink" title="三元组相加办法"></a>三元组相加办法</h2><p>三元组比两元组多了一个元素，在两元组查找的基础上，再添加一层循环。</p><p>也就是一个最初的循环，然后在那个循环里面开始两元组的查找办法。有个需要注意的要点就是：三元组里面可能会出现的重复。</p><p>当我们对初始数据进行预处理（排序）后，相同元素会排在一块。所以需要避免相同三元组出现的话，就需要保证每次遍历的元素都是独一无二的，这是建立在二元组基础上的三元组需要注意的地方。</p><p><a href="https://github.com/aimasa/exercise_demo/tree/master/src/exercise/demo/threesum" target="_blank" rel="noopener">代码示例</a></p><h1 id="四元组相加办法"><a href="#四元组相加办法" class="headerlink" title="四元组相加办法"></a>四元组相加办法</h1><p>四元组又比三元组多了一个元素</p><p>所以又在外层加了一层循环语句，为了让复杂度小于o($n^{3}$)，我们对循环进行了一些操作，又叫剪枝。</p><p>剪枝把可能会产生重复四元组的情况去掉了，也把可能在对四元组的其中一个元素做循环，但没有能和这个元素产生结果的情况去掉了。</p><p>emm，也就是假如是[-1,0,1,2,-1,-4]这个数组我想要的目标值是0，但当我最外层循环指向-4时候，第二层循环，加上第三层循环都不可能能够找到-4和哪三个数相加得到0的时候，我就需要在预判断时候，就能够跳出循环，以避免产生更多的不必要的运算。</p><p>所以，剪枝我的办法是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;<span class="keyword">continue</span>;&#125;</span><br><span class="line"><span class="keyword">if</span>(nums[i] + nums[i + <span class="number">1</span>] + nums[i + <span class="number">2</span>] + nums[i + <span class="number">3</span>] &gt; target)       </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(nums[i] + nums[n] + nums[n - <span class="number">1</span>] + nums[n - <span class="number">2</span>] &lt; target) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>预判断最外层指定的元素可不可能是想要的四元组的成员之一。</p><p>或者预判断最外层和次外层指定的两个元素可不可能和另外两个元素产生想要的四元组。</p><p>同时剪枝还需要去重：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;<span class="keyword">continue</span>;&#125;</span><br></pre></td></tr></table></figure><p>判断当前指向的这个元素是不是这个指针上一个地方指向的是同一个元素，如果是，那指向下一个元素。这个去重是三层循环都必须需要的步骤，这样可以安全的去掉可能产生一样的四元组的可能。</p><p><a href="https://github.com/aimasa/exercise_demo/tree/master/src/exercise/demo/foursum" target="_blank" rel="noopener">四元组之和代码示范</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。&lt;/p&gt;
&lt;p&gt;注意：答案中不可以包含重复的三元组。&lt;/p&gt;
&lt;p&gt;例如, 给定数组 &lt;code&gt;nums = [-1, 0, 1, 2, -1, -4]&lt;/code&gt;，&lt;/p&gt;
&lt;p&gt;满足要求的三元组集合为：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [-1, 0, 1],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [-1, -1, 2]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/3sum&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;力扣（LeetCode）&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://aimasa.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="三数之和" scheme="http://aimasa.github.io/categories/%E7%AE%97%E6%B3%95/%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    
    
      <category term="算法" scheme="http://aimasa.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式匹配</title>
    <link href="http://aimasa.github.io/2019/07/18/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/"/>
    <id>http://aimasa.github.io/2019/07/18/正则表达式匹配/</id>
    <published>2019-07-18T08:26:52.000Z</published>
    <updated>2019-07-18T08:27:31.754Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="算法" scheme="http://aimasa.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="正则表达式匹配" scheme="http://aimasa.github.io/categories/%E7%AE%97%E6%B3%95/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/"/>
    
    
      <category term="算法" scheme="http://aimasa.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>整数反转</title>
    <link href="http://aimasa.github.io/2019/07/18/%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/"/>
    <id>http://aimasa.github.io/2019/07/18/整数反转/</id>
    <published>2019-07-18T03:29:49.000Z</published>
    <updated>2019-07-18T08:12:32.608Z</updated>
    
    <content type="html"><![CDATA[<p>给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。</p><p>示例 1:</p><pre><code>输入: 123输出: 321</code></pre><p>示例 2:</p><pre><code>输入: -123输出: -321</code></pre><p>示例 3:</p><pre><code>输入: 120输出: 21</code></pre><p>注意:</p><p>假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 <code>[−231,  231 − 1]</code>。请根据这个假设，如果反转后整数溢出那么就返回 0。</p><p><a href="https://leetcode-cn.com/problems/reverse-integer" target="_blank" rel="noopener">力扣（LeetCode）</a></p><a id="more"></a><p>这个我先把整数转成<code>string</code>形式，然后再重新把这个字符串拼接，最后输出的字符串转换成整数即可，不过要先转换成<code>long</code>类型整数，再转换成<code>int</code>类型，不然会溢出的。</p><p>官方给的解答是：</p><p>对该整数循环进行整除10，直到最后结果为零才停止循环，在和该数除以10的余数相加，中途记住判断是否溢出即可。</p><p>因为太简单，直接放代码把。</p><p><a href="https://github.com/aimasa/exercise_demo/blob/master/src/exercise/demo/reversea" target="_blank" rel="noopener">代码</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。&lt;/p&gt;
&lt;p&gt;示例 1:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入: 123
输出: 321
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;示例 2:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入: -123
输出: -321
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;示例 3:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入: 120
输出: 21
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;注意:&lt;/p&gt;
&lt;p&gt;假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 &lt;code&gt;[−231,  231 − 1]&lt;/code&gt;。请根据这个假设，如果反转后整数溢出那么就返回 0。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/reverse-integer&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;力扣（LeetCode）&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://aimasa.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="整数反转" scheme="http://aimasa.github.io/categories/%E7%AE%97%E6%B3%95/%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/"/>
    
    
      <category term="算法" scheme="http://aimasa.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>z字形变换</title>
    <link href="http://aimasa.github.io/2019/07/18/z%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2/"/>
    <id>http://aimasa.github.io/2019/07/18/z字形变换/</id>
    <published>2019-07-18T02:06:03.000Z</published>
    <updated>2019-08-21T06:53:55.183Z</updated>
    
    <content type="html"><![CDATA[<p>将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。</p><p>比如输入字符串为 “LEETCODEISHIRING” 行数为 3 时，排列如下：</p><pre><code>L   C   I   RE T O E S I I GE   D   H   N</code></pre><p>之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：”LCIRETOESIIGEDHN”。</p><p><a href="https://leetcode-cn.com/problems/zigzag-conversion" target="_blank" rel="noopener">力扣（LeetCode）</a></p><a id="more"></a><p>我用暴力破解，z形输出了输入的字符串，结果发现看错了题目……只是要我z形排序。</p><p>然后官方题解特别简洁</p><p>它先是创建了一个列表，这个列表的长度代表了z字形需要被分成的行数（n = 3时候list.length = 3）</p><p>列表里面装的元素类型是stringBuffer，把每行会被输出的内容拼接在一起，如图：</p><p><center><img src="http://pictures.aimasa.club/static/images/z字形变换/example.png"></center><br><code>flag</code>就是一个布尔（Boolean）值，用来判断z字形输出的走向，应该往上走还是往下走。它控制的是list存储里面应该往上存储还是向下存储，换句话来说就是<code>list&lt;StringBuffer&gt;.get(i)</code>中的<code>i</code>是增加还是还是减少。</p><p>最后再把里面的<code>list</code>里面的<code>stringBuffer</code>循环输出进行拼接，最后返回正确的值。</p><p>所以超简单，但是我就是没想到。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p><a href="https://github.com/aimasa/exercise_demo/tree/tablebookexercise/src/exercise/demo/convert" target="_blank" rel="noopener">代码</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。&lt;/p&gt;
&lt;p&gt;比如输入字符串为 “LEETCODEISHIRING” 行数为 3 时，排列如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;L   C   I   R
E T O E S I I G
E   D   H   N
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：”LCIRETOESIIGEDHN”。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/zigzag-conversion&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;力扣（LeetCode）&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://aimasa.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="z字形变换" scheme="http://aimasa.github.io/categories/%E7%AE%97%E6%B3%95/z%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2/"/>
    
    
      <category term="算法" scheme="http://aimasa.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>正则匹配</title>
    <link href="http://aimasa.github.io/2019/07/08/%E6%AD%A3%E5%88%99%E5%8C%B9%E9%85%8D/"/>
    <id>http://aimasa.github.io/2019/07/08/正则匹配/</id>
    <published>2019-07-08T07:38:24.000Z</published>
    <updated>2019-07-09T12:15:38.525Z</updated>
    
    <content type="html"><![CDATA[<p>看代码时候看到正则这块，而且我对它也一直搞不明白，这次干脆写篇博客，让自己对它理解更深一点。</p><a id="more"></a><h1 id="关于对一些正则公式的理解"><a href="#关于对一些正则公式的理解" class="headerlink" title="关于对一些正则公式的理解"></a>关于对一些正则公式的理解</h1><p><code>(?:pattern)</code>:在我参考的博客里面解释的是非获取匹配，也就是只负责匹配，但不会获取匹配结果进行输出，提升了效率</p><p><code>\s</code>：匹配空白字符</p><p><code>\t</code>：制表符</p><p><code>\r</code>：回车符</p><p><code>\n</code>：换行符</p><p><code>[]</code>:括号里面代表或</p><p><code>*</code>:跟在字符后面代表可以有0个或多个这个字符</p><p><code>?</code>：表达前面的表达式可以出线0次或1次</p><p><code>(?&lt;=exp)</code>：匹配最左边的exp表达式能匹配的值。eg:remember (?&lt;=re) 返回的结果就是member</p><h1 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h1><p><a href="https://tool.oschina.net/uploads/apidocs/jquery/regexp.html" target="_blank" rel="noopener">关于正则的公式的解析</a></p><p><a href="https://blog.csdn.net/jusang486/article/details/42122837" target="_blank" rel="noopener">关于正则公式的匹配</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;看代码时候看到正则这块，而且我对它也一直搞不明白，这次干脆写篇博客，让自己对它理解更深一点。&lt;/p&gt;
    
    </summary>
    
      <category term="java语法" scheme="http://aimasa.github.io/categories/java%E8%AF%AD%E6%B3%95/"/>
    
      <category term="正则匹配" scheme="http://aimasa.github.io/categories/java%E8%AF%AD%E6%B3%95/%E6%AD%A3%E5%88%99%E5%8C%B9%E9%85%8D/"/>
    
    
      <category term="java语法" scheme="http://aimasa.github.io/tags/java%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>HMM隐马尔可夫模型</title>
    <link href="http://aimasa.github.io/2019/07/03/HMM%E9%9A%90%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E6%A8%A1%E5%9E%8B/"/>
    <id>http://aimasa.github.io/2019/07/03/HMM隐马尔可夫模型/</id>
    <published>2019-07-03T12:02:29.000Z</published>
    <updated>2019-07-03T12:07:56.747Z</updated>
    
    <content type="html"><![CDATA[<p>emm学长让我看看命名实体识别，解释牵涉到HMM隐马尔可夫模型和条件随机场，我先看看，顺便记笔记，写博客。</p><a id="more"></a><h1 id="关于熵（Entropy）"><a href="#关于熵（Entropy）" class="headerlink" title="关于熵（Entropy）"></a>关于熵（Entropy）</h1><p>熵在这里被用来表征系统的无序程度，熵越大，系统越无序。</p><p>负熵是物质系统有序化，组织化，复杂化状态的一种度量。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.cnblogs.com/skyme/p/4651331.html" target="_blank" rel="noopener">隐马尔可夫模型解释</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;emm学长让我看看命名实体识别，解释牵涉到HMM隐马尔可夫模型和条件随机场，我先看看，顺便记笔记，写博客。&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://aimasa.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="隐马尔可夫模型" scheme="http://aimasa.github.io/categories/%E7%AE%97%E6%B3%95/%E9%9A%90%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E6%A8%A1%E5%9E%8B/"/>
    
    
      <category term="算法" scheme="http://aimasa.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Mockito使用</title>
    <link href="http://aimasa.github.io/2019/06/24/Mockito%E4%BD%BF%E7%94%A8/"/>
    <id>http://aimasa.github.io/2019/06/24/Mockito使用/</id>
    <published>2019-06-24T11:59:21.000Z</published>
    <updated>2019-06-27T02:28:20.984Z</updated>
    
    <content type="html"><![CDATA[<p>关于Mockito的使用，跟着文档边看边试着那些用法。</p><ul><li>来一段从官网搞出来的话</li></ul><blockquote><p>Mockito is a mocking framework that tastes really good. It lets you write beautiful tests with a clean &amp; simple API. Mockito doesn’t give you hangover because the tests are very readable and they produce clean verification errors. </p></blockquote><ul><li>翻译</li></ul><blockquote><p>Mockito是一个体感非常好的mocking框架，它能够让你用简洁干净的API写出漂亮的测试方法……</p></blockquote><p>好了后面的不翻译了，我看了一下，简而言之就是这个测试框架非常好用，特别好用，快来用吧</p><a id="more"></a><h1 id="Mockito使用"><a href="#Mockito使用" class="headerlink" title="Mockito使用"></a>Mockito使用</h1><h2 id="创建mock对象"><a href="#创建mock对象" class="headerlink" title="创建mock对象"></a>创建mock对象</h2><p>刚开始我是<code>mock()</code>一个对象：</p><pre><code>UserPersonService mockedUserPerson = Mockito.mock(UserPersonService.class);</code></pre><p>ps:其中<code>UserPersonService</code>是我想调通的service类。</p><p>然后发现可以用<code>@Mock</code>然后<code>private</code>这个类，然后就很方便的创建了一个Mock对象了：</p><pre><code>@Mockprivate UserPersonService userPersonService;</code></pre><h2 id="验证行为"><a href="#验证行为" class="headerlink" title="验证行为"></a>验证行为</h2><p>这里就是验证方法是否真的被调用，或者调用了多少次。</p><pre><code>List mockedList = mock(List.class);//using mock object 使用mock对象mockedList.add(&quot;one&quot;);mockedList.clear();//verification 验证verify(mockedList).add(&quot;one&quot;);verify(mockedList).clear();</code></pre><p>里面是验证</p><h2 id="做测试桩"><a href="#做测试桩" class="headerlink" title="做测试桩"></a>做测试桩</h2><p>打桩就是对调用的方法给它模拟返回值。然后再后面对这个方法进行调用，输入与之前设定的一样的输入值时候，如果那个方法响应了就会把自己之前模拟的返回值返回出来。这时候我们就能用输出到控制台语句去观摩一下是不是自己预期设定的结果。</p><pre><code>LinkedList mockedList = mock(LinkedList.class); //stubbing // 测试桩 when(mockedList.get(0)).thenReturn(&quot;first&quot;); when(mockedList.get(1)).thenThrow(new RuntimeException());</code></pre><p>这是官网给出来的使用方法，里面当<code>mockedList.get(0)</code>时候返回的是自己设定好的<code>first</code>这个值，然后<code>mockedList.get(1)</code>时候返回的就是自己设定好的抛异常<code>new RuntimeException()</code></p><p>当然，如果自己没有对某个输入参数进行打桩的话，输出就会默认<code>null</code>。</p><p>这个方法也就是看能不能调通这个方法，看是否会响应，会的话就会输出期望值，还能查看这个方法被调用了多少次。</p><h1 id="使用心得"><a href="#使用心得" class="headerlink" title="使用心得"></a>使用心得</h1><p>我试着用<code>@Mock</code>去注解一个类，然后打桩，但是发现打完桩，还是不能返回我打桩时候设定的返回值。</p><p>然后问大佬们，他们给我说用<code>@MockBean</code>，之后就成功了，所以在看<code>@Mock</code>和<code>@MockBean</code>两个注解的区别</p><h2 id="Mock"><a href="#Mock" class="headerlink" title="@Mock"></a>@Mock</h2><p>它们允许模拟类或接口，并记录和验证其上的行为。</p><p>将字段标记为模拟。</p><p>允许速记模拟创建。<br>最小化重复的模拟创建代码。<br>使测试类更具可读性。<br>使验证错误更容易阅读，因为字段名称用于标识模拟。</p><h2 id="MockBean"><a href="#MockBean" class="headerlink" title="@MockBean"></a>@MockBean</h2><p>就是对不需要验证的类加上这个注解，然后它会自动将这个类代入测试的<code>controller</code>中的被<code>@Autowired</code>注解的类。然后返回自己打桩时候设置的值</p><p>Not only will @MockBean provide you with a mock, it will also add that mock as a bean (as the name suggests) within the ApplicationContext, and override any existing beans either by name or by type</p><p>————————<a href="https://gooroo.io/GoorooTHINK/Article/16943/Spring-Boot-14--MockBean-and-SpyBean/24301#.XRQk2egzaM8" target="_blank" rel="noopener">摘自博文</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于Mockito的使用，跟着文档边看边试着那些用法。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;来一段从官网搞出来的话&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;Mockito is a mocking framework that tastes really good. It lets you write beautiful tests with a clean &amp;amp; simple API. Mockito doesn’t give you hangover because the tests are very readable and they produce clean verification errors. &lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;翻译&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;Mockito是一个体感非常好的mocking框架，它能够让你用简洁干净的API写出漂亮的测试方法……&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;好了后面的不翻译了，我看了一下，简而言之就是这个测试框架非常好用，特别好用，快来用吧&lt;/p&gt;
    
    </summary>
    
      <category term="spring相关" scheme="http://aimasa.github.io/categories/spring%E7%9B%B8%E5%85%B3/"/>
    
      <category term="Mockito使用" scheme="http://aimasa.github.io/categories/spring%E7%9B%B8%E5%85%B3/Mockito%E4%BD%BF%E7%94%A8/"/>
    
    
      <category term="spring相关" scheme="http://aimasa.github.io/tags/spring%E7%9B%B8%E5%85%B3/"/>
    
  </entry>
  
  <entry>
    <title>机器学习之线性回归</title>
    <link href="http://aimasa.github.io/2019/06/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/"/>
    <id>http://aimasa.github.io/2019/06/21/机器学习之线性回归/</id>
    <published>2019-06-21T01:34:22.000Z</published>
    <updated>2019-06-24T12:24:33.158Z</updated>
    
    <content type="html"><![CDATA[<p>在机器学习中，我听了吴恩达老师的几节课，一节是来介绍机器学习里面的监督学习，监督学习里面以回归分析和分类为代表，然后吴恩达老师介绍了回归算法，在此做笔记。</p><a id="more"></a><p>会用到的表达符号：</p><ul><li>m：培训的样本的数量（prince in 1000’s有47列:m=47）</li></ul><ul><li>x：输入变量，也称为‘特征’(Size in feet^2)</li></ul><ul><li>y：输出变量，也叫‘目标变量’（prince in 1000’s）</li></ul><ul><li>‘#’ ：训练样本的“个数”缩写</li></ul><ul><li>$\theta_{i}\,=\,$：模型参数</li></ul><h1 id="回归算法"><a href="#回归算法" class="headerlink" title="回归算法"></a>回归算法</h1><p>计算函数最小值：求导 = 0（因为求某数导是求的在当前这个数时候的切线斜率，只有在数值达到峰值时候，切线斜率才会为0）</p><p>回归算法分线性回归和非线性回归，这里先讨论线性回归。</p><h2 id="线性回归"><a href="#线性回归" class="headerlink" title="线性回归"></a>线性回归</h2><p>就是一条直线，有两个未知数（x和y）</p><p>公式：$h_{\theta }(x)=\theta _{0}x+\theta_{1}$</p><h2 id="拟合"><a href="#拟合" class="headerlink" title="拟合"></a>拟合</h2><p>拟合就是把平面上的点,用一条光滑的曲线连接起来,因为这条曲线有无数种可能,就有了各种拟合方法.</p><p>拟合误差（即总残差）</p><h2 id="绝对值的导数不存在的推导"><a href="#绝对值的导数不存在的推导" class="headerlink" title="绝对值的导数不存在的推导"></a>绝对值的导数不存在的推导</h2><p>函数可导必要条件是：在此点连续(也就是左连续必须和右连续相同)</p><p>这里是别人对绝对值的导数可能不存在而写出的证明：</p><center><img src="http://pictures.aimasa.club/static/images/机器学习之线性回归/proof.png"></center><h2 id="最小二乘法"><a href="#最小二乘法" class="headerlink" title="最小二乘法"></a>最小二乘法</h2><p><code>最小二乘法</code>是一种数学优化技术，就是可以求到一些未知的数据，并且使这些求得的数据和实际数据间的误差的平方和为最小</p><h2 id="损失函数（loss-function）"><a href="#损失函数（loss-function）" class="headerlink" title="损失函数（loss function）"></a>损失函数（loss function）</h2><p>就是真实值和理论值的偏差。</p><p>因为实际应用中会受到诸多因素的制约</p><h2 id="效用函数"><a href="#效用函数" class="headerlink" title="效用函数"></a>效用函数</h2><p>百度里说：效用函数通常是用来表示消费者在消费中所获得的效用与所消费的商品组合之间数量关系的函数，以衡量消费者从消费既定的商品组合中所获得满足的程度。</p><h2 id="残差平方和"><a href="#残差平方和" class="headerlink" title="残差平方和"></a>残差平方和</h2><p>百度里解释的是：把数据点和它和回归直线上的预估点的差异数据称为残差，然后，所有的残差的平方和被称为残差平方和。它表示随机误差的效应，一组数据的残差平方和越小，它的拟合度也就越好。    </p><h2 id="拟合-1"><a href="#拟合-1" class="headerlink" title="拟合"></a>拟合</h2><p>就是自己通过方程拟出来的曲线和已知的数据相吻合，这个过程叫做拟合</p><h2 id="代价函数"><a href="#代价函数" class="headerlink" title="代价函数"></a>代价函数</h2><p>在单变量线性回归函数（例）：$h_{\theta }(x)=\theta _{0}x+\theta_{1}$中的$\theta_{1}$和$\theta_{0}$(就是模型参数)这两个未知数可以有很多种组合，从而得出不同的线性函数，拟合出不同的曲线。</p><p>但是为了能够让拟合出来的曲线和已知数据尽最大程度吻合，挑选$\theta_{1}$和$\theta_{0}$很重要。</p><p>所以就有了求平均误差的公式：$J(\theta _{0} \,,\, \theta _{1} \, )=\frac{1}{2m}\sum_{i=1}^{m}(h_{\theta }(x^{(i)})-y^{(i)}))^{2}$</p><p>这个公式是用来衡量设置出来的$\theta_{1}$和$\theta_{0}$的值拟合的曲线和真实的数据的吻合度，所以这个公式得出来的结果越小越好。</p><blockquote><p>其中的$\frac{1}{2}$这是在尝试减小平均误差</p></blockquote><p>于是其中：minimize $J(\theta _{0} \,,\, \theta _{1} \, )$，就是这个线性函数的代价函数</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://baike.baidu.com/item/拟合" target="_blank" rel="noopener">拟合解释</a></p><p><a href="https://math.stackexchange.com/questions/991475/why-is-the-absolute-value-function-not-differentiable-at-x-0/991559" target="_blank" rel="noopener">绝对值的导数不存在的原因</a></p><p>[参考视频为吴恩达老师的机器学习的入门视频]</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在机器学习中，我听了吴恩达老师的几节课，一节是来介绍机器学习里面的监督学习，监督学习里面以回归分析和分类为代表，然后吴恩达老师介绍了回归算法，在此做笔记。&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://aimasa.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="机器学习" scheme="http://aimasa.github.io/categories/%E7%AE%97%E6%B3%95/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="线性回归算法" scheme="http://aimasa.github.io/categories/%E7%AE%97%E6%B3%95/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://aimasa.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="机器学习" scheme="http://aimasa.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>最长回文串</title>
    <link href="http://aimasa.github.io/2019/06/18/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E4%B8%B2/"/>
    <id>http://aimasa.github.io/2019/06/18/最长回文串/</id>
    <published>2019-06-18T12:08:52.000Z</published>
    <updated>2019-07-18T02:01:03.092Z</updated>
    
    <content type="html"><![CDATA[<p>终于弄懂了最长回文串，在做题的时候，总是在暴力破解的思路里出不去，总想着两个for循环，空间复杂度为o($n^{2}$)然后解题思路里面讲了Manacher’s algorithm这个算法，把复杂度降低到了o(n)。</p><a id="more"></a><p>首先看张图（我为了图方便，都先预处理了字符串，不是按官方给的判断回文子串的奇偶方法）</p><center><img src="http://pictures.aimasa.club/static/images/最长回文串/time.png"></center><p>上面那行是我用暴力破解用的时间，下面那行是用Manacher’s algorithm这个算法花的时间，可以很明显的看到emm差距。</p><p>（想说一点[题外话]：记得老师说以空间换时间和以时间换空间的这句话，所以我们需要在时间和空间中找到一个平衡点以达到我们想要的效率）</p><h1 id="暴力破解"><a href="#暴力破解" class="headerlink" title="暴力破解"></a>暴力破解</h1><p>这个算法很简单，就是简单粗暴的双循环，接着判断是不是回文串，再判断是不是最长的回文串。</p><p>我用的是先预处理字符串，在字符串中间加入”#”号，字符串首尾也加上这个</p><p>eg：abcd  =====&gt; #a#b#c#d#</p><p>这样就能保证字符串长度一定为奇数了（如果字符串原长3，那么就需要插入4个”#”，那么奇数加偶数一定是奇数了）</p><p>然后根据循环到的位置，扩散开来判断是否是回文串，是的话同时记录长度和下标，就能够寻找到最长的回文串了。</p><h1 id="Manacher’s-algorithm"><a href="#Manacher’s-algorithm" class="headerlink" title="Manacher’s algorithm"></a>Manacher’s algorithm</h1><h2 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h2><p>首先预处理字符串，让字符串保证长度为奇数<br>eg：aba  =====&gt; #a#b#a#</p><h2 id="主要思路"><a href="#主要思路" class="headerlink" title="主要思路"></a>主要思路</h2><p>先假设<strong>当前最长回文串</strong></p><center><img src="http://pictures.aimasa.club/static/images/最长回文串/table.png"></center><p>里面的p[i]是指当前回文串的半径（其实p[i] - 1就是当前回文串的真实长度）</p><p>所以，p[j]是最后得出最长回文串的关键。</p><p>所以我们需要求出p[j]（ci的位置就是为p[i]服务的）</p><p>先假设ci是<strong>当前</strong>最长回文串的中心点，那么由它开始往外扩展，判断这个最长回文串里面是否有新的回文串，如果有的话，首先判断新的回文串是不是被这个最大回文串包含了。</p><p>从j=0开始往后遍历，同时开始判断当前最长的回文串，然后ci的位置根据最长回文串的最右边界的位置而开始发生改变。</p><p>接着就要开始讨论关于j的位置处于最长回文串的笼罩范围内的情况了：</p><center><img src="http://pictures.aimasa.club/static/images/最长回文串/lenth.png"></center><p>这里列举的是j存在的回文串<strong>处于最长回文串笼罩的范围内的情况</strong>。</p><p>在这里我们没有必要去一个个比较去判断在最长回文串内的i的情况，我们可以直接对j对应ci的另一边的j的映射（我们称为i，i = 2* ci - j）i的p[i]的长度，如果p[i]的回文串长度如上图所示的话，那么p[j]=p[i],然后跳出循环，去遍历下一个j</p><p>除了刚刚那种情况，那就还有剩下的一种情况了：j存在的回文串<strong>长于最长回文串笼罩的范围内的情况</strong></p><center><img src="http://pictures.aimasa.club/static/images/最长回文串/overLenth.png"></center><p>其中j的回文子串的右边比ci所对应的回文串的最右边长（如图），那么我们就需要判断一下j对应的i的回文字符串有多长，所以首先我们要知道l的长度，因为对应的i的那个部分是回文字符串，所以在没有超出ci的最长回文串的最右边界的部分，j的那段一定是回文字符串，所以我们就需要在基于l长度的回文字符串的基础下，继续往后比较。</p><center><img src="http://pictures.aimasa.club/static/images/最长回文串/final.png"></center><p>如果j的回文串的最右边界超出了ci原本对应的最长回文串的边界</p><center><img src="http://pictures.aimasa.club/static/images/最长回文串/realFinal.png"></center><p>那么就令ci的值变成j的值。</p><p>当然，在对ci做改变时候，要记住随时记录p[j]的值，并且随时记录p[j]里面的最大值。</p><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>所以最后就根据p[j]的最大值找到对应的字符子串，这个子串就是最大回文串</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/solution/zhong-xin-kuo-san-dong-tai-gui-hua-by-liweiwei1419/" target="_blank" rel="noopener">参考官方资料</a></p><p><a href="https://github.com/aimasa/exercise_demo/tree/master/src/exercise/demo/longestpalindrome" target="_blank" rel="noopener">本文代码</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;终于弄懂了最长回文串，在做题的时候，总是在暴力破解的思路里出不去，总想着两个for循环，空间复杂度为o($n^{2}$)然后解题思路里面讲了Manacher’s algorithm这个算法，把复杂度降低到了o(n)。&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://aimasa.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="最长回文串" scheme="http://aimasa.github.io/categories/%E7%AE%97%E6%B3%95/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E4%B8%B2/"/>
    
    
      <category term="算法" scheme="http://aimasa.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>寻找两个有序数组的中位数</title>
    <link href="http://aimasa.github.io/2019/06/10/%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/"/>
    <id>http://aimasa.github.io/2019/06/10/寻找两个有序数组的中位数/</id>
    <published>2019-06-10T13:58:46.000Z</published>
    <updated>2019-07-15T01:34:12.363Z</updated>
    
    <content type="html"><![CDATA[<p>给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。</p><p>请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。</p><p>你可以假设 nums1 和 nums2 不会同时为空。</p><pre><code>nums1 = [1, 3]nums2 = [2]</code></pre><p>中位数是：2.0</p><a id="more"></a><p>我自己的解法是用的归并排序，先把两个有序数组排好序放到另一个数组中，再用位运算找到中位，求解，然后结果是运行速度极慢。</p><p>就去看了官方的结题思路</p><p>因为官方有直接的答案，我就在这写写我的理解(ps：其中一些公式什么的是直接从官网复制黏贴来的，图片也是直接截的，手打太费事了)【简要概述】：</p><h1 id="结题思路"><a href="#结题思路" class="headerlink" title="结题思路"></a>结题思路</h1><p>把nums1和nums2都分成两个部分，然后nums1左边的部分和nums2左边的部分，nums1右边的部分nums2右边的部分放在一块，最后左边的部分总数要和右边部分的总数一样多,如下图：</p><center><img src="http://pictures.aimasa.club/static/images/寻找两个有序数组的中位数/part.png"></center><p>根据这张图里面的左边和右边的部分，我们假设已知$\,i\,$和$\,m\,$还有$\,n\,$的值，然后用公式把$\,j\,$表示出来,其中：</p><ul><li>$len(left_part)=len(right_part)$</li><li>$\max(\text{left_part}) \leq \min(\text{right_part})max(left_part)≤min(right_part)$</li></ul><p>为了保证数据不溢出，所以要保证nums1的长度要小于nums2，这样先对nums1选中i的指向位置后，根据公式算出j的时候就不会发生j指向的nums2数据溢出了。</p><p>这个题目的本质就是，把这两个数组统一分成两部分，前面那个部分都要比后面的部分小，所以，我们必须确保：</p><p>B[j−1]≤A[i] 以及 $\text{A}[i-1] \leq \text{B}[j],A[i−1]≤B[j]$</p><p>然后i和j的算法公式：</p><p>$ i=0∼m, j=\frac{m+n+1}{2}−i$</p><p>所以，得出i和j之后，我们就可以根据nums1[]和nums2[]这两个有序数组的大小去寻找中位数了。</p><p>其中m+n+1是为了保证中位数落在分割线的左边，如果中位数在中位线的右边的话，很容易因为数据溢出而报错。</p><p>因为很多时候，i会等于nums1[].lenth()，或者j会等于nums2[].lenth()，所以我们在循环保证i的指向是我们想要的地方之后（或者刚好溢出后），进入判断环节。</p><p>如果i等于nums1[].lenth()，那么则意味着j的指向的数字是我们所需要的中位数之一（之所以说是之一，是因为这两个数组长度加在一起是奇数，不然i是不会等于nums1[].lenth()），j也是这样。</p><p>如果i等于0的时候，那么意味着j现在指向的就是中位数，而不需要继续去寻找中位数了。j等于0的时候也是如此。（i或者j指向0，这种情况在两个数组长度为奇数或者偶数的情况下都会出现）</p><p>讲的有点零散，所以我决定直接把代码连接放出来！<br><a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/xun-zhao-liang-ge-you-xu-shu-zu-de-zhong-wei-shu-b/" target="_blank" rel="noopener">见官网</a></p><p><a href="https://github.com/aimasa/exercise_demo/tree/master/src/exercise/demo/findmediansortedarrays" target="_blank" rel="noopener">和我github上面的代码实现</a></p><h1 id="题目来源"><a href="#题目来源" class="headerlink" title="题目来源"></a>题目来源</h1><p><a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays" target="_blank" rel="noopener">力扣（LeetCode）</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。&lt;/p&gt;
&lt;p&gt;请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。&lt;/p&gt;
&lt;p&gt;你可以假设 nums1 和 nums2 不会同时为空。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;nums1 = [1, 3]
nums2 = [2]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;中位数是：2.0&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://aimasa.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="寻找两个有序数组的中位数" scheme="http://aimasa.github.io/categories/%E7%AE%97%E6%B3%95/%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/"/>
    
    
      <category term="算法" scheme="http://aimasa.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>SpringCloud学习</title>
    <link href="http://aimasa.github.io/2019/06/05/SpringCloud%E5%AD%A6%E4%B9%A0/"/>
    <id>http://aimasa.github.io/2019/06/05/SpringCloud学习/</id>
    <published>2019-06-05T06:28:23.000Z</published>
    <updated>2019-06-05T08:33:47.760Z</updated>
    
    <content type="html"><![CDATA[<p>之前我写的代码都是单架构模式，就是把多个功能放在同一个应用里面，就像之前写的小程序后台一样</p><p>修改了部分代码，就得整体再重新打包编译，没有修改的部分，甚至不需要使用到这部分代码的功能也因为重新打包编译而全部不能使用……</p><p>所以要通过分布式和集群的方式把单架构模式改造一下</p><a id="more"></a><h1 id="微服务概念"><a href="#微服务概念" class="headerlink" title="微服务概念"></a>微服务概念</h1><p>一个springboot就是一个微服务，而且这个springboot做的事情很单一。在我的理解里面，就是把之前的一个整体的分层架构的springboot分成controller、service、dao这三个部分，</p><h1 id="微服务注册"><a href="#微服务注册" class="headerlink" title="微服务注册"></a>微服务注册</h1><p>虽然把springboot分了三部分，但这三部分应该怎么建立连接，相互之间应该怎么进行联络，所以就要引入一个微服务注册中心的概念了。这个微服务注册中心在 springcloud 里就叫做 eureka server, 通过它把就可以把微服务注册起来，以供将来调用。</p><h1 id="微服务访问"><a href="#微服务访问" class="headerlink" title="微服务访问"></a>微服务访问</h1><p>一个服务通过微服务注册中心定位并访问另外一个微服务。</p><h1 id="分布式概念"><a href="#分布式概念" class="headerlink" title="分布式概念"></a>分布式概念</h1><p>博客里介绍：本来一个spring boot就能完成的任务现在分布在多个spring boot里面做。<br>就是不同的部分的微服务可以由不同的团队去开发，耦合度低。</p><h1 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h1><p>就是同样的功能，但是用的端口不一样，如果8080挂了，我可以用8081这个端口的这个功能的微服务，这叫高可用==。</p><h1 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h1><p><a href="http://how2j.cn/k/springcloud/springcloud-distribution/2037.html" target="_blank" rel="noopener">Spring Cloud入门（对这篇博客做的笔记）</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前我写的代码都是单架构模式，就是把多个功能放在同一个应用里面，就像之前写的小程序后台一样&lt;/p&gt;
&lt;p&gt;修改了部分代码，就得整体再重新打包编译，没有修改的部分，甚至不需要使用到这部分代码的功能也因为重新打包编译而全部不能使用……&lt;/p&gt;
&lt;p&gt;所以要通过分布式和集群的方式把单架构模式改造一下&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Cloud学习（一）" scheme="http://aimasa.github.io/categories/Spring-Cloud%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    
      <category term="微服务的概念" scheme="http://aimasa.github.io/categories/Spring-Cloud%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%A6%82%E5%BF%B5/"/>
    
    
      <category term="Spring Cloud" scheme="http://aimasa.github.io/tags/Spring-Cloud/"/>
    
  </entry>
  
  <entry>
    <title>springBootTest注入失败</title>
    <link href="http://aimasa.github.io/2019/06/05/springBootTest%E6%B3%A8%E5%85%A5%E5%A4%B1%E8%B4%A5/"/>
    <id>http://aimasa.github.io/2019/06/05/springBootTest注入失败/</id>
    <published>2019-06-05T01:26:51.000Z</published>
    <updated>2019-06-05T01:41:11.417Z</updated>
    
    <content type="html"><![CDATA[<p>在用测试测dao层时候，虽然都有用注解:dao层用注解@Repository标记，Test类里面注入用@Autowired标记。</p><p>但是还是显示注入失败。</p><a id="more"></a><p>查了半天方法，最后去了spring boot的运行类里面加上了指定包扫描@ComponentScan(basePackages = {“扫描的包的共有的包名部分”})</p><p>然后刚刚发现，之所以扫不出来是因为我包名的命名错误</p><img src="http://pictures.aimasa.club/static/images/springBootTest注入失败/package.png">]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在用测试测dao层时候，虽然都有用注解:dao层用注解@Repository标记，Test类里面注入用@Autowired标记。&lt;/p&gt;
&lt;p&gt;但是还是显示注入失败。&lt;/p&gt;
    
    </summary>
    
      <category term="spring相关" scheme="http://aimasa.github.io/categories/spring%E7%9B%B8%E5%85%B3/"/>
    
      <category term="Test" scheme="http://aimasa.github.io/categories/spring%E7%9B%B8%E5%85%B3/Test/"/>
    
      <category term="SpringBootTest注入失败" scheme="http://aimasa.github.io/categories/spring%E7%9B%B8%E5%85%B3/Test/SpringBootTest%E6%B3%A8%E5%85%A5%E5%A4%B1%E8%B4%A5/"/>
    
    
      <category term="运行error" scheme="http://aimasa.github.io/tags/%E8%BF%90%E8%A1%8Cerror/"/>
    
  </entry>
  
  <entry>
    <title>态势感知</title>
    <link href="http://aimasa.github.io/2019/05/31/%E6%80%81%E5%8A%BF%E6%84%9F%E7%9F%A5/"/>
    <id>http://aimasa.github.io/2019/05/31/态势感知/</id>
    <published>2019-05-31T09:31:11.000Z</published>
    <updated>2019-07-18T01:55:51.514Z</updated>
    
    <content type="html"><![CDATA[<p>在找研究方向时候，有人推荐我看看态势感知，所以记个笔记</p><p>我对态势感知的理解就是：对网络里来往的流量进行分析，排除噪声，通过各种手段通过分析得出安全情况，然后进行防护。</p><p>网络安全态势感知NSSA（network security situation awareness）<br><a id="more"></a></p><h1 id="态势感知"><a href="#态势感知" class="headerlink" title="态势感知"></a>态势感知</h1><p> 态势是各种状态的综合，是一个整体和全局的概念。它强调的是系统和系统对象之间的关系,下图是态势感知的系统要素内容（我jio的就是单纯的流程，就是从收集到的原始数据，然后进行处理得到的数据，再从这些数据里面用技术去分析，得到相关不同的进行了的活动，再去针对不同的活动进行不同的分析，最后的状态评估，进行预测，不同的活动会对系统中的各个对象产生的作用）</p><center><img src="http://pictures.aimasa.club/static/images/态势感知/struct.png"></center>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在找研究方向时候，有人推荐我看看态势感知，所以记个笔记&lt;/p&gt;
&lt;p&gt;我对态势感知的理解就是：对网络里来往的流量进行分析，排除噪声，通过各种手段通过分析得出安全情况，然后进行防护。&lt;/p&gt;
&lt;p&gt;网络安全态势感知NSSA（network security situation awareness）&lt;br&gt;
    
    </summary>
    
      <category term="态势感知相关" scheme="http://aimasa.github.io/categories/%E6%80%81%E5%8A%BF%E6%84%9F%E7%9F%A5%E7%9B%B8%E5%85%B3/"/>
    
      <category term="态势感知" scheme="http://aimasa.github.io/categories/%E6%80%81%E5%8A%BF%E6%84%9F%E7%9F%A5%E7%9B%B8%E5%85%B3/%E6%80%81%E5%8A%BF%E6%84%9F%E7%9F%A5/"/>
    
    
      <category term="态势感知" scheme="http://aimasa.github.io/tags/%E6%80%81%E5%8A%BF%E6%84%9F%E7%9F%A5/"/>
    
  </entry>
  
  <entry>
    <title>文件上传到mongdb的方法</title>
    <link href="http://aimasa.github.io/2019/05/23/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%88%B0mongdb%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>http://aimasa.github.io/2019/05/23/文件上传到mongdb的方法/</id>
    <published>2019-05-23T08:38:02.000Z</published>
    <updated>2019-05-24T06:03:48.951Z</updated>
    
    <content type="html"><![CDATA[<p>思路：先构造一个请求体，然后获取文件类型，进行比对，如果不是excel类型拒绝，是则存入请求体.</p><p>把文件内容转成输入流，再从输入流中读取转成二进制byteArray类型</p><p>对这个二进制数组做哈希</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;思路：先构造一个请求体，然后获取文件类型，进行比对，如果不是excel类型拒绝，是则存入请求体.&lt;/p&gt;
&lt;p&gt;把文件内容转成输入流，再从输入流中读取转成二进制byteArray类型&lt;/p&gt;
&lt;p&gt;对这个二进制数组做哈希&lt;/p&gt;

      
    
    </summary>
    
      <category term="spring相关" scheme="http://aimasa.github.io/categories/spring%E7%9B%B8%E5%85%B3/"/>
    
      <category term="mongodb存储" scheme="http://aimasa.github.io/categories/spring%E7%9B%B8%E5%85%B3/mongodb%E5%AD%98%E5%82%A8/"/>
    
    
      <category term="mongodb" scheme="http://aimasa.github.io/tags/mongodb/"/>
    
  </entry>
  
  <entry>
    <title>一种基于结构划分概率的口令攻击方法</title>
    <link href="http://aimasa.github.io/2019/05/10/%E4%B8%80%E7%A7%8D%E5%9F%BA%E4%BA%8E%E7%BB%93%E6%9E%84%E5%88%92%E5%88%86%E6%A6%82%E7%8E%87%E7%9A%84%E5%8F%A3%E4%BB%A4%E6%94%BB%E5%87%BB%E6%96%B9%E6%B3%95/"/>
    <id>http://aimasa.github.io/2019/05/10/一种基于结构划分概率的口令攻击方法/</id>
    <published>2019-05-10T12:26:08.000Z</published>
    <updated>2019-06-12T09:16:48.178Z</updated>
    
    <content type="html"><![CDATA[<p>这是一种基于结构划分概率的口令攻击方法研究，里面牵涉到了上下文无关文法</p><p>它分析了现在存储用户口令的方法，然后优化了对口令的攻击方法，节约了很多时间</p><a id="more"></a><h1 id="论文大体介绍"><a href="#论文大体介绍" class="headerlink" title="论文大体介绍"></a>论文大体介绍</h1><p>现在的系统大部分是保存口令的Hash值，用户登录时候，会通过<strong>单向函数</strong>（单向函数给定输入值进行输出很简单，但是很难从输出值去推算回输入值）对输入的口令进行运算，再把得到的Hash值去和存储的哈希值进行对比，如果相等，那么就登录成功了。</p><p>也有一些系统是采用加盐值（就是给你的密码加一串随机数，然后再进行哈希运算，得出一串哈希值，这样对于去破解密码的人来说，运算量很大，很难被破解）的方法去进一步保证系统的安全性。</p><p>因为攻击难度提高了，所以攻击者换了个角度，开始从人对口令的记忆方面去思考攻击方法，提高攻击效率。</p><p>这篇论文是重在考虑基于口令划分概率的口令攻击方法。它和另一个方法相比提高了百分之二十到百分之三十的命中率</p><p>这个方法也具有学习功能，能够根据攻击结果更新使用的字典，提高攻击效率。</p><h1 id="近来口令分析简介"><a href="#近来口令分析简介" class="headerlink" title="近来口令分析简介"></a>近来口令分析简介</h1><ul><li><p>结合词典，根据刚开始定义的变形规则去改变刚开始的单词，生成口令。</p><ul><li>但是变形规则简单，数量有限，要人工自己编写</li><li>口令搜索空间有限，它依赖于已经有的字典和变形规则，变形规则简单，虽然可以根据攻击者自己想变形规则去形成复杂口令，但效率不高。</li></ul></li><li><p>基于马尔科夫链的时间存储折中攻击</p><ul><li>（没看）</li></ul></li><li><p>基于概率上下文无关文法口令攻击方法</p><ul><li>用概率上下文无关文法去定义口令结构，就分块定义，然后对每个块的密码内容进行概率排序，然后产生半终端结构（就是比如我分块是A、B、C、D三个块，A概率最大的值是1，那么按A概率排的半终端结构就是1BCD）</li><li>各个块进行概率排序，然后各个按概率大小组合在一起，形成的结构再按概率插入队列</li><li>有了更多的变形规则，搜索空间更大了</li><li>据统计，高概率的具体结构长度大部分都小于等于3（就分的块小于等于分出了三个块）</li><li>命中率低（但相对于前面的，已经提高了命中率）</li></ul></li></ul><h1 id="口令结构分析"><a href="#口令结构分析" class="headerlink" title="口令结构分析"></a>口令结构分析</h1><p>详细数据表明，大部分人都会把口令只划分为一个部分（也就是比较单一）当然还有少部分会使用其他结构</p><p>对口令按具体结构进行初次划分时候，不会把口令结构划分的很小。</p><p>根据数据分析，虽然结构长的口令比较难被攻击者猜测出来，但是很少有用户会选择结构长的口令。</p><h1 id="基于结构划分概率的方法"><a href="#基于结构划分概率的方法" class="headerlink" title="基于结构划分概率的方法"></a>基于结构划分概率的方法</h1><p>所以该文决定对高概率的口令组合结构根据用户习惯进行再次划分</p><p>主要步骤：</p><ul><li>预处理</li><li>口令攻击阶段</li></ul><h2 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h2><ul><li>具体结构：就是根据用户设置的口令而划分的结构（没有被处理过的那种）</li><li>抽取子结构：就是从具体结构中划分出来的小结构再分类别归类，从而形成了抽取子结构。eg:A（字母）、D（数字），具体结构是：ADAD =&gt; {AA，DD}（分类别归类），其中抽取子结构为：$\bar{A}\, =\, AA\,$</li><li>再对具体结构根据它对应的抽取子结构进行归类，再计算该结构的使用概率。</li></ul><p>论文中使用了一种概率统计方法：</p><p>$p\, =\frac{NUM_{ss_{i}}} {NUM_{es_{j}}}$ </p><p>其中分母表示的是具有这个抽取子结构的数目，分子是对应的具有此划分子结构数目（就是对具体子结构分类别归类后，不同结构组成同一抽取子结构的结构）</p><p>$\,ss_{i}\,$表示第i个划分子结构,$\,es_{j}\,$表示二对应的第j个抽取子结构.</p><p>由论文总结的数据可以得知：用户口令单一结构的组成占大多数。</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1] 邹静,林东岱,郝春辉.一种基于结构划分概率的口令攻击方法[J].计算机学报,2014,37(05):1206-1215.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是一种基于结构划分概率的口令攻击方法研究，里面牵涉到了上下文无关文法&lt;/p&gt;
&lt;p&gt;它分析了现在存储用户口令的方法，然后优化了对口令的攻击方法，节约了很多时间&lt;/p&gt;
    
    </summary>
    
      <category term="数学导论" scheme="http://aimasa.github.io/categories/%E6%95%B0%E5%AD%A6%E5%AF%BC%E8%AE%BA/"/>
    
      <category term="上下文无关文法" scheme="http://aimasa.github.io/categories/%E6%95%B0%E5%AD%A6%E5%AF%BC%E8%AE%BA/%E4%B8%8A%E4%B8%8B%E6%96%87%E6%97%A0%E5%85%B3%E6%96%87%E6%B3%95/"/>
    
      <category term="论文赏析（只有赏）" scheme="http://aimasa.github.io/categories/%E6%95%B0%E5%AD%A6%E5%AF%BC%E8%AE%BA/%E4%B8%8A%E4%B8%8B%E6%96%87%E6%97%A0%E5%85%B3%E6%96%87%E6%B3%95/%E8%AE%BA%E6%96%87%E8%B5%8F%E6%9E%90%EF%BC%88%E5%8F%AA%E6%9C%89%E8%B5%8F%EF%BC%89/"/>
    
    
      <category term="数学导论" scheme="http://aimasa.github.io/tags/%E6%95%B0%E5%AD%A6%E5%AF%BC%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>学习爬虫（一）：安装selenium和ChromeDriver</title>
    <link href="http://aimasa.github.io/2019/05/10/%E5%AD%A6%E4%B9%A0%E7%88%AC%E8%99%AB%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%AE%89%E8%A3%85selenium%E5%92%8CChromeDriver/"/>
    <id>http://aimasa.github.io/2019/05/10/学习爬虫（一）：安装selenium和ChromeDriver/</id>
    <published>2019-05-10T09:33:44.000Z</published>
    <updated>2019-06-12T09:14:44.057Z</updated>
    
    <content type="html"><![CDATA[<p>关于爬虫的学习，先从selenium这个库开始学。</p><a id="more"></a><h1 id="关于selenium"><a href="#关于selenium" class="headerlink" title="关于selenium"></a>关于selenium</h1><p>先是</p><pre><code>pip install selenium</code></pre><p>安装完这个，我以为就odk了，然后在pycharm编译器里面跟着网上给的代码敲了一段</p><pre><code>from selenium import webdriverbrowser = webdriver.Chrome()browser.get(&#39;https://www.baidu.com&#39;)</code></pre><p>结果报错了</p><pre><code>This inspection detects names that should resolve but don&#39;t. Due to dynamic dispatch and duck typing, this is possible in a limited but useful number of cases. Top-level and class-level items are supported better than instance items.</code></pre><p>大体意思就是模块不存在，然后我以为是pip install时候出错了，就回去再pip install一遍，结果发现，还是没有用。</p><p>然后上网找解决方案，跟着网上的教程去看了pycharm这个IDE里面设置的python环境的路径：</p><ul><li><strong>File &gt; settings &gt; project:xxxxxxx(你导入pycharm的文件夹)  &gt; project Interpreter</strong></li></ul><p>就发现我pip install下载下来的selenium库地址和之前设置在IDE里面python环境的地址不一样，所以没法找到selenium这个模块。</p><p>然后去对这个IDE里面的python路径进行更改。</p><h2 id="更改"><a href="#更改" class="headerlink" title="更改"></a>更改</h2><center><img src="http://pictures.aimasa.club/static/images/学习爬虫（一）：安装selenium和ChromeDriver/pycharm.png"></center><p>点<strong>show all……</strong></p><p>接着</p><center><img src="http://pictures.aimasa.club/static/images/学习爬虫（一）：安装selenium和ChromeDriver/add.png"></center><p>找到对应python-pip的相关python目录所在地，然后更改IDE依赖环境目录。</p><h2 id="查找目录所在地"><a href="#查找目录所在地" class="headerlink" title="查找目录所在地"></a>查找目录所在地</h2><p>我是再次pip install selenium，然后看到了selenium存的位置，再根据这个位置找到相关信息。</p><h1 id="ChromeDriver"><a href="#ChromeDriver" class="headerlink" title="ChromeDriver"></a>ChromeDriver</h1><p>我弄好了，发现不再显示该模块不存在的信息了之后，运行了一遍，发现还是报错了。</p><pre><code>Service chromedriver unexpectedly exited</code></pre><p>出现了这个报错信息。</p><h2 id="装插件"><a href="#装插件" class="headerlink" title="装插件"></a>装插件</h2><p>所以我去安装chromedriver驱动<a href="http://npm.taobao.org/mirrors/chromedriver/" target="_blank" rel="noopener">下载地址</a></p><p>下载好了之后，解压，再新建一个文件夹，里面只放解压出来的exe文件，再去控制面板里面配置环境path</p><p>然后再运行，成功调出了Chrome浏览器，并且让它自动进入百度搜索页面。</p><h1 id="browser-get"><a href="#browser-get" class="headerlink" title="browser.get()"></a>browser.get()</h1><p>browser.get()括号里面的字符串必须填写完整的网址，不然会显示无效网址的错误提示。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://blog.csdn.net/qq_41188944/article/details/79039690" target="_blank" rel="noopener">参考资料</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于爬虫的学习，先从selenium这个库开始学。&lt;/p&gt;
    
    </summary>
    
      <category term="爬虫、python" scheme="http://aimasa.github.io/categories/%E7%88%AC%E8%99%AB%E3%80%81python/"/>
    
      <category term="安装selenium和ChromeDriver" scheme="http://aimasa.github.io/categories/%E7%88%AC%E8%99%AB%E3%80%81python/%E5%AE%89%E8%A3%85selenium%E5%92%8CChromeDriver/"/>
    
    
      <category term="爬虫" scheme="http://aimasa.github.io/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>git出错（一）</title>
    <link href="http://aimasa.github.io/2019/05/09/git%E5%87%BA%E9%94%99%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://aimasa.github.io/2019/05/09/git出错（一）/</id>
    <published>2019-05-09T03:25:38.000Z</published>
    <updated>2019-05-09T03:33:09.375Z</updated>
    
    <content type="html"><![CDATA[<p>报错：src refspec master does not match any</p><a id="more"></a><h1 id="操作过程"><a href="#操作过程" class="headerlink" title="操作过程"></a>操作过程</h1><pre><code>git initgit commit -m &quot;first commit&quot;git remote add origin git@github.com:aimasa/xxxxxxxxgit push -u origin master</code></pre><p>然后再回车的时候，git bash就报错了</p><pre><code>src refspec master does not match any</code></pre><h1 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h1><p>我没有提交任何内容，我的本地库（.git）是空的，所以第一次push是提交一个空项目，里面没有任何东西，所以报错了</p><h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p>把代码提交到本地，然后再推送一次</p><pre><code>git add .git commit -m &quot;xxxx&quot;git push -u origin master</code></pre><p>推送成功</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;报错：src refspec master does not match any&lt;/p&gt;
    
    </summary>
    
      <category term="git" scheme="http://aimasa.github.io/categories/git/"/>
    
      <category term="git出错" scheme="http://aimasa.github.io/categories/git/git%E5%87%BA%E9%94%99/"/>
    
      <category term="src refspec master does not match any." scheme="http://aimasa.github.io/categories/git/git%E5%87%BA%E9%94%99/src-refspec-master-does-not-match-any/"/>
    
    
      <category term="git出错" scheme="http://aimasa.github.io/tags/git%E5%87%BA%E9%94%99/"/>
    
  </entry>
  
</feed>

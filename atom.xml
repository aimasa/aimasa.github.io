<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>aimasa的个人博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://aimasa.github.io/"/>
  <updated>2019-04-29T09:08:47.598Z</updated>
  <id>http://aimasa.github.io/</id>
  
  <author>
    <name>ZHY</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>java打包供maven使用</title>
    <link href="http://aimasa.github.io/2019/04/28/java%E6%89%93%E5%8C%85%E4%BE%9Bmaven%E4%BD%BF%E7%94%A8/"/>
    <id>http://aimasa.github.io/2019/04/28/java打包供maven使用/</id>
    <published>2019-04-28T12:36:08.000Z</published>
    <updated>2019-04-29T09:08:47.598Z</updated>
    
    <content type="html"><![CDATA[<p>因为之前老师说好的说让我自己试试怎么对项目打包，然后把包封装成相关依赖，这样可以直接在maven里面添加依赖，然后对包进行调用。</p><a id="more"></a><h1 id="把项目打包"><a href="#把项目打包" class="headerlink" title="把项目打包"></a>把项目打包</h1><p>用的是fatjar对项目进行的打包，又快又方便。</p><p>我用的是eclipse4.4版本，对项目右键会有build FatJar的选项，然后点进去，选择好生成jar包的位置【注意：包存放的文件夹名中间不能有空格，不然包转成依赖语句会报错】，然后jar包就生成了。</p><h1 id="把包转换成依赖"><a href="#把包转换成依赖" class="headerlink" title="把包转换成依赖"></a>把包转换成依赖</h1><p>首先win+R进入cmd命令行，然后cd到该jar包存放的位置，再然后输入以下命令行</p><pre><code>mvn install:install-file -Dfile=jar包的位置 -DgroupId=上面的groupId -DartifactId=上面的artifactId -Dversion=上面的version -Dpackaging=jar</code></pre><p>—————————————————-<a href="https://blog.csdn.net/u012759397/article/details/53437502" target="_blank" rel="noopener">摘自博客</a></p><p>然后回车，一顿操作猛如虎，再新建一个项目，添加：</p><pre><code>&lt;dependency&gt;&lt;groupId&gt;com.qrcode&lt;/groupId&gt;&lt;!--DgroupId等于的参数值--&gt;&lt;artifactId&gt;qr&lt;/artifactId&gt;&lt;!--DartifactId等于的参数值--&gt;&lt;version&gt;0.1&lt;/version&gt;&lt;!--Dversion等于的参数值--&gt;&lt;/dependency&gt;</code></pre><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://blog.csdn.net/u012759397/article/details/53437502" target="_blank" rel="noopener">博客</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;因为之前老师说好的说让我自己试试怎么对项目打包，然后把包封装成相关依赖，这样可以直接在maven里面添加依赖，然后对包进行调用。&lt;/p&gt;
    
    </summary>
    
      <category term="java语法" scheme="http://aimasa.github.io/categories/java%E8%AF%AD%E6%B3%95/"/>
    
      <category term="java打包供maven使用" scheme="http://aimasa.github.io/categories/java%E8%AF%AD%E6%B3%95/java%E6%89%93%E5%8C%85%E4%BE%9Bmaven%E4%BD%BF%E7%94%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>java版本太低</title>
    <link href="http://aimasa.github.io/2019/04/28/java%E7%89%88%E6%9C%AC%E5%A4%AA%E4%BD%8E/"/>
    <id>http://aimasa.github.io/2019/04/28/java版本太低/</id>
    <published>2019-04-28T11:32:56.000Z</published>
    <updated>2019-04-28T12:35:05.900Z</updated>
    
    <content type="html"><![CDATA[<p>导入一个本来是没有语法错误的项目，然后IDE到处报错，说是jdk版本太高，要更改成低版本。</p><a id="more"></a><p>对着被导入的项目点击右键-&gt; properties-&gt;java build path</p><p>然后双击JRE System Library，然后更换jre的版本号（和本地装的jre的版本号一致）</p><center><img src="http://pp48biywe.bkt.clouddn.com/static/images/java版本太低/confi.png"></center><p>然后成功</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;导入一个本来是没有语法错误的项目，然后IDE到处报错，说是jdk版本太高，要更改成低版本。&lt;/p&gt;
    
    </summary>
    
      <category term="运行error" scheme="http://aimasa.github.io/categories/%E8%BF%90%E8%A1%8Cerror/"/>
    
      <category term="java版本太低" scheme="http://aimasa.github.io/categories/%E8%BF%90%E8%A1%8Cerror/java%E7%89%88%E6%9C%AC%E5%A4%AA%E4%BD%8E/"/>
    
    
      <category term="运行error" scheme="http://aimasa.github.io/tags/%E8%BF%90%E8%A1%8Cerror/"/>
    
  </entry>
  
  <entry>
    <title>vim的使用心得</title>
    <link href="http://aimasa.github.io/2019/04/23/vim%E7%9A%84%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97/"/>
    <id>http://aimasa.github.io/2019/04/23/vim的使用心得/</id>
    <published>2019-04-23T08:20:24.000Z</published>
    <updated>2019-04-23T12:16:45.053Z</updated>
    
    <content type="html"><![CDATA[<p>因为最近不是b站后台源码被泄露了嘛，然后它用的是go语言，我又不想在windows系统里面装go语言的IDE，然后就在虚拟机里面配置go语言的环境，过程中在里面我用到了一些对vim的操作，在这里特地记录一下。</p><a id="more"></a><h1 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h1><p>直接按<strong>s</strong>键，然后又可以插入，也可以对其中的内容进行修改。</p><h1 id="保存并且推出"><a href="#保存并且推出" class="headerlink" title="保存并且推出"></a>保存并且推出</h1><ul><li>保存：按住esc键，然后输入<strong>:w</strong></li><li>退出：按住esc键，然后输入<strong>:q</strong></li><li>保存且退出：按住esc键，然后输入<strong>:wq</strong></li></ul><h1 id="目前只用到了这些操作方法，所以暂时如此记录"><a href="#目前只用到了这些操作方法，所以暂时如此记录" class="headerlink" title="目前只用到了这些操作方法，所以暂时如此记录"></a>目前只用到了这些操作方法，所以暂时如此记录</h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;因为最近不是b站后台源码被泄露了嘛，然后它用的是go语言，我又不想在windows系统里面装go语言的IDE，然后就在虚拟机里面配置go语言的环境，过程中在里面我用到了一些对vim的操作，在这里特地记录一下。&lt;/p&gt;
    
    </summary>
    
      <category term="ubuntu的使用" scheme="http://aimasa.github.io/categories/ubuntu%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    
      <category term="vim的使用心得" scheme="http://aimasa.github.io/categories/ubuntu%E7%9A%84%E4%BD%BF%E7%94%A8/vim%E7%9A%84%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97/"/>
    
    
      <category term="关于ubuntu" scheme="http://aimasa.github.io/tags/%E5%85%B3%E4%BA%8Eubuntu/"/>
    
  </entry>
  
  <entry>
    <title>eclipse调字体大小</title>
    <link href="http://aimasa.github.io/2019/04/23/eclipse%E8%B0%83%E5%AD%97%E4%BD%93%E5%A4%A7%E5%B0%8F/"/>
    <id>http://aimasa.github.io/2019/04/23/eclipse调字体大小/</id>
    <published>2019-04-23T07:19:48.000Z</published>
    <updated>2019-04-23T07:19:48.632Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>关于maven</title>
    <link href="http://aimasa.github.io/2019/04/18/%E5%85%B3%E4%BA%8Emaven/"/>
    <id>http://aimasa.github.io/2019/04/18/关于maven/</id>
    <published>2019-04-18T07:07:41.000Z</published>
    <updated>2019-04-29T07:13:58.353Z</updated>
    
    <content type="html"><![CDATA[<p>之前一直只是单纯的知道maven是用来加载库的，然后去代码里面调用它。里面<dependencies>&lt;/dependencies&gt;这里面是存放需要被调用的库的依赖。但是maven里面包括的内容除了<dependencies></dependencies>还有别的，所以就去查了一些资料，然后总结在这。</dependencies></p><a id="more"></a><p>Maven 主要帮助用户完成以下 3 个方面的工作：</p><ul><li>生命周期管理，便捷的构建过程；</li><li>依赖管理，方便引入所需依赖 Jar 包；</li><li>仓库管理，提供统一管理所有 Jar 包的工具；</li></ul><p>————-(<a href="https://www.jianshu.com/p/b4ef9978d85d" target="_blank" rel="noopener">摘自博客</a>)</p><p>在建了一个maven项目之后，会发现在项目里面有一个pom.xml文档</p><h1 id="什么是pom"><a href="#什么是pom" class="headerlink" title="什么是pom"></a>什么是pom</h1><p>项目对象模型或POM是Maven的基本工作单元。 它是一个XML文件，其中包含有关Maven用于构建项目的项目和配置详细信息的信息。 它包含大多数项目的默认值。 这方面的例子是：target是构建目录;构建源目录是src / main / java; src / test / java是测试源目录。执行任务时，Maven在当前目录中查找POM。 它读取POM，获取所需的配置信息，然后执行目标。</p><p>maven install时候，会自动把pom里面添加的依赖下载下来。</p><h1 id="maven的生命周期"><a href="#maven的生命周期" class="headerlink" title="maven的生命周期"></a>maven的生命周期</h1><p>maven内部有三个构建生命周期：分别是：clean, default, site</p><p>我在那个博客里面找到了这张展示default构建生命周期核心阶段的图：</p><center><img src="http://pp48biywe.bkt.clouddn.com/static/images/关于maven/life.png"></center><p>当执行mvn install时候，maven就会自动执行生命周期中的validate, compile, test, package, verify, install这些阶段，并将 package 生成的包发布到本地仓库中。</p><p>Maven 将构建过程定义为 default lifecycle</p><h2 id="阶段和插件的关系"><a href="#阶段和插件的关系" class="headerlink" title="阶段和插件的关系"></a>阶段和插件的关系</h2><p>就像上面说的那样，maven把构建过程定义成default lifecycle，并且将它里面的一个个阶段划分为phase，但是这些phase只是规定执行顺序，对于每个阶段做什么工作，就要看pom.xml里面的插件（plugins）了。</p><p>pom.xml里面有这么个元素叫<plugins>，它是用来把phase和做的目标<goal>绑定在一起，当要执行某个<phase>时候，就会调用插件来完成绑定的目标，一个阶段里面可以绑定好多个目标，也可以不绑定目标。</phase></goal></plugins></p><p>但是不配置<plugins>也可以，因为maven有默认的<plugins>。</plugins></plugins></p><p>在输出日志里面，会有一系列的 插件(plugin):版本号:<goal>(phase) 输出，可以根据日志里面的这种输出去观察哪些阶段会调用插件去完成那些<goal>了。</goal></goal></p><h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><p>在<dependencies></dependencies>里面的依赖一般都是这种形式出现：</p><pre><code>    &lt;dependency&gt;    &lt;groupId&gt;mysql&lt;/groupId&gt;    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;    &lt;scope&gt;runtime&lt;/scope&gt;    &lt;/dependency&gt;</code></pre><h2 id="关于maven整体"><a href="#关于maven整体" class="headerlink" title="关于maven整体"></a>关于maven整体</h2><p>| groupId|一般用该项目的组织或团体的域名来标识，例如:org.apache.maven.plugins  |</p><p>| artifactId | 代表唯一的工程名 |</p><p>|version| 版本号|</p><p>|packaging| 标识打包的类型，例如有:jar, war, tar |</p><p>|dependencies| 该工程内依赖的其他 jar 包|</p><h2 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h2><p>如果 Maven 在中央仓库中也找不到依赖的库文件，它会停止构建过程并输出错误信息到控制台。为避免这种情况，Maven 提供了远程仓库的概念，它是开发人员自己定制仓库，包含了所需要的代码库或者其他工程中用到的 jar 文件。</p><h2 id=""><a href="#" class="headerlink" title=""></a><respositories></respositories></h2><p>我的理解就是可以通过这个repositories节点，去访问给出的url地址上的这个仓库，去下载自己需要的库，因为这个库在可能是自己的远程仓库里面，就没法从中央仓库里面下载到这个库，所以就使用这个节点，里面配置各种你可能需要用到的远程库。</p><pre><code>&lt;repositories&gt;    &lt;repository&gt;        &lt;id&gt;spring-snapshots&lt;/id&gt;        &lt;name&gt;Spring Snapshots&lt;/name&gt;        &lt;url&gt;https://repo.spring.io/snapshot&lt;/url&gt;        &lt;snapshots&gt;            &lt;enabled&gt;true&lt;/enabled&gt;        &lt;/snapshots&gt;    &lt;/repository&gt;</code></pre><h2 id="Maven-依赖搜索顺序"><a href="#Maven-依赖搜索顺序" class="headerlink" title="Maven 依赖搜索顺序"></a>Maven 依赖搜索顺序</h2><p>当我们执行 Maven 构建命令时，Maven 开始按照以下顺序查找依赖的库：</p><ul><li>步骤 1 － 在本地仓库中搜索，如果找不到，执行步骤 2，如果找到了则执行其他操作。</li><li>步骤 2 － 在中央仓库中搜索，如果找不到，并且有一个或多个远程仓库已经设置，则执行步骤 4，如果找到了则下载到本地仓库中已被将来引用。</li><li>步骤 3 － 如果远程仓库没有被设置，Maven 将简单的停滞处理并抛出错误（无法找到依赖的文件）。</li><li>步骤 4 － 在一个或多个远程仓库中搜索依赖的文件，如果找到则下载到本地仓库已被将来引用，否则 Maven 将停止处理并抛出错误（无法找到依赖的文件）。</li></ul><p>———————————<a href="https://wiki.jikexueyuan.com/project/maven/repositories.html" target="_blank" rel="noopener">摘自极客学院maven教程</a></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.jianshu.com/p/b4ef9978d85d" target="_blank" rel="noopener">maven入门</a></p><p><a href="https://www.jianshu.com/p/fd43b3d0fdb0" target="_blank" rel="noopener">maven生命周期</a></p><p><a href="https://wiki.jikexueyuan.com/project/maven/repositories.html" target="_blank" rel="noopener">极客学院maven教程</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前一直只是单纯的知道maven是用来加载库的，然后去代码里面调用它。里面&lt;dependencies&gt;&amp;lt;/dependencies&amp;gt;这里面是存放需要被调用的库的依赖。但是maven里面包括的内容除了&lt;dependencies&gt;&lt;/dependencies&gt;还有别的，所以就去查了一些资料，然后总结在这。&lt;/dependencies&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="maven" scheme="http://aimasa.github.io/categories/maven/"/>
    
    
      <category term="maven" scheme="http://aimasa.github.io/tags/maven/"/>
    
  </entry>
  
  <entry>
    <title>开始学习spring（五）：连接数据库</title>
    <link href="http://aimasa.github.io/2019/04/17/%E5%BC%80%E5%A7%8B%E5%AD%A6%E4%B9%A0spring%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9A%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>http://aimasa.github.io/2019/04/17/开始学习spring（五）：连接数据库/</id>
    <published>2019-04-17T03:01:44.000Z</published>
    <updated>2019-04-29T09:17:54.904Z</updated>
    
    <content type="html"><![CDATA[<p>因为这边都用的是jooq框架来对数据库进行操作，然后我就开始学jooq框架惹==。我暑假还是想好好的活着，不想再像上个暑假一样痛苦。</p><p>不过刚开始接触这个框架，坑也没少踩，我会在下面分别列出来。</p><p>用的是maven</p><a id="more"></a><h1 id="第一步：装依赖"><a href="#第一步：装依赖" class="headerlink" title="第一步：装依赖"></a>第一步：装依赖</h1><p>在jooq的官网看，首先第一步，在pom中要加上这三个依赖</p><pre><code>    &lt;dependency&gt;        &lt;groupId&gt;org.jooq&lt;/groupId&gt;        &lt;artifactId&gt;jooq&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.jooq&lt;/groupId&gt;        &lt;artifactId&gt;jooq-meta&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.jooq&lt;/groupId&gt;        &lt;artifactId&gt;jooq-codegen&lt;/artifactId&gt;    &lt;/dependency&gt;</code></pre><ul><li>jooq ：核心包，CRUD（增删查改）核心类所在大本营。</li><li>jooq-meta ：数据管理和操作的核心代码。</li><li>jooq-codegen ：负责数据库代码生成，主要负责JOOQ的代码生成功能。</li></ul><h1 id="第二步：加插件"><a href="#第二步：加插件" class="headerlink" title="第二步：加插件"></a>第二步：加插件</h1><pre><code>        &lt;plugin&gt;            &lt;groupId&gt;org.jooq&lt;/groupId&gt;            &lt;artifactId&gt;jooq-codegen-maven&lt;/artifactId&gt;            &lt;executions&gt;                &lt;execution&gt;                    &lt;goals&gt;                        &lt;goal&gt;generate&lt;/goal&gt;                    &lt;/goals&gt;                &lt;/execution&gt;            &lt;/executions&gt;            &lt;dependencies&gt;                &lt;dependency&gt;                    &lt;groupId&gt;mysql&lt;/groupId&gt;                    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;                    &lt;version&gt;5.1.39&lt;/version&gt;                &lt;/dependency&gt;            &lt;/dependencies&gt;            &lt;configuration&gt;                &lt;jdbc&gt;                    &lt;driver&gt;com.mysql.jdbc.Driver&lt;/driver&gt;                    &lt;url&gt;jdbc:mysql://localhost:3306/exercise_test?useSSL=true&lt;/url&gt;                    &lt;user&gt;root&lt;/user&gt;                    &lt;password&gt;&lt;/password&gt;                &lt;/jdbc&gt;                &lt;generator&gt;                    &lt;database&gt;                        &lt;name&gt;org.jooq.util.mysql.MySQLDatabase&lt;/name&gt;                        &lt;includes&gt;.*&lt;/includes&gt;                        &lt;excludes&gt;&lt;/excludes&gt;                        &lt;inputSchema&gt;exercise_test&lt;/inputSchema&gt;                        &lt;forcedTypes&gt;                            &lt;forcedType&gt;                                &lt;userType&gt;java.util.Date&lt;/userType&gt;                                &lt;converter&gt;com.example.util.DateConverter&lt;/converter&gt;                                &lt;types&gt;datetime&lt;/types&gt;                            &lt;/forcedType&gt;                        &lt;/forcedTypes&gt;                    &lt;/database&gt;                    &lt;target&gt;                        &lt;!-- The destination package of your generated classes (within the                             destination directory) --&gt;                        &lt;packageName&gt;com.example.pojo&lt;/packageName&gt;                        &lt;!-- The destination directory of your generated classes --&gt;                        &lt;directory&gt;/src/main/java&lt;/directory&gt;                    &lt;/target&gt;                    &lt;generate&gt;                        &lt;pojos&gt;true&lt;/pojos&gt;                        &lt;daos&gt;true&lt;/daos&gt;                        &lt;deprecated&gt;false&lt;/deprecated&gt;                    &lt;/generate&gt;                &lt;/generator&gt;            &lt;/configuration&gt;        &lt;/plugin&gt;</code></pre><p>这一部分是用来生成数据库映射代码的插件。</p><p>里面是对数据库的信息进行配置：</p><pre><code>            &lt;configuration&gt;                &lt;jdbc&gt;                    &lt;driver&gt;com.mysql.jdbc.Driver&lt;/driver&gt;                    &lt;url&gt;jdbc:mysql://localhost:3306/exercise_test?useSSL=true&lt;/url&gt;                    &lt;user&gt;root&lt;/user&gt;                    &lt;password&gt;&lt;/password&gt;                &lt;/jdbc&gt;                &lt;generator&gt;                    &lt;database&gt;                        &lt;name&gt;org.jooq.util.mysql.MySQLDatabase&lt;/name&gt;                        &lt;includes&gt;.*&lt;/includes&gt;&lt;!--点后面的所有文件--&gt;                        &lt;excludes&gt;&lt;/excludes&gt;                        &lt;!--映射的数据库的架构名（就是你的表是放在哪个架构下的）--&gt;                        &lt;inputSchema&gt;exercise_test&lt;/inputSchema&gt;                        &lt;forcedTypes&gt;                            &lt;forcedType&gt;                                &lt;userType&gt;java.util.Date&lt;/userType&gt;                                &lt;converter&gt;com.example.util.DateConverter&lt;/converter&gt;                                &lt;types&gt;datetime&lt;/types&gt;                            &lt;/forcedType&gt;                        &lt;/forcedTypes&gt;                    &lt;/database&gt;                    &lt;target&gt;                        &lt;!-- 你数据库映射出来的表打算放在代码里面的哪个包下 --&gt;                        &lt;packageName&gt;com.example.pojo&lt;/packageName&gt;                        &lt;!-- 这个包是应该在哪个class下面 --&gt;                        &lt;directory&gt;/src/main/java&lt;/directory&gt;                    &lt;/target&gt;                    &lt;generate&gt;                        &lt;pojos&gt;true&lt;/pojos&gt;                        &lt;daos&gt;true&lt;/daos&gt;                        &lt;deprecated&gt;false&lt;/deprecated&gt;                    &lt;/generate&gt;                &lt;/generator&gt;            &lt;/configuration&gt;</code></pre><p>这里面配置这段就是把数据库中的表映射出来的。</p><pre><code>                         &lt;forcedTypes&gt;                            &lt;forcedType&gt;                                &lt;userType&gt;java.util.Date&lt;/userType&gt;                                &lt;converter&gt;com.example.util.DateConverter&lt;/converter&gt;                                &lt;types&gt;datetime&lt;/types&gt;                            &lt;/forcedType&gt;                        &lt;/forcedTypes&gt;</code></pre><p>这段代码是用来映射时间戳的，其中</p><pre><code>&lt;converter&gt;com.example.util.DateConverter&lt;/converter&gt;</code></pre><p>是放有映射方法的包，没有放映射方法的话，那这段无效==。可以按ctrl进去，查看这个包，如果无法查看的话，那么说明这个包不是需要的。</p><h1 id="数据库的架构"><a href="#数据库的架构" class="headerlink" title="数据库的架构"></a>数据库的架构</h1><p>放张图就很详细了：</p><center><img src="http://pp48biywe.bkt.clouddn.com/static/images/开始学习spring（五）：连接数据库/schema.png"></center><h1 id="出错地方"><a href="#出错地方" class="headerlink" title="出错地方"></a>出错地方</h1><p>这样配置完成后，我的这个项目名旁边跟了一个红<strong>×</strong>，所以就右键项目，选中<strong>maven</strong>，出现子目录，选中<strong>update project</strong>，点击，如果配置没有错误的话，红<strong>×</strong>会自然消失。</p><p>然后就是maven install的问题了，显示BUILD FAILED失败，里面有一句话，翻译过来是问我有没有配置错jdk，所以我就去perferences里面的 java-&gt;install JREs看了看里面的包是不是配置的jdk包，如果不是，点击add-&gt;Standard VM-&gt;next-&gt;选择jdk的包</p><p>再然后maven install就没有再出问题了，同时，也将我数据库里的表转换成了pojo的包里的java类了。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="http://www.mysunshinedreams.com/orm%E7%9A%84%E5%B0%8F%E6%B8%85%E6%96%B0-jooq/" target="_blank" rel="noopener">参考博客</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;因为这边都用的是jooq框架来对数据库进行操作，然后我就开始学jooq框架惹==。我暑假还是想好好的活着，不想再像上个暑假一样痛苦。&lt;/p&gt;
&lt;p&gt;不过刚开始接触这个框架，坑也没少踩，我会在下面分别列出来。&lt;/p&gt;
&lt;p&gt;用的是maven&lt;/p&gt;
    
    </summary>
    
      <category term="spring相关" scheme="http://aimasa.github.io/categories/spring%E7%9B%B8%E5%85%B3/"/>
    
      <category term="连接数据库" scheme="http://aimasa.github.io/categories/spring%E7%9B%B8%E5%85%B3/%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="spring相关" scheme="http://aimasa.github.io/tags/spring%E7%9B%B8%E5%85%B3/"/>
    
  </entry>
  
  <entry>
    <title>开始学习spring（四）：Junit测试</title>
    <link href="http://aimasa.github.io/2019/04/10/%E5%BC%80%E5%A7%8B%E5%AD%A6%E4%B9%A0spring%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9AJunit%E6%B5%8B%E8%AF%95/"/>
    <id>http://aimasa.github.io/2019/04/10/开始学习spring（四）：Junit测试/</id>
    <published>2019-04-10T03:11:31.000Z</published>
    <updated>2019-04-12T07:51:27.480Z</updated>
    
    <content type="html"><![CDATA[<p>跟着<a href="http://blog.didispace.com/spring-boot-learning-1/" target="_blank" rel="noopener">博客</a>开始学怎么用Junit对写出的部分代码进行单元测试。</p><a id="more"></a><h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><p>跟着它给的代码：</p><pre><code>@RunWith(SpringJUnit4ClassRunner.class)@SpringBootTest(classes=MockServletContext.class)@WebAppConfigurationpublic class DemoApplicationTests {    private MockMvc mvc;    @Before    public void Setup() throws Exception {        mvc = MockMvcBuilders.standaloneSetup(new exampleController()).build();    }    @Test    public void contextLoads() throws Exception{        mvc.perform(MockMvcRequestBuilders.get(&quot;/&quot;).accept(MediaType.APPLICATION_JSON))                .andExpect(status().isOk())                .andExpect(content().string(equalTo(&quot;index&quot;))).andDo(print());    }}</code></pre><p>但是很奇怪的是一直在</p><pre><code> .andExpect(content().string(equalTo(&quot;index&quot;))).andDo(print());</code></pre><p>这个部分报错，说<strong>The method content()/equalTo() is ambiguous for the type DemoApplicationTests</strong></p><p>结果我发现在我直接敲入这段代码时候，eclipse会直接帮忙自动导入对应的包：</p><pre><code>import static org.hamcrest.CoreMatchers.equalTo;import static org.hamcrest.Matchers.equalTo;import static org.springframework.test.web.client.match.MockRestRequestMatchers.content;import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;</code></pre><p>里面会有不同包里面的同名称的类文件，在这里我们选用：</p><pre><code>import static org.hamcrest.Matchers.equalTo;import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;</code></pre><h1 id="讲解"><a href="#讲解" class="headerlink" title="讲解"></a>讲解</h1><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><h3 id="MockMvcBuilders"><a href="#MockMvcBuilders" class="headerlink" title="MockMvcBuilders"></a>MockMvcBuilders</h3><p>这个是用来构造MockMvc的构造器，主要是有两种实现，分别是StandaloneMockMvcBuilder和DefaultMockMvcBuilder一种是独立安装和集成Web环境测试（此种方式并不会集成真正的web环境，而是通过相应的Mock API进行模拟测试，无须启动服务器）。</p><p>较新版的Spring Boot取消了@SpringApplicationConfiguration这个注解，用@SpringBootTest就可以了</p><h3 id="集成web环境测试"><a href="#集成web环境测试" class="headerlink" title="集成web环境测试"></a>集成web环境测试</h3><p>MockMvcBuilders.webAppContextSetup(WebAppContext webAppContext):指定的webAPPContext会从<strong>上下文中去获取相应的控制器</strong>并得到相应的MockMvc</p><p>怎么获取呢？所以就在测试的程序前面加上@ContextConfiguration(classes = xxx.class)（xxx.class是自己定义的配置类，继承WebMvcConfigurerAdapter 这个类的类，新版spring boot不用继承这类再去使用了，会报错，它改成直接用接口形式implements这个类，并且去使用，还有一个方法来着去使用这个类，但是我忘了，可以直接谷歌一下，WebMvcConfigurerAdapter配置类其实是Spring内部的一种配置方式，采用JavaBean的形式来代替传统的xml配置文件形式进行针对框架个性化定制，它是对需要进行拦截的地方是要使用的拦截器配好对）。</p><p>（拦截器是什么：拦截器相当于把一部分会需要经常改动的代码提取出来，然后对一些固有操作执行前进行拦截，去运行在不同情况下需要运行的代码。减少代码的冗余度，提高重用率。也就是AOP的一种运用。）</p><p>如果没有@ContextConfiguration是会报错的。</p><p>@WebAppConfiguration：测试环境使用，用来表示测试环境使用的ApplicationContext将是WebApplicationContext类型的；value指定web应用的根；</p><p>@Autowired WebApplicationContext wac:注入web环境的applicationContext容器；</p><p>然后通过MockMvcBuilders.webAppContextSetup(this.wac).build();创建一个MockMvc去测试。</p><h3 id="独立测试方式"><a href="#独立测试方式" class="headerlink" title="独立测试方式"></a>独立测试方式</h3><p>这个MockMvcBuilders.standaloneSetup(Object… controllers)可以通过参数去指定一组或者一个控制器，而不需要上下文获取了。</p><p>只需两个步骤：创建相应的控制器，然后注入相应的依赖；通过MockMvcBuilders.standaloneSetup(Object… controllers).bulid()去获取一个MockMvc去测试。</p><h2 id="RequestBuilder"><a href="#RequestBuilder" class="headerlink" title="RequestBuilder"></a>RequestBuilder</h2><p>RequestBuilder这个是用来存放模拟输入的命令的。比如在这里我要测试控制层的输出结果是不是我想要的，然后我会用RequestBuilder.get/post/put…(/网址/).param()…这样去模拟数据输入，进而测试程序有没有错误。</p><pre><code>        request = get(&quot;/users/&quot;);</code></pre><p>RequestBuilder执行完这一步之后，里面会存放如下参数：</p><center><img src="http://pp48biywe.bkt.clouddn.com/static/images/开始学习spring（四）：Junit测试/RequestBuilder.png"></center><p>可以从图中看到里面有我刚开始设置进去的网址”/users”,然后其他值设置之类地方都是显示null，或者[]或者{}。</p><h1 id="关于content-string-equalTo-xxx"><a href="#关于content-string-equalTo-xxx" class="headerlink" title="关于content().string(equalTo(xxx))"></a>关于content().string(equalTo(xxx))</h1><p>跟着敲完对控制层的测试类之后，一直报错，我debug发现，不是程序里面的问题，是我参数出的问题。</p><p>我里面的参数不是少了对字符串的外标的双引号，就是字符串的排列顺序不对</p><p>我设置的返回值是对User实例化后的字符串的值的返回</p><pre><code>public class User {    private String name;    private long id;    private Integer age;}</code></pre><p>里面按照顺序需要：name 、 id 、 age这个顺序返回值，然后碰到字符串时候，需要上标双引号，但是因为本身我就是设置它需要根据我给出的字符串去比较是不是我想要的结果，所以在content().string(equalTo(xxx))里面，xxx这个字符串中的双引号需要转义字符：\”</p><pre><code>content().string(equalTo(&quot;[{\&quot;name\&quot;:\&quot;nana\&quot;,\&quot;id\&quot;:1,\&quot;age\&quot;:12}]&quot;))).andDo(print())</code></pre><h2 id="测试部分"><a href="#测试部分" class="headerlink" title="测试部分"></a>测试部分</h2><p>perform：执行一个RequestBuilder请求，会自动执行SpringMVC的流程并映射到相应的控制器执行处理；</p><p>andExpect：添加ResultMatcher验证规则，验证控制器执行完成后结果是否正确；</p><p>andDo：添加ResultHandler结果处理器，比如调试时打印结果到控制台；</p><p>andReturn：最后返回相应的MvcResult；然后进行自定义验证/进行下一步的异步处理；</p><p>accept：接收的返回的信息格式，这里是接收的是json类型数据。</p><p>ContentResultMatchers content()：得到响应内容验证器；</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://blog.csdn.net/cankingapp/article/details/7626566" target="_blank" rel="noopener">关于拦截器讲解比较详细的博客</a></p><p><a href="https://www.cnblogs.com/lyy-2016/p/6122144.html" target="_blank" rel="noopener">关于测试部分讲解详细的博客</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;跟着&lt;a href=&quot;http://blog.didispace.com/spring-boot-learning-1/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;博客&lt;/a&gt;开始学怎么用Junit对写出的部分代码进行单元测试。&lt;/p&gt;
    
    </summary>
    
      <category term="spring相关" scheme="http://aimasa.github.io/categories/spring%E7%9B%B8%E5%85%B3/"/>
    
      <category term="Junit测试" scheme="http://aimasa.github.io/categories/spring%E7%9B%B8%E5%85%B3/Junit%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="spring相关" scheme="http://aimasa.github.io/tags/spring%E7%9B%B8%E5%85%B3/"/>
    
  </entry>
  
  <entry>
    <title>开始学习spring（三）：注解2</title>
    <link href="http://aimasa.github.io/2019/04/08/%E5%BC%80%E5%A7%8B%E5%AD%A6%E4%B9%A0spring%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E6%B3%A8%E8%A7%A32/"/>
    <id>http://aimasa.github.io/2019/04/08/开始学习spring（三）：注解2/</id>
    <published>2019-04-08T13:14:34.000Z</published>
    <updated>2019-04-12T12:13:35.447Z</updated>
    
    <content type="html"><![CDATA[<p>虽然明白注解是怎么一回事了，但是还是好奇它的反射机制是怎么实现的，所以谷歌了一下，之后可能会试着自己看看源码。</p><p>注：在 Spring 中，构成应用程序主干并由Spring IoC容器管理的对象称为bean。bean是一个由Spring IoC容器实例化、组装和管理的对象。</p><p><a href="https://www.awaimai.com/2596.html" target="_blank" rel="noopener">关于IoC(控制反转)</a></p><a id="more"></a><h1 id="RequestMapping"><a href="#RequestMapping" class="headerlink" title="RequestMapping"></a>RequestMapping</h1><p>这个是用来处理请求地址映射的注解，它的注解有六个属性：</p><h2 id="value"><a href="#value" class="headerlink" title="value"></a>value</h2><p><strong>value</strong>：指定请求的实际地址</p><p><strong>method</strong>： 指定请求的method类型， GET、POST、PUT、DELETE等；</p><center><img src="http://pp48biywe.bkt.clouddn.com/static/images/开始学习spring（三）：注解2/method.png"></center><p><strong>consumes</strong>：指定处理请求的提交内容类型（Content-Type），例如application/json, text/html;</p><p><strong>produces</strong>: 指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回；</p><p><strong>params</strong>： 指定request中必须包含某些参数值是，才让该方法处理。</p><p><strong>headers</strong>： 指定request中必须包含某些指定的header值，才能让该方法处理请求。</p><p>———————-<a href="https://blog.csdn.net/walkerJong/article/details/7994326" target="_blank" rel="noopener">摘自博客</a>等我用了一遍再回来补充。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;虽然明白注解是怎么一回事了，但是还是好奇它的反射机制是怎么实现的，所以谷歌了一下，之后可能会试着自己看看源码。&lt;/p&gt;
&lt;p&gt;注：在 Spring 中，构成应用程序主干并由Spring IoC容器管理的对象称为bean。bean是一个由Spring IoC容器实例化、组装和管理的对象。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.awaimai.com/2596.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;关于IoC(控制反转)&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="spring相关" scheme="http://aimasa.github.io/categories/spring%E7%9B%B8%E5%85%B3/"/>
    
      <category term="注解" scheme="http://aimasa.github.io/categories/spring%E7%9B%B8%E5%85%B3/%E6%B3%A8%E8%A7%A3/"/>
    
      <category term="spring注解" scheme="http://aimasa.github.io/categories/spring%E7%9B%B8%E5%85%B3/%E6%B3%A8%E8%A7%A3/spring%E6%B3%A8%E8%A7%A3/"/>
    
    
      <category term="spring相关" scheme="http://aimasa.github.io/tags/spring%E7%9B%B8%E5%85%B3/"/>
    
  </entry>
  
  <entry>
    <title>开始学习spring（三）：注解</title>
    <link href="http://aimasa.github.io/2019/04/04/%E5%BC%80%E5%A7%8B%E5%AD%A6%E4%B9%A0spring%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E6%B3%A8%E8%A7%A3/"/>
    <id>http://aimasa.github.io/2019/04/04/开始学习spring（三）：注解/</id>
    <published>2019-04-04T06:49:42.000Z</published>
    <updated>2019-04-08T13:49:14.008Z</updated>
    
    <content type="html"><![CDATA[<p>因为spring Boot项目里面一直要用到注解，所以我特地开了一篇文章来介绍元注解和自定义注解。关于@ResponseMapping这类经常用到的注解可能会零开一篇去写。</p><p>现有的spring提供了大量的注解，而且点进去会发现它的源码很短，注解中用到的Annotations元注解其实只是元数据，和业务逻辑一点关系都没有，既然和业务逻辑没有关系，那么就必须有人来实现这些逻辑。Annotations仅仅提供它定义的属性(类/方法/包/域)的信息.</p><p>当我们使用Java的标注Annotations(例如@Override)时，JVM就是一个用户，它在字节码层面工作。</p><p>bean 是组件的意思。</p><a id="more"></a><h1 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h1><p>一共有以下个元注解</p><ul><li>@Document</li><li>@Target</li><li>@Retention</li><li>@Inherited</li></ul><h2 id="Target"><a href="#Target" class="headerlink" title="@Target"></a>@Target</h2><p>它是用来约束注解的使用范围的，可以用ElementType类型去给它定义使用范围，一下是它的源代码：</p><pre><code>public enum ElementType {    /** Class, interface (including annotation type), or enum declaration */    TYPE,    /** Field declaration (includes enum constants) */    FIELD,    /** Method declaration */    METHOD,    /** Formal parameter declaration */    PARAMETER,    /** Constructor declaration */    CONSTRUCTOR,    /** Local variable declaration */    LOCAL_VARIABLE,    /** 用于另外一个注解上 */    ANNOTATION_TYPE,    /** Package declaration */    PACKAGE,    /**     * Type parameter declaration     *     * @since 1.8     */    TYPE_PARAMETER,    /**     * Use of a type     *     * @since 1.8     */    TYPE_USE}</code></pre><p>如果这个注解中@Target没有被申明，那么意思是它可以被应用在任何元素之上。</p><h1 id="Retention"><a href="#Retention" class="headerlink" title="@Retention"></a>@Retention</h1><p>这个元注解是用来约束注解的生命周期的。里面有三个状态，一个是源码级别（source）、一个是类文件级别（class）、还一个是运行时级别（runtime）</p><ul><li>source ： 注解将被编译器丢弃（这个类型的注解信息只保留在源码里面，源码经过编译后，注解信息会被丢弃，不会保留在编译好的class里面。）如java内置注解：@Override、@SuppressWarnning等</li><li>class ： 注解在class文件里可用，但是会被vm（虚拟机）抛弃（这个类型的注解信息只会保存在源码里面和class文件里面，在运行时候，不会载入虚拟机里面），<strong>当注解没有定义Retention的时候，会默认是class</strong>，如java内置注解：</li><li>runtime ： 注解信息将在运行期（JVM）中也保留，因此可以通过反射机制读取注解的信息。（源码、class文件和虚拟机中都有注解的信息。）如SpringMvc中的@Controller、@Autowired、@RequestMapping等，如java内置注解：@Deprecated(用于标明已经过时的方法或类)等。</li></ul><h1 id="Documented"><a href="#Documented" class="headerlink" title="@Documented"></a>@Documented</h1><p>@Documented 被修饰的注解会生成到javadoc中</p><h1 id="Inherited"><a href="#Inherited" class="headerlink" title="@Inherited"></a>@Inherited</h1><p>可以让注解被继承，但这并不是真的继承，只是通过使用@Inherited，可以让子类Class对象使用getAnnotations()获取父类被@Inherited修饰的注解。</p><h1 id="关于自定义注解里面的一些语句"><a href="#关于自定义注解里面的一些语句" class="headerlink" title="关于自定义注解里面的一些语句"></a>关于自定义注解里面的一些语句</h1><pre><code>String name() default &quot;&quot;;//指定义了name这个属性，默认是空字符串。</code></pre><p>声明注解类型时候，不能用包装类型，只能用基本类型去声明</p><pre><code>@Target({ElementType.TYPE})@Retention(RetentionPolicy.RUNTIME)@Documented@Componentpublic @interface Controller {    @AliasFor(annotation = Component.class)    String value() default &quot;&quot;;}</code></pre><p>因为上面除掉元注解外还有@component，说明@controller这个注解属于@component这个注解</p><p>我们定义了自己的注解并将其应用在业务逻辑的方法上。所以就需要我们写一个用户程序调用我们的注解。这里需要使用<strong>反射机制</strong>。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://blog.csdn.net/javazejian/article/details/71860633" target="_blank" rel="noopener">我觉得写得很详细的</a></p><p><a href="http://www.importnew.com/10294.html" target="_blank" rel="noopener">注解是什么</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;因为spring Boot项目里面一直要用到注解，所以我特地开了一篇文章来介绍元注解和自定义注解。关于@ResponseMapping这类经常用到的注解可能会零开一篇去写。&lt;/p&gt;
&lt;p&gt;现有的spring提供了大量的注解，而且点进去会发现它的源码很短，注解中用到的Annotations元注解其实只是元数据，和业务逻辑一点关系都没有，既然和业务逻辑没有关系，那么就必须有人来实现这些逻辑。Annotations仅仅提供它定义的属性(类/方法/包/域)的信息.&lt;/p&gt;
&lt;p&gt;当我们使用Java的标注Annotations(例如@Override)时，JVM就是一个用户，它在字节码层面工作。&lt;/p&gt;
&lt;p&gt;bean 是组件的意思。&lt;/p&gt;
    
    </summary>
    
      <category term="spring相关" scheme="http://aimasa.github.io/categories/spring%E7%9B%B8%E5%85%B3/"/>
    
      <category term="注解" scheme="http://aimasa.github.io/categories/spring%E7%9B%B8%E5%85%B3/%E6%B3%A8%E8%A7%A3/"/>
    
      <category term="注解大体简介" scheme="http://aimasa.github.io/categories/spring%E7%9B%B8%E5%85%B3/%E6%B3%A8%E8%A7%A3/%E6%B3%A8%E8%A7%A3%E5%A4%A7%E4%BD%93%E7%AE%80%E4%BB%8B/"/>
    
    
      <category term="spring相关" scheme="http://aimasa.github.io/tags/spring%E7%9B%B8%E5%85%B3/"/>
    
  </entry>
  
  <entry>
    <title>二分排序法</title>
    <link href="http://aimasa.github.io/2019/04/03/%E4%BA%8C%E5%88%86%E6%8E%92%E5%BA%8F%E6%B3%95/"/>
    <id>http://aimasa.github.io/2019/04/03/二分排序法/</id>
    <published>2019-04-03T03:29:45.000Z</published>
    <updated>2019-04-04T10:34:15.751Z</updated>
    
    <content type="html"><![CDATA[<p>这是很久前写的一篇博文，现在转移了地址，就一起把这篇博文转过来。</p><p>二分排序法书上的讲解用的是借抓<br>扑克牌这个模式讲的</p><a id="more"></a><h1 id="二分法排序"><a href="#二分法排序" class="headerlink" title="二分法排序"></a>二分法排序</h1><pre><code>public class B {    public void BinarySort(int[] a) {        for (int i = 1; i &lt; a.length; i++) {            int tmp = a[i];            int left = 0;            int right = i - 1;            while (left &lt;= right) {                int mid = (right + left)&gt;&gt;1;                if (a[mid] &gt; tmp) {                    right = mid - 1;                } else {                    left = mid + 1;                }            }            for (int j = i - 1; j &gt;= left; j--) {                a[j + 1] = a[j];            }            a[left] = tmp;        }    }}public class test {    public static void main(String[] args) {        int[] a= {1,24,5,6,3,2,7,8,2};        B b=new B();        b.BinarySort(a);        for(int i=0;i&lt;a.length;i++){        System.out.println(a[i]);}    }}</code></pre><p> 就是先从低位开始排序，从i=1开始大循环，从已经排好序的left和right中折中取中间数，然后再和还未排序的数字进行比较大小，如果是大于中间数的话那么更改left指向位置（指向中间数后一个数据），依次循环，如果right小于left的话终止比较（这样就不会忘记把right指向的数据和需要排序的数据进行比较）。接着就插入，像插入排序那样进行数据交换，把这个未排序的数字插入该插入的地方。</p><p>ps:求left和right之间的mid的等式是：（left+right）&gt;&gt;1！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是很久前写的一篇博文，现在转移了地址，就一起把这篇博文转过来。&lt;/p&gt;
&lt;p&gt;二分排序法书上的讲解用的是借抓&lt;br&gt;扑克牌这个模式讲的&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://aimasa.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="二分排序法" scheme="http://aimasa.github.io/categories/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%8E%92%E5%BA%8F%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://aimasa.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>MavenInstall错误类型（一）</title>
    <link href="http://aimasa.github.io/2019/04/03/MavenInstall%E9%94%99%E8%AF%AF%E7%B1%BB%E5%9E%8B%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://aimasa.github.io/2019/04/03/MavenInstall错误类型（一）/</id>
    <published>2019-04-03T00:57:51.000Z</published>
    <updated>2019-04-03T01:03:09.646Z</updated>
    
    <content type="html"><![CDATA[<p>工具：STS</p><p>在Maven Install加载pom.xml里面添加的依赖时候，结果出了错误：Failed to execute goal org.apache.maven.plugins:maven-surefire-plugin:2.22.1</p><a id="more"></a><p>我百度了一会，各种方法都试过，却没有用，结果发现是我之前点击Spring Boot App这里让这个项目运行起来了，但是却没有关闭，然后再点击Maven Install，所以报错了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;工具：STS&lt;/p&gt;
&lt;p&gt;在Maven Install加载pom.xml里面添加的依赖时候，结果出了错误：Failed to execute goal org.apache.maven.plugins:maven-surefire-plugin:2.22.1&lt;/p&gt;
    
    </summary>
    
      <category term="运行error" scheme="http://aimasa.github.io/categories/%E8%BF%90%E8%A1%8Cerror/"/>
    
      <category term="Maven Install错误类型：Failed to execute goal org.apache.maven.plugins:maven-surefire-plugin:2.22.1" scheme="http://aimasa.github.io/categories/%E8%BF%90%E8%A1%8Cerror/Maven-Install%E9%94%99%E8%AF%AF%E7%B1%BB%E5%9E%8B%EF%BC%9AFailed-to-execute-goal-org-apache-maven-plugins-maven-surefire-plugin-2-22-1/"/>
    
    
      <category term="Maven Install error" scheme="http://aimasa.github.io/tags/Maven-Install-error/"/>
    
  </entry>
  
  <entry>
    <title>开始学习spring（二）：试图搭建一个相关项目</title>
    <link href="http://aimasa.github.io/2019/04/02/%E5%BC%80%E5%A7%8B%E5%AD%A6%E4%B9%A0spring%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%AF%95%E5%9B%BE%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%9B%B8%E5%85%B3%E9%A1%B9%E7%9B%AE/"/>
    <id>http://aimasa.github.io/2019/04/02/开始学习spring（二）：试图搭建一个相关项目/</id>
    <published>2019-04-02T13:08:01.000Z</published>
    <updated>2019-04-11T06:50:22.030Z</updated>
    
    <content type="html"><![CDATA[<p>看了很多东西，但是概念太多了，脑壳痛，所以先搭一个spring Boot的项目，运行一下，再深入学习一下。在别人推荐下我用的是STS（Spring Tool Suite）去搭建的这个项目。</p><a id="more"></a><h1 id="新建项目"><a href="#新建项目" class="headerlink" title="新建项目"></a>新建项目</h1><center><img src="http://pp48biywe.bkt.clouddn.com/static/images/开始学习spring（二）：试图搭建一个相关项目/new.png"></center><p>在新建-&gt;project里面的弹出框选择Spring Starter Project去新建一个project。</p><center><img src="http://pp48biywe.bkt.clouddn.com/static/images/开始学习spring（二）：试图搭建一个相关项目/then.png"></center><p>然后我箭头指的地方是我做过些许改动的地方，接着点击Next。</p><center><img src="http://pp48biywe.bkt.clouddn.com/static/images/开始学习spring（二）：试图搭建一个相关项目/next.png"></center><p>再在红色框框框住的地方选择自己想要的插件，这样maven会自动在pom.xml里面自动填写相关代码去下载需要的配件的安装包，最后点击Finish，就完成了新建spring Boot的任务。</p><h1 id="添加代码让项目成功运行"><a href="#添加代码让项目成功运行" class="headerlink" title="添加代码让项目成功运行"></a>添加代码让项目成功运行</h1><p>在src/main/java下面新建一个类，命名为xxxcontroller.java，然后在这个类里面写上如下代码：</p><pre><code>@Controllerpublic class exampleControl {    @RequestMapping(&quot;/&quot;)    public String Index(Locale locale, Model model) {        Date date = new Date();        DateFormat dateFormat = DateFormat.getDateTimeInstance(DateFormat.LONG, DateFormat.LONG, locale);        String formatDate = dateFormat.format(date);        model.addAttribute(&quot;serverTime&quot;,formatDate);        return &quot;Index&quot;;    }</code></pre><p>然后再在src/main/resources/templates里面新建一个HTML文件：index.html</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h3&gt;Spring Boot and Spring MVC&lt;/h3&gt;    &lt;P th:text=&quot;&#39;The time on the server is &#39; + ${serverTime}&quot;&gt;&lt;/P&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>接着得记住去原项目根目录下的pom.xml里面添上这样一行:</p><pre><code>    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;    &lt;/dependency&gt;</code></pre><p>Thymeleaf是一个XML/XHTML/HTML5模板引擎，用来渲染页面的。Thymeleaf的主要目标在于提供一种可被浏览器正确显示的、格式良好的模板创建方式，因此也可以用作静态建模。<br>之后就才显示</p><img src="http://pp48biywe.bkt.clouddn.com/static/images/开始学习spring（二）：试图搭建一个相关项目/result.png"><p>不然会显示：</p><img src="http://pp48biywe.bkt.clouddn.com/static/images/开始学习spring（二）：试图搭建一个相关项目/404.png"><p>在正在运行时的状态下，修改代码是不会直接反馈到浏览器上显示的，所以得停止运行，再重启。</p><h1 id="运行后出现page-no-find"><a href="#运行后出现page-no-find" class="headerlink" title="运行后出现page no find"></a>运行后出现page no find</h1><p>默认情况下spring boot只会扫描启动类当前包和以下的包，在如果配置正确，但是还是没有运行出现自己想要的界面的情况下，可能有原因是在Application.class这个类扫描时候没有扫描到你的controller控制类，所以你可以在你的Application.class这个类里面@SpringBootApplication下面加上@componentscan(controller所在的包。)</p><p>@SpringBootApplication<br>@componentscan(basePackages = “com.didispace.*”)</p><h1 id="关于该项目用到的注解"><a href="#关于该项目用到的注解" class="headerlink" title="关于该项目用到的注解"></a>关于该项目用到的注解</h1><h2 id="Controller"><a href="#Controller" class="headerlink" title="@Controller"></a>@Controller</h2><p>根据代码中给出的解释就是，带了这个注释的类就是控制器，允许通过类路径扫描自动检测实现类，通常与@ResponseMapping这类注释结合使用。</p><p>我刚刚谷歌了一下这方面的知识，用@Controller其实大部分是用来返回字符串，或者是字符串匹配的模板名称，即直接渲染视图，和HTML结合使用的，但是这个前提前后端配合度要高。（单用@Controller并且不做别的处理的话，返回的字符串没有对应的HTML页面的话，就会报错，出现Whitelabel Error Page这个页面）</p><h3 id="在-Controller这个注解里面的-AliasFor"><a href="#在-Controller这个注解里面的-AliasFor" class="headerlink" title="在@Controller这个注解里面的@AliasFor"></a>在@Controller这个注解里面的@AliasFor</h3><pre><code>@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.METHOD)@Documentedpublic @interface AliasFor {    /**     * Alias for {@link #attribute}.     * &lt;p&gt;Intended to be used instead of {@link #attribute} when {@link #annotation}     * is not declared &amp;mdash; for example: {@code @AliasFor(&quot;value&quot;)} instead of     * {@code @AliasFor(attribute = &quot;value&quot;)}.     */    @AliasFor(&quot;attribute&quot;)    String value() default &quot;&quot;;    /**     * The name of the attribute that &lt;em&gt;this&lt;/em&gt; attribute is an alias for.     * @see #value     */    @AliasFor(&quot;value&quot;)    String attribute() default &quot;&quot;;}</code></pre><p>就相当于value的用法和attribute的用法是一样的，值也是一样的，在这里来给注解的属性起别名，使它们互为别名，意义相同</p><h3 id="返回字符串对应的html"><a href="#返回字符串对应的html" class="headerlink" title="返回字符串对应的html"></a>返回字符串对应的html</h3><pre><code>@Controllerpublic class exampleControl {    @RequestMapping(&quot;/&quot;)    public String Index(Locale locale, Model model) {        Date date = new Date();        DateFormat dateFormat = DateFormat.getDateTimeInstance(DateFormat.LONG, DateFormat.LONG, locale);        String formatDate = dateFormat.format(date);        model.addAttribute(&quot;serverTime&quot;,formatDate);        return &quot;index&quot;;    } }</code></pre><center><img src="http://pp48biywe.bkt.clouddn.com/static/images/开始学习spring（二）：试图搭建一个相关项目/result.png"></center><h3 id="返回json格式数据"><a href="#返回json格式数据" class="headerlink" title="返回json格式数据"></a>返回json格式数据</h3><p>如果想用@Controller这个注释可以返回json的话，就要在返回json的方法前面加上@ResponseBody，这样就会在浏览器页面输出json的格式。</p><p>user类：</p><pre><code>public class User {    private String name;    public void setName(String name) {        this.name = name;    }    public String getName() {        return this.name;    }}</code></pre><p>controller层：</p><pre><code>@Controllerpublic class exampleControl {    @RequestMapping(&quot;/&quot;)    @ResponseBody    public User userTest() {        User user = new User();        user.setName(&quot;haha&quot;);        return user;    }}</code></pre><center><img src="http://pp48biywe.bkt.clouddn.com/static/images/开始学习spring（二）：试图搭建一个相关项目/result2.png"></center><h2 id="RestController"><a href="#RestController" class="headerlink" title="@RestController"></a>@RestController</h2><p>这个注解和@Controller不一样，是由@Controller和@ResponseBody合在一起的，返回的是一个对象（字符串也可，json格式数据也可等等），其实和@Controller放在类上面，然后在需要返回json格式数据的方法上面加一个@ResponseBody的效果一样，只是一个是整体，一个是局部。（这个可以返回Restful风格—-我也不知道什么风格，但是看到还要配置才能用，所以等以后用到了再来补吧。）</p><h1 id="结果输出"><a href="#结果输出" class="headerlink" title="结果输出"></a>结果输出</h1><center><img src="http://pp48biywe.bkt.clouddn.com/static/images/开始学习spring（二）：试图搭建一个相关项目/result.png"></center><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.jianshu.com/p/b534b394dc7a" target="_blank" rel="noopener">关于@Controller和@RestController</a><br><a href="http://blog.didispace.com/springbootweb/" target="_blank" rel="noopener">关于spring boot的学习</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;看了很多东西，但是概念太多了，脑壳痛，所以先搭一个spring Boot的项目，运行一下，再深入学习一下。在别人推荐下我用的是STS（Spring Tool Suite）去搭建的这个项目。&lt;/p&gt;
    
    </summary>
    
      <category term="spring相关" scheme="http://aimasa.github.io/categories/spring%E7%9B%B8%E5%85%B3/"/>
    
      <category term="搭建项目（初级）" scheme="http://aimasa.github.io/categories/spring%E7%9B%B8%E5%85%B3/%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE%EF%BC%88%E5%88%9D%E7%BA%A7%EF%BC%89/"/>
    
    
      <category term="spring相关" scheme="http://aimasa.github.io/tags/spring%E7%9B%B8%E5%85%B3/"/>
    
  </entry>
  
  <entry>
    <title>开始学习spring（一）：关于一些基础知识点</title>
    <link href="http://aimasa.github.io/2019/04/02/%E5%BC%80%E5%A7%8B%E5%AD%A6%E4%B9%A0spring%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%85%B3%E4%BA%8E%E4%B8%80%E4%BA%9B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>http://aimasa.github.io/2019/04/02/开始学习spring（一）：关于一些基础知识点/</id>
    <published>2019-04-02T06:44:53.000Z</published>
    <updated>2019-04-02T13:09:52.866Z</updated>
    
    <content type="html"><![CDATA[<p>现在正式开始学spring了，在此打卡（4.2）</p><a id="more"></a><h1 id="什么是POJOs"><a href="#什么是POJOs" class="headerlink" title="什么是POJOs"></a>什么是POJOs</h1><p>POJO, or Plain Old Java Object, is a normal Java object class (that is, not a JavaBean, EntityBean etc.) </p><p>POJO（plain Old Java Object）它是一个正规的、简单的java对象，包含了业务逻辑处理和持久化逻辑等，但不是JavaBean、EntityBean等，<strong>不具有任何特殊角色和不继承不实现任何其他java框架的类或接口。</strong></p><p>POJO里面是可以包含业务逻辑处理和持久化逻辑，也可以包含类似与JavaBean属性和对属性访问的set和get方法的。</p><p>代码示例：</p><pre><code>package com.demo.spring;public class DbHello { //简单的Java类，称之为POJO，不继承，不实现接口    private DictionaryDAO dao;    public void setDao(DictionaryDAO dao) {        this.dao = dao;    }}</code></pre><h1 id="什么是javabean"><a href="#什么是javabean" class="headerlink" title="什么是javabean"></a>什么是javabean</h1><p>一种特殊又简单的类，</p><ul><li>这个类必须具有一个公共的(public)无参构造函数；</li><li>所有属性私有化（private）；</li><li>私有化的属性必须通过public类型的方法（getter和setter）暴露给其他程序，并且方法的命名也必须遵循一定的命名规范。 </li><li>这个类应是可序列化的。（比如可以实现Serializable 接口，用于实现bean的持久性）</li></ul><h1 id="EJB是什么"><a href="#EJB是什么" class="headerlink" title="EJB是什么"></a>EJB是什么</h1><p>Enterprise JavaBean又叫企业级JavaBean(听说很老了，以后如果用到的话再回来补。)</p><h1 id="依赖注入（DI）"><a href="#依赖注入（DI）" class="headerlink" title="依赖注入（DI）"></a>依赖注入（DI）</h1><p>就是减少依赖。里面牵涉到了依赖倒置（IoC）（这个和设计模式相关，我会找个时间把设计模式的笔记补上。）</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://blog.csdn.net/tonny_guan/article/details/2250134" target="_blank" rel="noopener">关于POJOs</a><br><a href="https://blog.csdn.net/chenchunlin526/article/details/69939337" target="_blank" rel="noopener">关于javabean</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;现在正式开始学spring了，在此打卡（4.2）&lt;/p&gt;
    
    </summary>
    
      <category term="spring相关" scheme="http://aimasa.github.io/categories/spring%E7%9B%B8%E5%85%B3/"/>
    
      <category term="基础指示点" scheme="http://aimasa.github.io/categories/spring%E7%9B%B8%E5%85%B3/%E5%9F%BA%E7%A1%80%E6%8C%87%E7%A4%BA%E7%82%B9/"/>
    
    
      <category term="spring相关" scheme="http://aimasa.github.io/tags/spring%E7%9B%B8%E5%85%B3/"/>
    
  </entry>
  
  <entry>
    <title>hexo博客上传图片</title>
    <link href="http://aimasa.github.io/2019/03/29/hexo%E5%8D%9A%E5%AE%A2%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87/"/>
    <id>http://aimasa.github.io/2019/03/29/hexo博客上传图片/</id>
    <published>2019-03-29T11:15:36.000Z</published>
    <updated>2019-04-03T03:26:57.110Z</updated>
    
    <content type="html"><![CDATA[<p>因为之前用插件在本地导入图片到博客上这个方法因为别的缘故，不能很稳定的让图片插入进去……<br>这就要从我开始装数学公式的插件说起了，反正我不想再折腾了，听说本地导入图片的方法也会导致项目过大然后会受github项目仓库的限制，所以我干脆卸载了本地导入图片的这个插件，换成了用七牛云去在线导入图片。当然这个过程不太顺畅。特此记录一下。</p><a id="more"></a><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><p>去七牛云注册了一个账号（前不久他们特地打电话过来关怀一下注册了账号就不见人影的我，我还嘚瑟的和他们说我不用你们的产品，真香）</p><p>然后百度教程</p><h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><p>下载插件</p><pre><code>npm install hexo-qiniu-sync --save</code></pre><p>然后去！！！！hexo下面的_config.yml里面加上qiniu的配置！！！！是hexo下面不是next下面</p><pre><code>#plugins:  #- hexo-qiniu-sync（这部分要删掉的，不然会报错）qiniu:  offline: false  sync: true  bucket: bucket_name # 你在七牛上面设置的存储图片的存储空间的名字  access_key: AccessKey # 你在七牛上面账号的密钥管理的key  secret_key: SecretKey # 你在七牛上面账号的密钥管理的key  dirPrefix: static #自动在你七牛的那个存储空间里面新建一个这个文件夹，听说是加个文件夹比较好  urlPrefix: http://7xqb0u.com1.z0.glb.clouddn.com/static    local_dir: xxx # 当你hexo qiniu s时候，这个文件夹的东西会自动上传到你七牛云里头创建的static文件夹里面。  update_exist: true  image:    folder: images    extend:  js:    folder: js  css:    folder: css</code></pre><p>好了，其他详细的说明下面有指路辽==</p><h1 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h1><p>我用的是</p><pre><code>{% qnimg xxx.png %}</code></pre><p>这种语法，其他的我不想看辽，目前也用不到。</p><h1 id="上传图片到七牛云"><a href="#上传图片到七牛云" class="headerlink" title="上传图片到七牛云"></a>上传图片到七牛云</h1><p>先去博客本地生成的存图的文件夹（上面有注解），然后博客文里面对它进行引用。然后上传图片去七牛云本地时候，就用：</p><pre><code>hexo qiniu s</code></pre><p>这个语法即可。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://lwtang.github.io/2018/11/27/qiniu-store-image/" target="_blank" rel="noopener">我觉得很详细的教程</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;因为之前用插件在本地导入图片到博客上这个方法因为别的缘故，不能很稳定的让图片插入进去……&lt;br&gt;这就要从我开始装数学公式的插件说起了，反正我不想再折腾了，听说本地导入图片的方法也会导致项目过大然后会受github项目仓库的限制，所以我干脆卸载了本地导入图片的这个插件，换成了用七牛云去在线导入图片。当然这个过程不太顺畅。特此记录一下。&lt;/p&gt;
    
    </summary>
    
      <category term="hexo更新配置" scheme="http://aimasa.github.io/categories/hexo%E6%9B%B4%E6%96%B0%E9%85%8D%E7%BD%AE/"/>
    
      <category term="hexo插入图片" scheme="http://aimasa.github.io/categories/hexo%E6%9B%B4%E6%96%B0%E9%85%8D%E7%BD%AE/hexo%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87/"/>
    
    
      <category term="hexo" scheme="http://aimasa.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>为Next主题添加统计阅读量的功能以及开评论</title>
    <link href="http://aimasa.github.io/2019/03/29/%E4%B8%BANext%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E7%BB%9F%E8%AE%A1%E9%98%85%E8%AF%BB%E9%87%8F%E7%9A%84%E5%8A%9F%E8%83%BD%E4%BB%A5%E5%8F%8A%E5%BC%80%E8%AF%84%E8%AE%BA/"/>
    <id>http://aimasa.github.io/2019/03/29/为Next主题添加统计阅读量的功能以及开评论/</id>
    <published>2019-03-29T01:09:00.000Z</published>
    <updated>2019-03-29T10:32:51.262Z</updated>
    
    <content type="html"><![CDATA[<h1 id="需要准备工作"><a href="#需要准备工作" class="headerlink" title="需要准备工作"></a>需要准备工作</h1><p>我先在leancloud注册了一个账号，用来统计阅读量和去Next主题里设置开放评论用。</p><a id="more"></a><h1 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h1><h2 id="开放评论"><a href="#开放评论" class="headerlink" title="开放评论"></a>开放评论</h2><p>注册完这个账号，然后创建项目（企业开发的话要钱，所以选择个人开发）。接着去Next主题里面设置</p><pre><code>valine:  enable: true  appid:  # your leancloud application appid你点进你leancloud账号里新建的项目里面，然后点进设置，会看到项目自动生成的appid，然后复制过来  appkey: # your leancloud application appkey它的位置就在appid下面一行  notify: false # mail notifier , https://github.com/xCss/Valine/wiki通知  verify: false # Verification code验证码（评论前要输入的）  placeholder: Just go go # comment box placeholder评论框提示你输入的话语  avatar: mm # gravatar style默认头像  guest_info: nick,mail # custom comment header评论前要输入的信息  pageSize: 10 # pagination size一页默认展示的评论数</code></pre><p>然后就能开评论了，因为我刚开始设置输入错了appid和appkey，出现了402错误（反正会提示你哪错了，就不做解释辽。）</p><h3 id="给评论加上邮件通知"><a href="#给评论加上邮件通知" class="headerlink" title="给评论加上邮件通知"></a>给评论加上邮件通知</h3><p>这个是跟着<a href="https://github.com/zhaojun1998/Valine-Admin" target="_blank" rel="noopener">这个博客</a>的方法来的，虽然之前的博客教我怎么用leancloud自带的邮件通知功能去提醒别人评论已回复，但是说是因为是正在开发的功能，还不太稳定，同时还会被要求开验证码，觉得很不方便，所以我换了个博客跟着用第三方的邮件提醒功能。</p><p>因为过程有些繁琐，我也只是跟着它的方法来的，所以就只在这放个链接好了。这是个开源项目。</p><h2 id="添加统计阅读量功能"><a href="#添加统计阅读量功能" class="headerlink" title="添加统计阅读量功能"></a>添加统计阅读量功能</h2><p>在你新建的项目的存储里面，新建一个叫Counter的class，ACL权限选择无限制，里面的appid和appkey和上面获取的是一样的，在这里就不讲是怎么去获取的了。</p><pre><code># Show number of visitors to each article.# You can visit https://leancloud.cn get AppID and AppKey.leancloud_visitors:  enable: true  app_id: #AppID  app_key: #AppKey</code></pre><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://notes.doublemine.me/2015-10-21-%E4%B8%BANexT%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E6%96%87%E7%AB%A0%E9%98%85%E8%AF%BB%E9%87%8F%E7%BB%9F%E8%AE%A1%E5%8A%9F%E8%83%BD.html#%E9%85%8D%E7%BD%AELeanCloud" target="_blank" rel="noopener">参考博客(添加统计阅读量功能)</a></p><p><a href="https://valine.js.org/notify.html" target="_blank" rel="noopener">参考博客(添加统计阅读量功能)</a></p><p><a href="https://github.com/xCss/Valine/wiki/Valine-%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E9%82%AE%E4%BB%B6%E6%8F%90%E9%86%92%E8%AE%BE%E7%BD%AE" target="_blank" rel="noopener">参考博客(让博客支持评论功能)</a></p><p><a href="https://github.com/zhaojun1998/Valine-Admin/blob/master/高级配置.md#自定义邮件模板" target="_blank" rel="noopener">第三方邮件回复自带定时器</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;需要准备工作&quot;&gt;&lt;a href=&quot;#需要准备工作&quot; class=&quot;headerlink&quot; title=&quot;需要准备工作&quot;&gt;&lt;/a&gt;需要准备工作&lt;/h1&gt;&lt;p&gt;我先在leancloud注册了一个账号，用来统计阅读量和去Next主题里设置开放评论用。&lt;/p&gt;
    
    </summary>
    
      <category term="hexo 更新配置" scheme="http://aimasa.github.io/categories/hexo-%E6%9B%B4%E6%96%B0%E9%85%8D%E7%BD%AE/"/>
    
      <category term="添加统计阅读量以及打开评论" scheme="http://aimasa.github.io/categories/hexo-%E6%9B%B4%E6%96%B0%E9%85%8D%E7%BD%AE/%E6%B7%BB%E5%8A%A0%E7%BB%9F%E8%AE%A1%E9%98%85%E8%AF%BB%E9%87%8F%E4%BB%A5%E5%8F%8A%E6%89%93%E5%BC%80%E8%AF%84%E8%AE%BA/"/>
    
    
      <category term="hexo" scheme="http://aimasa.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>bitSet源码解读</title>
    <link href="http://aimasa.github.io/2019/03/14/bitSet%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    <id>http://aimasa.github.io/2019/03/14/bitSet源码解读/</id>
    <published>2019-03-14T05:49:01.000Z</published>
    <updated>2019-03-28T07:37:24.581Z</updated>
    
    <content type="html"><![CDATA[<p>因为最近在看二维码相关，在github上拉下来的代码里面有用到bitSet库，所以在试着看源码。<br>看了一段时间，发现就算理清了逻辑结构也不明白什么意思，所以就去网上查了一下bitSet是做什么的。</p><p>都说bitSet是用来对大量的数据进行整理，减少内存负担（我是这样理解的），bitSet是用长整型对数据进行存储，比起用二进制用int对数据进行存储的方法相比，确实可以减少许多内存【这里对内存概念不是很清楚，日后补全。</p><a id="more"></a><h1 id="部分源码分析"><a href="#部分源码分析" class="headerlink" title="部分源码分析"></a>部分源码分析</h1><h2 id="定义好的关键词-大概可以这样叫"><a href="#定义好的关键词-大概可以这样叫" class="headerlink" title="定义好的关键词(大概可以这样叫)"></a>定义好的关键词(大概可以这样叫)</h2><pre><code>/* * bitSet被打包为字的数组 * word的大小选择完全取决于它的性能 */private final static int ADDRESS_BITS_PER_WORD = 6;private final static int BITS_PER_WORD = 1 &lt;&lt; ADDRESS_BITS_PER_WORD;private final static int BIT_INDEX_MASK = BITS_PER_WORD - 1;/* Used to shift left or right for a partial word mask */private static final long WORD_MASK = 0xffffffffffffffffL;</code></pre><p>这是该方法中定义的参数，其中ADDRESS_BITS_PER_WORD=6是指在java中long型是占8个字节，64bit（$\,2^{6}\,=\,64byte\,$）所以对应的二进制就是6.</p><pre><code>private long[] words;private transient int wordsInUse = 0;//已使用的范围的下标private transient boolean sizeIsSticky = false;//表示用户是使用默认的words的大小(64bit)还是自定义</code></pre><h2 id="关于wordIndex的定义"><a href="#关于wordIndex的定义" class="headerlink" title="关于wordIndex的定义"></a>关于wordIndex的定义</h2><p>这里是bit下标对应的word下标的计算过程：</p><pre><code>private static int wordIndex(int bitIndex) {    return bitIndex &gt;&gt; ADDRESS_BITS_PER_WORD;}</code></pre><h2 id="bitSet的构造函数-里面有对words这个数组的定义"><a href="#bitSet的构造函数-里面有对words这个数组的定义" class="headerlink" title="bitSet的构造函数(里面有对words这个数组的定义)"></a>bitSet的构造函数(里面有对words这个数组的定义)</h2><p>其中，bitSet的构造函数是：</p><pre><code>public BitSet(int nbits) {    // nbits can&#39;t be negative; size 0 is OK    if (nbits &lt; 0)        throw new NegativeArraySizeException(&quot;nbits &lt; 0: &quot; + nbits);    initWords(nbits);    sizeIsSticky = true;}private void initWords(int nbits) {    words = new long[wordIndex(nbits-1) + 1];}</code></pre><p>这是在初始化时候给bitSet中的long[] words分配大小时候，就会调用这个构造函数，但是如果初始化时候去输入long[] 这个数组的话，相当于直接定义long[] words这个数组。</p><pre><code>private BitSet(long[] words) {    this.words = words;    this.wordsInUse = words.length;//这里wordsInUse表示的是定义的数组的长度，如果没有定义长度的话，那么这个值默认为零。    checkInvariants();}</code></pre><p>然后还有无参构造，这个就是用默认的数组大小64bit</p><pre><code>public BitSet() {    initWords(BITS_PER_WORD);    sizeIsSticky = false;}</code></pre><h2 id="bitSet的clear方法-对words这个数组进行清零"><a href="#bitSet的clear方法-对words这个数组进行清零" class="headerlink" title="bitSet的clear方法(对words这个数组进行清零)"></a>bitSet的clear方法(对words这个数组进行清零)</h2><p>其中wordsInUse在源码中出现频率非常高，这个参数是用来记录word数组中已经使用了的个数。</p><pre><code>public void clear(int bitIndex) {    if (bitIndex &lt; 0)        throw new IndexOutOfBoundsException(&quot;bitIndex &lt; 0: &quot; + bitIndex);    int wordIndex = wordIndex(bitIndex);//计算这个bit下标实际上是第几个word(Long)    if (wordIndex &gt;= wordsInUse) //如果这个下标不在wordsInUse范围内，那么返回，因为没有必要进行别的操作了。        return;    words[wordIndex] &amp;= ~(1L &lt;&lt; bitIndex); //把words[wordIndex]中的值设置为false（就是清零）因为&lt;&lt;这是左移。取反后就全是零了，再进行与运算，就相当于设置该bitIndex这个位为false，也就是将该位清零。    recalculateWordsInUse();    checkInvariants();}</code></pre><h2 id="关于和clear对应的set方法-对words这个数组进行赋值"><a href="#关于和clear对应的set方法-对words这个数组进行赋值" class="headerlink" title="关于和clear对应的set方法(对words这个数组进行赋值)"></a>关于和clear对应的set方法(对words这个数组进行赋值)</h2><p>这是set函数，就是把bitIndex的对应的位置设置为true，然后返回设置了true的地方的下标：</p><pre><code>public void set(int bitIndex) {    if (bitIndex &lt; 0)        throw new IndexOutOfBoundsException(&quot;bitIndex &lt; 0: &quot; + bitIndex);    int wordIndex = wordIndex(bitIndex);    expandTo(wordIndex);//判断是否需要扩容，如果需要，则进行扩容    words[wordIndex] |= (1L &lt;&lt; bitIndex); // 把这个bitIndex位设置为true    checkInvariants();}</code></pre><h2 id="关于clear每次最后都要用到的recalculateWordsInUse-方法"><a href="#关于clear每次最后都要用到的recalculateWordsInUse-方法" class="headerlink" title="关于clear每次最后都要用到的recalculateWordsInUse()方法"></a>关于clear每次最后都要用到的recalculateWordsInUse()方法</h2><p>更新wordsInUse，判断实际存储大小。</p><pre><code>private void recalculateWordsInUse() {    //遍历words这个数组，直到找到一个是true的地方    int i;    for (i = wordsInUse-1; i &gt;= 0; i--)        if (words[i] != 0)            break;    wordsInUse = i+1; // 就是让wordsInUse的大小更改为实际单词存储量}</code></pre><h2 id="clear和set方法中都会出现的checkInvariants-方法"><a href="#clear和set方法中都会出现的checkInvariants-方法" class="headerlink" title="clear和set方法中都会出现的checkInvariants()方法"></a>clear和set方法中都会出现的checkInvariants()方法</h2><p>判断这个word数组是否溢出，是否需要抛出异常。</p><pre><code>private void checkInvariants() {    assert(wordsInUse == 0 || words[wordsInUse - 1] != 0);    assert(wordsInUse &gt;= 0 &amp;&amp; wordsInUse &lt;= words.length);    assert(wordsInUse == words.length || words[wordsInUse] == 0);}</code></pre><h2 id="克隆方法clone"><a href="#克隆方法clone" class="headerlink" title="克隆方法clone()"></a>克隆方法clone()</h2><pre><code>public Object clone() {    if (! sizeIsSticky)        trimToSize();    try {        BitSet result = (BitSet) super.clone();        result.words = words.clone();        result.checkInvariants();        return result;    } catch (CloneNotSupportedException e) {        throw new InternalError(e);    }}</code></pre><p><a href="https://aimasa.github.io/2019/03/11/%E5%AF%B9%E4%BA%8EQR%E7%94%9F%E6%88%90%E7%9A%84%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/">参考深克隆和浅克隆</a></p><h2 id="trimToSize-方法"><a href="#trimToSize-方法" class="headerlink" title="trimToSize()方法"></a>trimToSize()方法</h2><p>当word的长度或者内容是自定义的情况下则调用的<br>    private void trimToSize() {<br>        if (wordsInUse != words.length) {<br>            words = Arrays.copyOf(words, wordsInUse);//把实际用的数据拷贝出来放进words里面<br>            checkInvariants();<br>        }<br>    }</p><h2 id="get-方法"><a href="#get-方法" class="headerlink" title="get()方法"></a>get()方法</h2><pre><code>public boolean get(int bitIndex) {    if (bitIndex &lt; 0)        throw new IndexOutOfBoundsException(&quot;bitIndex &lt; 0: &quot; + bitIndex);    checkInvariants();    int wordIndex = wordIndex(bitIndex);    return (wordIndex &lt; wordsInUse)        &amp;&amp; ((words[wordIndex] &amp; (1L &lt;&lt; bitIndex)) != 0);//判断数据是否是在使用范围内，该bitIndex位是否为0.}</code></pre><p>就是前面的先是判断下标是否在存储完数据使用过的范围内，如果不在就无效。再判断bitIndex对应的数据位是否是零，如果都是的话返回true。</p><h1 id="参考网站"><a href="#参考网站" class="headerlink" title="参考网站"></a>参考网站</h1><p><a href="http://www.voidcn.com/article/p-bqoyhfid-rv.html" target="_blank" rel="noopener">对bitSet内存存储方法进行详细介绍，但其他的写的不太明了</a></p><p><a href="https://www.cnblogs.com/larryzeal/p/7710389.html" target="_blank" rel="noopener">举例说明了bitSet的用法，内容详细</a></p><p><a href="https://www.jianshu.com/p/91d75bf588b8" target="_blank" rel="noopener">对bitSet源码中的重要方法进行解读</a></p><p><a href="https://www.jianshu.com/p/00b38e7ec2f2" target="_blank" rel="noopener">简要介绍了bitSet里面的类</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;因为最近在看二维码相关，在github上拉下来的代码里面有用到bitSet库，所以在试着看源码。&lt;br&gt;看了一段时间，发现就算理清了逻辑结构也不明白什么意思，所以就去网上查了一下bitSet是做什么的。&lt;/p&gt;
&lt;p&gt;都说bitSet是用来对大量的数据进行整理，减少内存负担（我是这样理解的），bitSet是用长整型对数据进行存储，比起用二进制用int对数据进行存储的方法相比，确实可以减少许多内存【这里对内存概念不是很清楚，日后补全。&lt;/p&gt;
    
    </summary>
    
      <category term="java语法" scheme="http://aimasa.github.io/categories/java%E8%AF%AD%E6%B3%95/"/>
    
      <category term="bitSet部分源码解读" scheme="http://aimasa.github.io/categories/java%E8%AF%AD%E6%B3%95/bitSet%E9%83%A8%E5%88%86%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    
    
      <category term="java语法" scheme="http://aimasa.github.io/tags/java%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>java的~、|、&lt;&lt;、&gt;&gt;、&gt;&gt;&gt;、^</title>
    <link href="http://aimasa.github.io/2019/03/14/java%E7%9A%84/"/>
    <id>http://aimasa.github.io/2019/03/14/java的/</id>
    <published>2019-03-14T02:08:58.000Z</published>
    <updated>2019-03-28T09:20:23.695Z</updated>
    
    <content type="html"><![CDATA[<p>在看BitSet的源码的时候，我看到了这样一段代码</p><pre><code>words[wordIndex] &amp;= ~(1L &lt;&lt; bitIndex);</code></pre><p>其中~(1L&lt;&lt;bitIndex)我不太明白这是什么意思，所以谷歌了一下,就顺便查了一下日常容易被我弄错的逻辑运算符的用法。</p><a id="more"></a><p>其中</p><p>~：是按位取反运算符</p><p>如：~(10010010)=01101101</p><p>所以这句的意思是在1L左移bitIndex位后，对words[wordIndex]这个第一个bit的位清零</p><h1 id="容易混淆的逻辑运算符"><a href="#容易混淆的逻辑运算符" class="headerlink" title="容易混淆的逻辑运算符"></a>容易混淆的逻辑运算符</h1><p>顺便解释一下|这个的意思</p><pre><code>|：这个是按位或运算&gt;&gt; 是带符号右移，若左操作数是正数，则高位补“0”，若左操作数是负数，则高位补“1”.&lt;&lt; 左移，不管正负数左移时候，最高位都不用管，只需要在后面补零就可以了，和&lt;&lt;&lt;不带符号左移一样，所以就没有不带符号左移&gt;&gt;&gt; 是无符号右移，无论左操作数是正数还是负数，在高位都补“0”</code></pre><p>计算机都是用补码存储数据的。所以当一个数带符号右移或者左移，就是单纯的对该数进行除乘。</p><p>所以在带符号右移或者左移时候，为了保证数字在这个安全的距离能够得出想要的正确结果（乘除2的标准结果），所以int设置的可活动的位移是32，就是左右移32位时候，就会恢复数字的原本值，long设置的可活动位移是64.</p><p>emmmm感觉我语言讲述的不是很清楚，所以附上例子把。</p><pre><code>public class test {    public static void main(String[] args) {        long a=-5;        System.out.println((a &lt;&lt; 64));          // output: -5      }}</code></pre><p>这是long的情况，接下来我放int的例子：</p><pre><code>public class test {    public static void main(String[] args) {        int a=-5;        System.out.println((a &lt;&lt; 32));          // output: -5      }}</code></pre><p>恩，就是这样，我是这样理解的。</p><h1 id="关于"><a href="#关于" class="headerlink" title="关于^"></a>关于^</h1><p>^这个是异或运算符。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.jianshu.com/p/0236b51b903f" target="_blank" rel="noopener">位移参考</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在看BitSet的源码的时候，我看到了这样一段代码&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;words[wordIndex] &amp;amp;= ~(1L &amp;lt;&amp;lt; bitIndex);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其中~(1L&amp;lt;&amp;lt;bitIndex)我不太明白这是什么意思，所以谷歌了一下,就顺便查了一下日常容易被我弄错的逻辑运算符的用法。&lt;/p&gt;
    
    </summary>
    
      <category term="java语法" scheme="http://aimasa.github.io/categories/java%E8%AF%AD%E6%B3%95/"/>
    
      <category term="java中的&quot;~&quot;" scheme="http://aimasa.github.io/categories/java%E8%AF%AD%E6%B3%95/java%E4%B8%AD%E7%9A%84/"/>
    
    
      <category term="java语法" scheme="http://aimasa.github.io/tags/java%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>eclipse找不到源码</title>
    <link href="http://aimasa.github.io/2019/03/13/eclipse%E6%89%BE%E4%B8%8D%E5%88%B0%E6%BA%90%E7%A0%81/"/>
    <id>http://aimasa.github.io/2019/03/13/eclipse找不到源码/</id>
    <published>2019-03-13T09:13:31.000Z</published>
    <updated>2019-03-29T10:41:43.056Z</updated>
    
    <content type="html"><![CDATA[<p>想看看bitSet的源码，但是点进去却显示Source Not Found</p><a id="more"></a><p>点windows—&gt;preference—&gt;java进入如下界面：</p><center><img src="http://pp48biywe.bkt.clouddn.com/static/images/eclipse找不到源码/java_jre.png"></center><p>然后用鼠标点击jre一下，使旁边的Edit获得焦点，然后点击Edit，进入如下界面：</p><center><img src="http://pp48biywe.bkt.clouddn.com/static/images/eclipse找不到源码/java_Edit.png"></center><p>最后选中jdk中的src.zip,点击确定，应用即可</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;想看看bitSet的源码，但是点进去却显示Source Not Found&lt;/p&gt;
    
    </summary>
    
      <category term="eclipse故障" scheme="http://aimasa.github.io/categories/eclipse%E6%95%85%E9%9A%9C/"/>
    
      <category term="eclipse点进方法找不到源码" scheme="http://aimasa.github.io/categories/eclipse%E6%95%85%E9%9A%9C/eclipse%E7%82%B9%E8%BF%9B%E6%96%B9%E6%B3%95%E6%89%BE%E4%B8%8D%E5%88%B0%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="eclipse故障" scheme="http://aimasa.github.io/tags/eclipse%E6%95%85%E9%9A%9C/"/>
    
  </entry>
  
  <entry>
    <title>对于QR生成的java源码学习(一):关于java语法内容</title>
    <link href="http://aimasa.github.io/2019/03/11/%E5%AF%B9%E4%BA%8EQR%E7%94%9F%E6%88%90%E7%9A%84%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    <id>http://aimasa.github.io/2019/03/11/对于QR生成的源码学习/</id>
    <published>2019-03-11T11:53:20.000Z</published>
    <updated>2019-04-02T10:40:13.459Z</updated>
    
    <content type="html"><![CDATA[<p>java的一些基本语法在这里，然后QR生成的源码结构非常清晰，值得一读，所以在这里会零零散散记录一些关于源码里面的一些语法的笔记。</p><a id="more"></a><h1 id="Object-与-Objects-的区别"><a href="#Object-与-Objects-的区别" class="headerlink" title="Object 与 Objects 的区别"></a>Object 与 Objects 的区别</h1><p>Object 是 Java 中所有类的基类，位于java.lang包。</p><p>Objects 是 Object 的工具类，位于java.util包。它从jdk1.7开始才出现，被final修饰不能被继承，拥有私有的构造函数。它由一些静态的实用方法组成，这些方法是null-save（空指针安全的）或null-tolerant（容忍空指针的），用于计算对象的hashcode、返回对象的字符串表示形式、比较两个对象。</p><pre><code>Objects.requireNonNull(text);</code></pre><p>其中源码是这样写的：</p><pre><code>public static &lt;T&gt; T requireNonNull(T obj)</code></pre><p>T：obj的相关类型</p><p>obj：要检查是否为空的参数</p><p>return：如果obj不为空就返回obj，如果是空就返回NullPointerException（空指针异常）</p><h1 id="关于Matcher"><a href="#关于Matcher" class="headerlink" title="关于Matcher"></a>关于Matcher</h1><p>源码是这样的：<br>    NUMERIC_REGEX.matcher(text).matches()</p><p>先把text创建一个匹配此模式的给定输入的匹配器。返回的值再去与NUMERIC_REGEX这个模式(源码中定义的final字段)进行匹配</p><pre><code>public Matcher matcher(CharSequence input)Pattern.matcher(CharSequence input)</code></pre><p>input：需要被转换为匹配模式的字符串</p><p>return：返回这个Pattern的新匹配器</p><pre><code>public boolean matches()</code></pre><p>return：当且仅当整个区域序列匹配此匹配器的模式时才返回true</p><h1 id="bitSet"><a href="#bitSet" class="headerlink" title="bitSet"></a>bitSet</h1><p>一个long长64bit，所以</p><pre><code>private final static int ADDRESS_BITS_PER_WORD = 6;private static int wordIndex(int bitIndex) {    return bitIndex &gt;&gt; ADDRESS_BITS_PER_WORD;}</code></pre><p>其中是在计算bitIndex个bit对应的是第几个long</p><h1 id="assert"><a href="#assert" class="headerlink" title="assert"></a>assert</h1><p>assert()对括号中的条件进行判定，如果条件为真则往下继续运行，条件为假则打印完错误信息然后程序停止运行。</p><h1 id="native"><a href="#native" class="headerlink" title="native"></a>native</h1><p>native是c++开发时候用的，java开发是不用它的，它是用来调用操作系统的一些函数的，然而操作系统的函数就是由c++写的，是没有办法看到它的源码的，java对它只能进行调用。是因为这些函数的实现体在DLL中，JDK的源代码中并不包含。</p><p>因为native是底层实现的，所以它的速度非常快。</p><h1 id="cloneable接口和Serializable接口"><a href="#cloneable接口和Serializable接口" class="headerlink" title="cloneable接口和Serializable接口"></a>cloneable接口和Serializable接口</h1><p>扩展<br>Java语言提供的Cloneable接口和Serializable接口的代码非常简单，它们都是空接口，这种空接口也称为标识接口，标识接口中没有任何方法的定义，其作用是告诉JRE这些接口的实现类是否具有某个功能，如是否支持克隆、是否支持序列化等。——摘自<a href="https://www.cnblogs.com/Qian123/p/5710533.html" target="_blank" rel="noopener">论java中的浅克隆和深克隆</a></p><h1 id="关于序列化"><a href="#关于序列化" class="headerlink" title="关于序列化"></a>关于序列化</h1><p>序列化简单来说就保存对象在内存中的状态,也可以说是实例化变量。这是Java提供的用来保存 Object state，一种保存对象状态的机制。只有实现了serializable接口的类的对象才能被实例化。——-摘自<a href="https://blog.csdn.net/u010486679/article/details/81562344" target="_blank" rel="noopener">序列化是什么</a></p><p>然后我谷歌了一会，理解的意思是，序列化就是把实例化的对象状态用二进制保存到一个文件之类的地方，用的时候再取出来。当然，这个接口只是一种申明，说在这里我要实现对某个实例对象进行序列化，而不包含去序列化东西的一个方法，序列化需要自己去实现。在<a href="https://aimasa.github.io/2019/03/14/bitSet%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/">bitSet</a>里面就implement了Serializable这个接口。</p><p>或者又如以下的代码：</p><pre><code>import java.io.*;   public class Box implements Serializable{       private int width;       private int height;   public void setWidth(int width){       this.width = width;   }   public void setHeight(int height){       this.height = height;   }   public static void main(String[] args){       Box myBox = new Box();       myBox.setWidth(50);       myBox.setHeight(30);       try{           FileOutputStream fs = new FileOutputStream(&quot;foo.ser&quot;);           ObjectOutputStream os = new ObjectOutputStream(fs);           os.writeObject(myBox);           os.close();       }catch(Exception ex){           ex.printStackTrace();       }   }   }   </code></pre><p>如果去掉implements Serializable的话，那么下面的writeObject会报错。</p><p>6、相关注意事项 </p><blockquote><ul><li>当一个父类实现序列化，子类自动实现序列化，不需要显式实现Serializable接口； </li><li>当一个对象的实例变量引用其他对象，序列化该对象时也把引用对象进行序列化； </li><li>并非所有的对象都可以序列化，,至于为什么不可以，有很多原因了,比如： <ul><li>安全方面的原因，比如一个对象拥有private，public等field，对于一个要传输的对象，比如写到文件，或者进行rmi传输 等等，在序列化进行传输的过程中，这个对象的private等域是不受保护的。 </li><li>资源分配方面的原因，比如socket，thread类，如果可以序列化，进行传输或者保存，也无法对他们进行重新的资源分 配，而且，也是没有必要这样实现。 </li></ul></li></ul></blockquote><h1 id="关于克隆clone-方法"><a href="#关于克隆clone-方法" class="headerlink" title="关于克隆clone()方法"></a>关于克隆clone()方法</h1><pre><code>public QrSegment(Mode md, int numCh, BitBuffer data) {//numCh=想在二维码中展示的字的长度。    mode = Objects.requireNonNull(md);    Objects.requireNonNull(data);    if (numCh &lt; 0)        throw new IllegalArgumentException(&quot;Invalid value&quot;);    numChars = numCh;    this.data = data.clone();  // 做一个完整的副本（final data）}</code></pre><p>这个clone()方法因为data是BitBuffer这个类，所以调用了BitBuffer这个类里面写的的clone()方法</p><pre><code>public BitBuffer clone() {    try {        BitBuffer result = (BitBuffer)super.clone();//创建并返回这个对象的一个副本，“副本”的准确含义可能依赖于对象的类。        result.data = (BitSet)result.data.clone();//对BitBuffer这个对象里面成员变量再做一次克隆（到BitSet类中的clone()这个方法去了）        return result;    } catch (CloneNotSupportedException e) {        throw new AssertionError(e);    }}</code></pre><p>为了进行深度克隆，第一次调用的clone()方法时java的Object这个对象的类的克隆，那个属于浅克隆。<br>这个克隆方法是用来创建并返回这个对象的一个副本，“副本”的准确含义可能依赖于对象的类。</p><pre><code>类Object：protected native Object clone() throws CloneNotSupportedException;</code></pre><p>浅克隆方法中，如果克隆对象的成员变量是值类型，那么就会把值原原本本复制一份出来，但是如果成员变量是值引用类型，那么复制出来的也会是地址信息，而引用类型的成员对象并没有复制。所以会对引用类型的成员对象再去做一次克隆，让这个复制出来的东西是可以独立于那个克隆对象的东西。</p><pre><code>类BitSet：public Object clone() {    if (! sizeIsSticky)        trimToSize();    try {        BitSet result = (BitSet) super.clone();        result.words = words.clone();        result.checkInvariants();        return result;    } catch (CloneNotSupportedException e) {        throw new InternalError(e);    }}</code></pre><p>其中result.data指向的是BitSet这个被实例化过一个类，所以去对BitSet data进行了一次克隆，然后data的里面有words的引用，所以再对这个值做一次clone().</p><h1 id="关于在一段数据后循环添加0xEC和0x11这两个数"><a href="#关于在一段数据后循环添加0xEC和0x11这两个数" class="headerlink" title="关于在一段数据后循环添加0xEC和0x11这两个数"></a>关于在一段数据后循环添加0xEC和0x11这两个数</h1><pre><code>for (int padByte = 0xEC; bb.bitLength() &lt; dataCapacityBits; padByte ^= 0xEC ^ 0x11)    bb.appendBits(padByte, 8);</code></pre><p>其中0xEC和0x11是8bit8bit循环添加在bb里面的<br>通过padByte ^= 0xEC ^ 0x11异或，来控制每次添加的8bit，先0xEC然后0x11这样去填充数据编码部分，直到值填满（为什么不能16bit一起填进去？如果16bit的话就会导致填到最后悔有溢出的情况。）</p><h1 id="关于QrSegment这个类"><a href="#关于QrSegment这个类" class="headerlink" title="关于QrSegment这个类"></a>关于QrSegment这个类</h1><p>QrSegment这个类被定义后包括的函数</p><pre><code>public final Mode mode;/** The length of this segment&#39;s unencoded data. Measured in characters for * numeric/alphanumeric/kanji mode, bytes for byte mode, and 0 for ECI mode. * Always zero or positive. Not the same as the data&#39;s bit length. */public final int numChars;// The data bits of this segment. Not null. Accessed through getData().final BitBuffer data;</code></pre><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.cnblogs.com/quiet-snowy-day/p/6387321.html" target="_blank" rel="noopener">关于Object和Objects的区别</a></p><p><a href="https://www.jianshu.com/p/91d75bf588b8" target="_blank" rel="noopener">关于bitSet的源码解读</a></p><p><a href="https://blog.csdn.net/youjianbo_han_87/article/details/2586375" target="_blank" rel="noopener">关于native的用法</a></p><p><a href="https://lixh1986.iteye.com/blog/1767076" target="_blank" rel="noopener">关于序列化的详细说明</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;java的一些基本语法在这里，然后QR生成的源码结构非常清晰，值得一读，所以在这里会零零散散记录一些关于源码里面的一些语法的笔记。&lt;/p&gt;
    
    </summary>
    
      <category term="对于QR生成的java源码学习" scheme="http://aimasa.github.io/categories/%E5%AF%B9%E4%BA%8EQR%E7%94%9F%E6%88%90%E7%9A%84java%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="java语法" scheme="http://aimasa.github.io/categories/%E5%AF%B9%E4%BA%8EQR%E7%94%9F%E6%88%90%E7%9A%84java%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/java%E8%AF%AD%E6%B3%95/"/>
    
    
      <category term="java语法" scheme="http://aimasa.github.io/tags/java%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>python下划线</title>
    <link href="http://aimasa.github.io/2019/03/07/python%E4%B8%8B%E5%88%92%E7%BA%BF/"/>
    <id>http://aimasa.github.io/2019/03/07/python下划线/</id>
    <published>2019-03-07T03:29:50.000Z</published>
    <updated>2019-03-29T10:57:30.321Z</updated>
    
    <content type="html"><![CDATA[<p>在python中经常会遇到下划线”_”的情况</p><a id="more"></a><h1 id="单下划线”-”"><a href="#单下划线”-”" class="headerlink" title="单下划线”_”"></a>单下划线”_”</h1><p>就是无关紧要的变量，就用”_”表示，因为这个值不需要再次引用。</p><p>也可以表达python REPL中最接近一根表达式的结果。</p><h1 id="单前导下划线”-var”"><a href="#单前导下划线”-var”" class="headerlink" title="单前导下划线”_var”"></a>单前导下划线”_var”</h1><p>这是命名约定，就是前面加一个下划线就是暗示别人说这里是私有类，用通配符导入模块时候这个方法（或者变量）是不会跟着包一起导入进去的，但是常规方法调用这个方法（或者变量时候）是不受单个下划线命名约定的影响的。</p><h1 id="单后导下划线”var-”"><a href="#单后导下划线”var-”" class="headerlink" title="单后导下划线”var_”"></a>单后导下划线”var_”</h1><p>就是让该变量名（或者方法名）来避免和python关键词产生冲突。</p><h1 id="双前导下划线”-var”"><a href="#双前导下划线”-var”" class="headerlink" title="双前导下划线”__var”"></a>双前导下划线”__var”</h1><p>当在类上下文中使用，会触发”名称修饰”，由python解释器强制执行。就是在这个双下划线前面加上”_[包名]”</p><center><img src="http://pp48biywe.bkt.clouddn.com/static/images/python下划线/qiandao.png"></center><h1 id="双前导和双末尾下划线-“var“"><a href="#双前导和双末尾下划线-“var“" class="headerlink" title="双前导和双末尾下划线 “var“"></a>双前导和双末尾下划线 “<strong>var</strong>“</h1><p>表示python语言定义的特殊方法。</p><p>最好避免在自己的程序中使用以双下划线（“dunders”）开头和结尾的名称，以避免与将来Python语言的变化产生冲突。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://zhuanlan.zhihu.com/p/36173202" target="_blank" rel="noopener">参考网页</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在python中经常会遇到下划线”_”的情况&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="http://aimasa.github.io/categories/python/"/>
    
      <category term="下划线" scheme="http://aimasa.github.io/categories/python/%E4%B8%8B%E5%88%92%E7%BA%BF/"/>
    
    
      <category term="python用法" scheme="http://aimasa.github.io/tags/python%E7%94%A8%E6%B3%95/"/>
    
  </entry>
  
</feed>

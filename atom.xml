<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>aimasa的个人博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://aimasa.github.io/"/>
  <updated>2019-10-17T03:13:48.588Z</updated>
  <id>http://aimasa.github.io/</id>
  
  <author>
    <name>ZHY</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>k个一组翻转链表</title>
    <link href="http://aimasa.github.io/2019/10/16/k%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
    <id>http://aimasa.github.io/2019/10/16/k个一组翻转链表/</id>
    <published>2019-10-16T14:11:20.000Z</published>
    <updated>2019-10-17T03:13:48.588Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。</p><p>k 是一个正整数，它的值小于或等于链表的长度。</p><p>如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。</p><p>示例 :</p><p><code>给定这个链表：1-&gt;2-&gt;3-&gt;4-&gt;5</code></p><p><code>当 k = 2 时，应当返回: 2-&gt;1-&gt;4-&gt;3-&gt;5</code></p><p><code>当 k = 3 时，应当返回: 3-&gt;2-&gt;1-&gt;4-&gt;5</code></p><p>说明 :</p><p>你的算法只能使用常数的额外空间。<br>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p><a id="more"></a><h1 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h1><p>写这道题目可以用递归，但对递归不太了解，所以明天打算写一下递归的专题，暂时不在这道题上耗时间了，等递归用的顺手的时候再回来写它。</p><h2 id="学到的点："><a href="#学到的点：" class="headerlink" title="学到的点："></a>学到的点：</h2><p>1、计算时间复杂度，虽然我在一个大循环里面包了两个不同的小循环，但是时间复杂度加在一起，一共是$f(3l-\frac{l}{k})$,并不是我想的会复杂度很高。</p><p>2、要理清楚<code>ListNode</code>的存储结构，不然容易出现指向地址的值产生循环的情况。</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>注：里面<code>pre</code>和<code>corr</code>默认使用<code>0-&gt;xxxxxx</code>如此，虽然画的是直接指向需要转换的链表的头指针，但是他们默认是<code>.next</code>指向。</p><p>我没太看仔细看网上的思路，跟着自己的想法写了这个，用语言不知道要怎么表达，干脆放图好了：</p><center><img src="http://pictures.aimasa.club/static/images/k个一组翻转链表\example.png"></center><p>在上图中，先考虑只改变<code>ListNode</code>链表首的翻转变动。$k = 1$的时候链表不做改动，$k = 2$的时候两两交换，$k = 3$的时候就把$k=2$时候翻转好的链表作为一个整体，再和指向的第三个链表做一次两两交换，$k=4$就可以把$k=3$的已经转换好的链表看做一个整体，再与指向的第四个链表做一次两两交换，以此类推。</p><p>这样就可以发现可以根据$k$数量的做一次循环了，这个循环的复杂度只有$f(k)$，需要的指针如下所示：</p><center><img src="http://pictures.aimasa.club/static/images/k个一组翻转链表\zhizhen.png"></center><p>指针<code>end</code>永远都是跟在<code>second</code>的后面，指向链表尾部，<code>second</code>指向<code>end</code>的前一个的原因就是上面说的将前一部分看做一个整体，和后面指向的数字进行两两交换，<code>first-&gt;second</code>就是那个整体，<code>end</code>是那个后面指向的数字。所以<code>first</code>永远都是指在要交换的链表头（就是比如图上<code>1-&gt;2-&gt;3-&gt;4</code>时候，$k=3$，第一次要对<code>1-&gt;2-&gt;3</code>交换，那<code>first</code>指向链表中存储<code>1</code>的位置，当前面三个交换完之后，对下一组进行交换，那么<code>first</code>就应该指向<code>4</code>，因为它是下一组的链表之首。）</p><p><code>pre.next</code>这个指针我用来存储头节点，到最后可以通过输出它，而输出已经被翻转好的链表。</p><p>但是，因为<code>end</code>指针会一直和<code>first</code>指针进行交换，所以<code>pre.next</code>指针指向的地址只会一直跟着<code>first</code>，而无法将转换好的链表完整输出：</p><center><img src="http://pictures.aimasa.club/static/images/k个一组翻转链表\preerror.png"></center><p>所以我加了一个<code>corr</code>指针去跟踪这个翻转后的完整的链表，让<code>corr</code>指向翻转好的链表地址。</p><center><img src="http://pictures.aimasa.club/static/images/k个一组翻转链表\process.png"></center><p>这样，就得到正确的结果了。</p><p>为了知道有多少段链表需要我去进行翻转，而不用临时判空等操作浪费时间，所以在用循环知道了链表会有多长之后，整除$k$，知道了有多少段链表需要翻转，然后再整合上面的思路。</p><h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><p>emm我觉得递归的话可能效率更高？因为时间都浪费在让<code>occr</code>这个指针去跟踪更新的链表了。</p><h1 id="题目来源"><a href="#题目来源" class="headerlink" title="题目来源"></a>题目来源</h1><p><a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/" target="_blank" rel="noopener">leedcode</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。&lt;/p&gt;
&lt;p&gt;k 是一个正整数，它的值小于或等于链表的长度。&lt;/p&gt;
&lt;p&gt;如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。&lt;/p&gt;
&lt;p&gt;示例 :&lt;/p&gt;
&lt;p&gt;&lt;code&gt;给定这个链表：1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;当 k = 2 时，应当返回: 2-&amp;gt;1-&amp;gt;4-&amp;gt;3-&amp;gt;5&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;当 k = 3 时，应当返回: 3-&amp;gt;2-&amp;gt;1-&amp;gt;4-&amp;gt;5&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;说明 :&lt;/p&gt;
&lt;p&gt;你的算法只能使用常数的额外空间。&lt;br&gt;你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://aimasa.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="k个一组翻转链表" scheme="http://aimasa.github.io/categories/%E7%AE%97%E6%B3%95/k%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
    
    
      <category term="算法" scheme="http://aimasa.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="leedcode算法题" scheme="http://aimasa.github.io/tags/leedcode%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>爬虫心得</title>
    <link href="http://aimasa.github.io/2019/10/15/%E7%88%AC%E8%99%AB%E5%BF%83%E5%BE%97/"/>
    <id>http://aimasa.github.io/2019/10/15/爬虫心得/</id>
    <published>2019-10-15T06:04:43.000Z</published>
    <updated>2019-10-17T00:59:42.781Z</updated>
    
    <content type="html"><![CDATA[<p>因为毕业设计的缘故，网上没有现成的数据库，所以要自己想办法去爬取数据。所以</p><p>毕业设计step1:</p><ol><li>书写爬虫爬取文本</li></ol><p>之前试着写了一个爬漫画的爬虫练手（书写思路另会写一条博客详细说明），那时候是对页面漫画的内容进行爬取，但是这次写的爬虫是对页面<code>html</code>的信息进行爬取。</p><a id="more"></a><p>拟使用的库是<code>requests_html</code>和<code>PyQuery</code>，但是<code>PyQuery</code>这个单独的库好像就能满足我的需求。</p><p>其中</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pyquery <span class="keyword">import</span> PyQuery <span class="keyword">as</span> pq</span><br></pre></td></tr></table></figure><p>从<code>PyQuery</code>导入<code>pyquery</code>的方法模块。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pq(link)</span><br></pre></td></tr></table></figure><p>这句话的意思是获取这个<code>link</code>对应的页面的<code>html</code>文件。但是我这样写的时候却出现了乱码。</p><p>要根据网站的编码方式再去进行解码，所以我直接去获取这个网址对应的<code>html</code>信息是会返回乱码的。所以要把这句话改成：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pq(link,encoding=<span class="string">""</span>)</span><br></pre></td></tr></table></figure><p>现在我们就需要知道网站编码格式是什么了，我们打开<code>link</code>对应的那个网站页面，点击<code>f12</code>看它的页面元素（位置一般在<code>&lt;head&gt;</code>这个标签里面）：</p><p><img src="G:\blog\tmp_myBlog\qiniu_picture\images\爬虫心得\content.png" alt="content"></p><p>由此可知，<code>encoding=&quot;gb2312&quot;</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;因为毕业设计的缘故，网上没有现成的数据库，所以要自己想办法去爬取数据。所以&lt;/p&gt;
&lt;p&gt;毕业设计step1:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;书写爬虫爬取文本&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;之前试着写了一个爬漫画的爬虫练手（书写思路另会写一条博客详细说明），那时候是对页面漫画的内容进行爬取，但是这次写的爬虫是对页面&lt;code&gt;html&lt;/code&gt;的信息进行爬取。&lt;/p&gt;
    
    </summary>
    
      <category term="爬虫" scheme="http://aimasa.github.io/categories/%E7%88%AC%E8%99%AB/"/>
    
      <category term="爬取html信息" scheme="http://aimasa.github.io/categories/%E7%88%AC%E8%99%AB/%E7%88%AC%E5%8F%96html%E4%BF%A1%E6%81%AF/"/>
    
    
      <category term="爬虫" scheme="http://aimasa.github.io/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>两两交换链表中的节点</title>
    <link href="http://aimasa.github.io/2019/10/14/%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/"/>
    <id>http://aimasa.github.io/2019/10/14/两两交换链表中的节点/</id>
    <published>2019-10-14T13:00:45.000Z</published>
    <updated>2019-10-17T03:12:09.665Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。</p><p>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p><center><img src="http://pictures.aimasa.club/static/images/两两交换链表中的节点\buzou.png"></center><p>示例:</p><p>给定 1-&gt;2-&gt;3-&gt;4, 你应该返回 2-&gt;1-&gt;4-&gt;3.</p><a id="more"></a><p>这题的话用之前的思路也是行得通的，就是两两交换的思路可以通过<code>while</code>进行循环，然后两两节点换位置，类似于普通参数换位置，因为它可以分解成一个个重复的小问题，所以这题还能用递归去解决。</p><p>因为我递归总是不太熟，所以在这里特地写了个笔记。</p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>把这个题目的大问题划分成一个个重复的子问题（对链表头进行节点互换），然后再限定条件，找到出口点（节点不能为空，节点的<code>.next</code>不能为空）</p><p>然后根据这个思路把代码表示出来。</p><p>在<a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs" target="_blank" rel="noopener">leedcode</a>网站中，标准题解中对递归解释是这样的：递归写法要观察本级递归的解决过程，形成抽象模型，因为递归本质就是不断重复相同的事情。而不是去思考完整的调用栈，一级又一级，无从下手。如图所示，我们应该关注一级调用小单元的情况，也就是单个f(x)。</p><h2 id="参考网站"><a href="#参考网站" class="headerlink" title="参考网站"></a>参考网站</h2><p><a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs" target="_blank" rel="noopener">力扣</a></p><h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><p><a href="https://github.com/aimasa/exercise_demo/tree/master/src/exercise/demo/swappairs" target="_blank" rel="noopener">代码</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。&lt;/p&gt;
&lt;p&gt;你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;http://pictures.aimasa.club/static/images/两两交换链表中的节点\buzou.png&quot;&gt;&lt;/center&gt;

&lt;p&gt;示例:&lt;/p&gt;
&lt;p&gt;给定 1-&amp;gt;2-&amp;gt;3-&amp;gt;4, 你应该返回 2-&amp;gt;1-&amp;gt;4-&amp;gt;3.&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://aimasa.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="两两交换链表中的节点" scheme="http://aimasa.github.io/categories/%E7%AE%97%E6%B3%95/%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/"/>
    
    
      <category term="算法" scheme="http://aimasa.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="leedcode算法题" scheme="http://aimasa.github.io/tags/leedcode%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Http协议</title>
    <link href="http://aimasa.github.io/2019/09/25/Http%E5%8D%8F%E8%AE%AE/"/>
    <id>http://aimasa.github.io/2019/09/25/Http协议/</id>
    <published>2019-09-25T01:38:23.000Z</published>
    <updated>2019-09-26T09:28:39.674Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Lezhin爬虫使用</title>
    <link href="http://aimasa.github.io/2019/09/08/lezhincomic/"/>
    <id>http://aimasa.github.io/2019/09/08/lezhincomic/</id>
    <published>2019-09-08T10:19:11.000Z</published>
    <updated>2019-09-20T02:45:08.872Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Lezhin爬虫使用方法"><a href="#Lezhin爬虫使用方法" class="headerlink" title="Lezhin爬虫使用方法"></a>Lezhin爬虫使用方法</h1><p>lezhin爬虫配置文件介绍</p><a id="more"></a><h2 id="配置文件模板"><a href="#配置文件模板" class="headerlink" title="配置文件模板"></a>配置文件模板</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#需要爬的漫画信息</span><br><span class="line">[comic_info]</span><br><span class="line">comic_chinese_name = 我的哥哥我的老师</span><br><span class="line">comic_name = mybromyssam</span><br><span class="line">series_id_first = 25</span><br><span class="line">series_id_last = 25</span><br><span class="line">; ---------------------------------</span><br><span class="line">; 需要存放的文件路径以及压缩格式</span><br><span class="line">[folder_info]</span><br><span class="line">zip_type = zip</span><br><span class="line">folder_name_header = H:/</span><br><span class="line"></span><br><span class="line">; ----------------------------------</span><br><span class="line">; 账号登录网站后得到的必要信息</span><br><span class="line">[comic_request_info]</span><br><span class="line">access_token = </span><br><span class="line">comic_id = </span><br><span class="line">lezhin_cookie = </span><br><span class="line"></span><br><span class="line">;------------------------------------</span><br><span class="line">;下载完一话漫画下第二话需要等待时间</span><br><span class="line">[spare_time]</span><br><span class="line">spare_time = 10</span><br></pre></td></tr></table></figure><p>注：配置文件后缀名为 .ini，也可以是.config</p><p><strong>小白使用方法</strong></p><ul><li>该脚本打包成的exe使用环境为 window10（我觉得window系列的系统都能用它，我没试过，因为我的电脑是window10，所以我这里标注的使用环境仅为window10）</li><li>新建配置文件在自己电脑里（文件名格式：xxx.ini 或 xxx.config 。ps：没试过用中文的文件名，你们可以试试。）</li><li>运行之后，输入配置文件地址</li><li>中断运行的话按<code>ctrl+c</code></li></ul><p><strong>开发者使用方法</strong></p><ul><li>下载源码，里面缺失的python包都能通过<code>pip install xxx</code>下载得到。</li><li>新建配置文件在自己电脑里（文件名格式：xxx.ini 或 xxx.config 。ps：没试过用中文的文件名，你们可以试试。）</li><li>入口地址为main.py。当然run.py里面也有入口，emmm我自己写着调试的，可以不用管它。</li><li>运行后会要求输入配置文件地址，按配置文件在自己电脑里存放的位置输入即可。</li></ul><p>只能爬取自己已经购买了的漫画，或者网站确定为免费的漫画。</p><p>打包后的脚本并未开放。</p><h2 id="配置参数详解："><a href="#配置参数详解：" class="headerlink" title="配置参数详解："></a>配置参数详解：</h2><h3 id="comic-name、comic-id"><a href="#comic-name、comic-id" class="headerlink" title="comic_name、comic_id"></a>comic_name、comic_id</h3><p><center><img src="http://pictures.aimasa.club/static/images/GitReadMePicture\LezhinComic\first.png"></center><br>点进去之后就能在浏览器的路径上找到对应漫画的comic_name</p><p><center><img src="http://pictures.aimasa.club/static/images/GitReadMePicture\LezhinComic\getcomicname.png"></center><br>接着往下拉，按下F12点，进想要下载的漫画的第一话（随便哪话都能找到以下信息）</p><p>=========================================================================================================</p><p>重点分割线</p><p>======================================================================================================</p><p>点开<code>NetWork</code>这栏</p><p><center><img src="http://pictures.aimasa.club/static/images/GitReadMePicture\LezhinComic\getLezhincookie.jpg"></center><br>找到红框中的链接内容，点开之后会在旁边弹出一个小框</p><p><center><img src="http://pictures.aimasa.club/static/images/GitReadMePicture\LezhinComic\comic_nameandid.jpg"></center><br>在这个小框中，划拉到<code>header</code>这栏最下面，会看到Query xxxx，里面alias就是配置文件里对应的<code>comic_name</code>，<code>_</code>的值就是配置文件里的<code>comic_id</code>【ps:<code>comic_id</code>是我命名有问题，我也不知道<code>_</code>是代表什么。】</p><h3 id="lezhin-cookie"><a href="#lezhin-cookie" class="headerlink" title="lezhin_cookie"></a>lezhin_cookie</h3><p>在<code>header</code>这栏中间会看到<code>cookie</code>，这个值是<code>lezhin_cookie</code></p><p><center><img src="http://pictures.aimasa.club/static/images/GitReadMePicture\LezhinComic\cookie.jpg"></center></p><p><center><img src="http://pictures.aimasa.club/static/images/GitReadMePicture\LezhinComic\togetaccesstoken.jpg"></center></p><h3 id="access-token"><a href="#access-token" class="headerlink" title="access_token"></a>access_token</h3><p>按<code>F5</code>刷新，切换按钮到红框指定的位置，根据下图的指示，能够找到配置文件中<code>access_token</code>对应的值。</p><p><center><img src="http://pictures.aimasa.club/static/images/GitReadMePicture\LezhinComic\getaccesstoken.jpg"></center><br>【因为如果哪天爬不到文件，有一个原因是cookie失效，或者access_token失效，那时候就需要重复一遍获取cookie和access_token的步骤去更新它们】</p><h3 id="comic-chinese-name、series-id-first、series-id-last、zip-type、folder-name-header、spare-time"><a href="#comic-chinese-name、series-id-first、series-id-last、zip-type、folder-name-header、spare-time" class="headerlink" title="comic_chinese_name、series_id_first、series_id_last、zip_type、folder_name_header、spare_time"></a>comic_chinese_name、series_id_first、series_id_last、zip_type、folder_name_header、spare_time</h3><p>这些参数都是自己可以随便定义的。</p><p><code>comic_chinese_name</code>：自己定义的漫画的中文名</p><p><code>series_id_first、series_id_last</code>：想要下载漫画的集数范围。例：如果想要下载该漫画1-15集，那么<code>series_id_first=1</code>，<code>series_id_last=15</code>  ;如果只想下载15集，那么<code>series_id_first = 15</code>，<code>series_id_last=15</code></p><p><code>zip_type</code>：想压缩成的格式。例：<code>zip_type = zip</code>，文件则被压缩成zip格式</p><p><code>folder_name_header</code>：想要存储的地址前缀。例：想要把<code>我的哥哥我的老师</code>漫画全部存在<code>D:/comic</code>里面，然后<code>folder_name_header = D:/comic</code>，运行此脚本，会在<code>D:/comic</code>里面生成一个<code>我的哥哥我的老师</code>这个总文件夹，里面会有你下载的漫画集数（下载下来的图片是分集装好）。</p><p><code>spare_time</code>：爬完上一话，继续爬下一话时候的间隔时间。因为怕爬取漫画过快，被检测发现是用了脚本在爬，所以加了一个<code>spare_time</code>，可以<code>spare_time=0</code>，但是可能会有被封号的风险哟。<code>spare_time=1</code>，就意思是间隔时间为1s。</p><blockquote><p>eg:    alias : myxxxx  =&gt;  comic_name = myxxxx</p></blockquote><p>接着把自己的配置文件在本地的存放位置在程序开始时填一下，如：配置文件名为：<code>lezhin.config</code>，放在电脑的<code>D:/configfile</code>这个文件夹下面，运行程序，出现<code>配置文件路径：</code>的字样时候，输入<code>D:/配置文件/lezhin.config</code>。好了，回车，开始爬数据了，如果突然闪退，可以看log里面的记录。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这个脚本对我来说现阶段最麻烦的就是cookie和access_token这两个参数需要手动获取。emmm看看能不能改进吧。</p><p>因为是在闲暇时候摸鱼写出来的脚本，可能会有很多不足，欢迎大家给我提issue。</p><h2 id="爬虫代码"><a href="#爬虫代码" class="headerlink" title="爬虫代码"></a>爬虫代码</h2><p><a href="https://github.com/aimasa/LezhinComic" target="_blank" rel="noopener">lezhin爬虫</a></p><h2 id="注：禁止用此爬虫爬下来的漫画进行二次贩卖！！！！！！！！！！请尊重他人版权！！！！！！！！！！！！！！！！此爬虫仅做学习用途！！！！！！！！！！！！！"><a href="#注：禁止用此爬虫爬下来的漫画进行二次贩卖！！！！！！！！！！请尊重他人版权！！！！！！！！！！！！！！！！此爬虫仅做学习用途！！！！！！！！！！！！！" class="headerlink" title="注：禁止用此爬虫爬下来的漫画进行二次贩卖！！！！！！！！！！请尊重他人版权！！！！！！！！！！！！！！！！此爬虫仅做学习用途！！！！！！！！！！！！！"></a>注：禁止用此爬虫爬下来的漫画进行二次贩卖！！！！！！！！！！请尊重他人版权！！！！！！！！！！！！！！！！此爬虫仅做学习用途！！！！！！！！！！！！！</h2><p>注：禁止用此爬虫爬下来的漫画进行二次贩卖！！！！！！！！！！请尊重他人版权！！！！！！！！！！！！！！！！此爬虫仅做学习用途！！！！！！！！！！！！！</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Lezhin爬虫使用方法&quot;&gt;&lt;a href=&quot;#Lezhin爬虫使用方法&quot; class=&quot;headerlink&quot; title=&quot;Lezhin爬虫使用方法&quot;&gt;&lt;/a&gt;Lezhin爬虫使用方法&lt;/h1&gt;&lt;p&gt;lezhin爬虫配置文件介绍&lt;/p&gt;
    
    </summary>
    
      <category term="爬虫" scheme="http://aimasa.github.io/categories/%E7%88%AC%E8%99%AB/"/>
    
      <category term="漫画" scheme="http://aimasa.github.io/categories/%E7%88%AC%E8%99%AB/%E6%BC%AB%E7%94%BB/"/>
    
    
      <category term="爬虫" scheme="http://aimasa.github.io/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>python语法记录</title>
    <link href="http://aimasa.github.io/2019/08/21/python%E8%AF%AD%E6%B3%95%E8%AE%B0%E5%BD%95/"/>
    <id>http://aimasa.github.io/2019/08/21/python语法记录/</id>
    <published>2019-08-21T03:17:19.000Z</published>
    <updated>2019-10-17T00:59:57.428Z</updated>
    
    <content type="html"><![CDATA[<p>这是在学习python时候碰到的一些语法问题，先记下来，方便日后使用</p><a id="more"></a><h2 id="numpy语法记录"><a href="#numpy语法记录" class="headerlink" title="numpy语法记录"></a>numpy语法记录</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">power(vector2 - vector1, <span class="number">2</span>)</span><br></pre></td></tr></table></figure><p><code>power</code>是<code>numpy</code>这个类的一个运算函数，是用来计算次方的，上面那行代码意思是计算$(vector2 - vector1)^{2}$,所以<code>power(x,y)</code>是计算$\,x^{y}\,$这个公式的.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sum(power(vector2 - vector1, <span class="number">2</span>))</span><br></pre></td></tr></table></figure><p><code>sum</code>也是<code>numpy</code>这个类的一个运算函数，但是在上式中vector是一个二维数组（可以这样说，是n行两列的矩阵中取的第一行），<code>num(x,y)</code>运算是$x + y$，所以里面就是<code>power(vector2 - vector1, 2)</code>计算出来的数组里面的第一行第一列和第二行第二列的数值相加。（等有机会试试<code>sum</code>的括号里放多行两列数组）</p><h2 id="pandas语法记录"><a href="#pandas语法记录" class="headerlink" title="pandas语法记录"></a>pandas语法记录</h2><p><code>read_csv()</code>：默认返回值是<code>DataFrame</code></p><p>而加上了<code>chunksize=xxx</code>这个参数之后返回值就变成了：<code>TextFileReader</code></p><p>在试运行文本处理的程序时候需要进行数据预处理，作者说是先在本机几条数据看看效果，所以我通过加参数<code>chunksize</code>把数据分块成小块这样，注意：并不是单纯的分割出来前多少条数据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">test_data = pd.DataFrame(pd.read_csv(<span class="string">'G:/Data using/new_data/new_data/test_set.csv'</span>,chunksize= <span class="number">1000</span>).get_chunk(<span class="number">1</span>))</span><br></pre></td></tr></table></figure><p>这是取分块成功后的第一块（就是前一千条哦）。是从1开始计数的。</p><p><code>G:/Data using/new_data/new_data/test_set.csv</code>这是我存放数据的地址。</p><p>​        </p><p>除掉这种<code>pd.DataFrame().get_chunk(1)</code>的办法还有拼接的办法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">test_data = pd.concat(pd.read_csv(<span class="string">'G:/Data using/new_data/new_data/test_set.csv'</span>,chunksize= <span class="number">1000</span>), ignore_index=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure><h2 id="requests-html"><a href="#requests-html" class="headerlink" title="requests_html"></a>requests_html</h2><h2 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h2><p><a href="https://stackoverflow.com/questions/39386458/how-to-read-data-in-python-dataframe-without-concatenating" target="_blank" rel="noopener">pandas TextFileReader  to DataFrame</a></p><p><a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html" target="_blank" rel="noopener">pandas官方文档</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是在学习python时候碰到的一些语法问题，先记下来，方便日后使用&lt;/p&gt;
    
    </summary>
    
      <category term="python语法" scheme="http://aimasa.github.io/categories/python%E8%AF%AD%E6%B3%95/"/>
    
      <category term="各大库的琐碎语法记录" scheme="http://aimasa.github.io/categories/python%E8%AF%AD%E6%B3%95/%E5%90%84%E5%A4%A7%E5%BA%93%E7%9A%84%E7%90%90%E7%A2%8E%E8%AF%AD%E6%B3%95%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="python语法" scheme="http://aimasa.github.io/tags/python%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>toString()和new String()</title>
    <link href="http://aimasa.github.io/2019/08/19/java%E7%9A%84%E8%BD%AC%E6%8D%A2String/"/>
    <id>http://aimasa.github.io/2019/08/19/java的转换String/</id>
    <published>2019-08-19T02:38:25.000Z</published>
    <updated>2019-09-09T06:34:34.909Z</updated>
    
    <content type="html"><![CDATA[<p>用byte[]转换成String类型的时候，我用了(byte[]).toString()去转换，然后返回的结果居然是xxx@xxxx这个字符串，然后我很懵，点进源码才明白原因。</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getClass().getName() + <span class="string">"@"</span> + Integer.toHexString(hashCode());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是把类的类名加上“@”加上做的hashcode值转换成字符串返回输出，byte[]是个数组，是一个对象，所有的对象都是object的子类，所以数组可以使用object的方法，在object的方法里有toString()这个方法，但在没有被复写的情况下使用它，就会生成<code>getClass().getName() + &quot;@&quot; + Integer.toHexString(hashCode())</code>这个字符串。</p><p>所以我们用new String()的方式去转换byte[]值，将其变成String字符串输出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">byte</span> bytes[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(bytes, <span class="number">0</span>, bytes.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">byte</span> bytes[], <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    checkBounds(bytes, offset, length);</span><br><span class="line">    <span class="keyword">this</span>.value = StringCoding.decode(bytes, offset, length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是这两种方法的输出结果</p><center><img src="http://pictures.aimasa.club/static/images/java的转换String/example.png"></center><h1 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h1><p><a href="https://blog.csdn.net/mrbacker/article/details/81638331" target="_blank" rel="noopener">数组相关概念</a></p><p><a href="https://zhidao.baidu.com/question/267505870.html" target="_blank" rel="noopener">关于object的子类</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;用byte[]转换成String类型的时候，我用了(byte[]).toString()去转换，然后返回的结果居然是xxx@xxxx这个字符串，然后我很懵，点进源码才明白原因。&lt;/p&gt;
    
    </summary>
    
      <category term="java语法" scheme="http://aimasa.github.io/categories/java%E8%AF%AD%E6%B3%95/"/>
    
      <category term="toString()和new String()" scheme="http://aimasa.github.io/categories/java%E8%AF%AD%E6%B3%95/toString-%E5%92%8Cnew-String/"/>
    
    
      <category term="java语法" scheme="http://aimasa.github.io/tags/java%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>电话号码的字母组合</title>
    <link href="http://aimasa.github.io/2019/08/05/%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/"/>
    <id>http://aimasa.github.io/2019/08/05/电话号码的字母组合/</id>
    <published>2019-08-05T03:09:32.000Z</published>
    <updated>2019-10-17T01:00:53.078Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个仅包含数字 <code>2-9</code> 的字符串，返回所有它能表示的字母组合。</p><p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p><center><img src="http://pictures.aimasa.club/static/images/电话号码的字母组合/problem.png"></center><p><a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/" target="_blank" rel="noopener">题目来源</a></p><a id="more"></a><h1 id="解答方法"><a href="#解答方法" class="headerlink" title="解答方法"></a>解答方法</h1><p>这个题目暴力破解的话至少要双重循环，更甚，然后我在这题里面学习了一下怎么用递归。</p><h2 id="关于递归"><a href="#关于递归" class="headerlink" title="关于递归"></a>关于递归</h2><p>递归的话就是把一个庞大的问题细化成一个细小的问题，当然，这个庞大的问题的必须是可以重复的，机械的问题。</p><p>我特地去找了一下递归的说明：</p><ol><li><strong>明确递归终止条件</strong>：就是让递归及时终止，这样递归就不会一直一直执行下去</li><li><strong>给出递归终止时的处理办法</strong>：终止时候需要执行什么，这也是需要写的。</li><li><strong>提取重复的逻辑，缩小问题规模</strong></li></ol><p>里面重要的还是对递归问题进行提取重复逻辑。</p><p>因为我对递归不是很了解，所以我打算在这记一下我跟着官方题解弄懂的怎么缩小大的问题规模</p><h2 id="分析逻辑"><a href="#分析逻辑" class="headerlink" title="分析逻辑"></a>分析逻辑</h2><p><center><img src="http://pictures.aimasa.club/static/images/电话号码的字母组合/tree.png"></center><br>假设输入的数字是“23“，然后”2“分支出去”abc“，三个支，再由”abc“分支，每个支都会连接到3里面的每个分支。</p><p>这就是可以被提取出来的重复逻辑。</p><p>可以从“2”中的分支递归。我们先把重复逻辑提取出来，重复的逻辑就是把数字对应的字母分支开来，然后继续分支下去，如此循环往复。</p><p>所以就用到了for循环，先对分支的顶端进行处理，也就是“2”分出来的“abc”三个分支。</p><p>我们要把结果存储到list列表里面，那么在递归结束后，要把输出的结果add进list中</p><p>流程就变成了这样：</p><p><center><img src="http://pictures.aimasa.club/static/images/电话号码的字母组合/info.png"></center><br>【注：里面有错别字：是==第一个循环==】</p><p>这样就能把这个分支用递归的办法全部遍历一遍了。</p><p>也就是：我从第一层开始就对“2”指向的全部字母进行一个循环，循环中我再对跟在“2”后面的“3”指向的字母再次进行一个循环（也就是循环中进行递归），在循环的过程中，如果“3”后面还跟有其他数字的话，那我继续对“3”后面跟着的数字指向的字母进行循环，但如果“3”是最后一个数字的话，我把“3”指向的字母遍历完就可以返回上一层递归了，直到最后返回到最顶层，返回最终的结果。</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://blog.csdn.net/HD243608836/article/details/79973010" target="_blank" rel="noopener">关于递归的特点以及注意点</a></p><p><a href>代码实现</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个仅包含数字 &lt;code&gt;2-9&lt;/code&gt; 的字符串，返回所有它能表示的字母组合。&lt;/p&gt;
&lt;p&gt;给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;http://pictures.aimasa.club/static/images/电话号码的字母组合/problem.png&quot;&gt;&lt;/center&gt;


&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目来源&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://aimasa.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="电话号码的字母组合" scheme="http://aimasa.github.io/categories/%E7%AE%97%E6%B3%95/%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/"/>
    
    
      <category term="算法" scheme="http://aimasa.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="leedcode算法题" scheme="http://aimasa.github.io/tags/leedcode%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>三数之和</title>
    <link href="http://aimasa.github.io/2019/07/22/%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <id>http://aimasa.github.io/2019/07/22/三数之和/</id>
    <published>2019-07-22T06:14:29.000Z</published>
    <updated>2019-10-17T01:01:11.318Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。</p><p>注意：答案中不可以包含重复的三元组。</p><p>例如, 给定数组 <code>nums = [-1, 0, 1, 2, -1, -4]</code>，</p><p>满足要求的三元组集合为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [-1, 0, 1],</span><br><span class="line">  [-1, -1, 2]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/3sum" target="_blank" rel="noopener">力扣（LeetCode）</a></p><a id="more"></a><p>先排序（<code>java</code>里面有<code>Arrays.sort()</code>这个方法进行排序，不过我自己用的是自己写的二分排序对这个数组进行的排序）</p><p>排完序，就能够更方便的去查找满足条件并且不重复的三元组了。</p><p>我们对三元组进行与两元组查找相似的操作，不过三元组多了一个元素而已。</p><p>所以先介绍两元组的和的查找办法</p><h2 id="两元组相加办法"><a href="#两元组相加办法" class="headerlink" title="两元组相加办法"></a>两元组相加办法</h2><p><center><img src="http://pictures.aimasa.club/static/images/三数之和\first.png"></center><br>因为现在这个数组是经过排序预处理的数组，所以接下来的查找中，left指向的数字和right指向的数字相加，比预计和要大的话，那么left就要向左边移动一位，就是<code>left--</code>；如果比预计和小的话，那么right要往右边移动一位，就是<code>right++</code>。</p><p>因为题目中要求的二元组是不能有重复的元素存在，所以在指针移动的过程中，我们要去对指针指向的数据进行判断，如果<code>right</code>和<code>left</code>指向的下一个元素与自己指向的上一个元素相同的时候，可以直接跳过，无需再次进行计算。（两点确定一条直线）</p><p><a href="https://github.com/aimasa/exercise_demo/tree/master/src/exercise/demo/twosun" target="_blank" rel="noopener">代码示例</a></p><h2 id="三元组相加办法"><a href="#三元组相加办法" class="headerlink" title="三元组相加办法"></a>三元组相加办法</h2><p>三元组比两元组多了一个元素，在两元组查找的基础上，再添加一层循环。</p><p>也就是一个最初的循环，然后在那个循环里面开始两元组的查找办法。有个需要注意的要点就是：三元组里面可能会出现的重复。</p><p>当我们对初始数据进行预处理（排序）后，相同元素会排在一块。所以需要避免相同三元组出现的话，就需要保证每次遍历的元素都是独一无二的，这是建立在二元组基础上的三元组需要注意的地方。</p><p><a href="https://github.com/aimasa/exercise_demo/tree/master/src/exercise/demo/threesum" target="_blank" rel="noopener">代码示例</a></p><h1 id="四元组相加办法"><a href="#四元组相加办法" class="headerlink" title="四元组相加办法"></a>四元组相加办法</h1><p>四元组又比三元组多了一个元素</p><p>所以又在外层加了一层循环语句，为了让复杂度小于o($n^{3}$)，我们对循环进行了一些操作，又叫剪枝。</p><p>剪枝把可能会产生重复四元组的情况去掉了，也把可能在对四元组的其中一个元素做循环，但没有能和这个元素产生结果的情况去掉了。</p><p>emm，也就是假如是[-1,0,1,2,-1,-4]这个数组我想要的目标值是0，但当我最外层循环指向-4时候，第二层循环，加上第三层循环都不可能能够找到-4和哪三个数相加得到0的时候，我就需要在预判断时候，就能够跳出循环，以避免产生更多的不必要的运算。</p><p>所以，剪枝我的办法是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;<span class="keyword">continue</span>;&#125;</span><br><span class="line"><span class="keyword">if</span>(nums[i] + nums[i + <span class="number">1</span>] + nums[i + <span class="number">2</span>] + nums[i + <span class="number">3</span>] &gt; target)       </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(nums[i] + nums[n] + nums[n - <span class="number">1</span>] + nums[n - <span class="number">2</span>] &lt; target) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>预判断最外层指定的元素可不可能是想要的四元组的成员之一。</p><p>或者预判断最外层和次外层指定的两个元素可不可能和另外两个元素产生想要的四元组。</p><p>同时剪枝还需要去重：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;<span class="keyword">continue</span>;&#125;</span><br></pre></td></tr></table></figure><p>判断当前指向的这个元素是不是这个指针上一个地方指向的是同一个元素，如果是，那指向下一个元素。这个去重是三层循环都必须需要的步骤，这样可以安全的去掉可能产生一样的四元组的可能。</p><p><a href="https://github.com/aimasa/exercise_demo/tree/master/src/exercise/demo/foursum" target="_blank" rel="noopener">四元组之和代码示范</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。&lt;/p&gt;
&lt;p&gt;注意：答案中不可以包含重复的三元组。&lt;/p&gt;
&lt;p&gt;例如, 给定数组 &lt;code&gt;nums = [-1, 0, 1, 2, -1, -4]&lt;/code&gt;，&lt;/p&gt;
&lt;p&gt;满足要求的三元组集合为：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [-1, 0, 1],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [-1, -1, 2]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/3sum&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;力扣（LeetCode）&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://aimasa.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="三数之和" scheme="http://aimasa.github.io/categories/%E7%AE%97%E6%B3%95/%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    
    
      <category term="算法" scheme="http://aimasa.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>整数反转</title>
    <link href="http://aimasa.github.io/2019/07/18/%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/"/>
    <id>http://aimasa.github.io/2019/07/18/整数反转/</id>
    <published>2019-07-18T03:29:49.000Z</published>
    <updated>2019-10-17T01:01:24.099Z</updated>
    
    <content type="html"><![CDATA[<p>给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。</p><p>示例 1:</p><pre><code>输入: 123输出: 321</code></pre><p>示例 2:</p><pre><code>输入: -123输出: -321</code></pre><p>示例 3:</p><pre><code>输入: 120输出: 21</code></pre><p>注意:</p><p>假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 <code>[−231,  231 − 1]</code>。请根据这个假设，如果反转后整数溢出那么就返回 0。</p><p><a href="https://leetcode-cn.com/problems/reverse-integer" target="_blank" rel="noopener">力扣（LeetCode）</a></p><a id="more"></a><p>这个我先把整数转成<code>string</code>形式，然后再重新把这个字符串拼接，最后输出的字符串转换成整数即可，不过要先转换成<code>long</code>类型整数，再转换成<code>int</code>类型，不然会溢出的。</p><p>官方给的解答是：</p><p>对该整数循环进行整除10，直到最后结果为零才停止循环，在和该数除以10的余数相加，中途记住判断是否溢出即可。</p><p>因为太简单，直接放代码把。</p><p><a href="https://github.com/aimasa/exercise_demo/blob/master/src/exercise/demo/reversea" target="_blank" rel="noopener">代码</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。&lt;/p&gt;
&lt;p&gt;示例 1:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入: 123
输出: 321
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;示例 2:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入: -123
输出: -321
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;示例 3:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入: 120
输出: 21
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;注意:&lt;/p&gt;
&lt;p&gt;假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 &lt;code&gt;[−231,  231 − 1]&lt;/code&gt;。请根据这个假设，如果反转后整数溢出那么就返回 0。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/reverse-integer&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;力扣（LeetCode）&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://aimasa.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="整数反转" scheme="http://aimasa.github.io/categories/%E7%AE%97%E6%B3%95/%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/"/>
    
    
      <category term="算法" scheme="http://aimasa.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>z字形变换</title>
    <link href="http://aimasa.github.io/2019/07/18/z%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2/"/>
    <id>http://aimasa.github.io/2019/07/18/z字形变换/</id>
    <published>2019-07-18T02:06:03.000Z</published>
    <updated>2019-10-17T01:00:17.851Z</updated>
    
    <content type="html"><![CDATA[<p>将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。</p><p>比如输入字符串为 “LEETCODEISHIRING” 行数为 3 时，排列如下：</p><pre><code>L   C   I   RE T O E S I I GE   D   H   N</code></pre><p>之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：”LCIRETOESIIGEDHN”。</p><p><a href="https://leetcode-cn.com/problems/zigzag-conversion" target="_blank" rel="noopener">力扣（LeetCode）</a></p><a id="more"></a><p>我用暴力破解，z形输出了输入的字符串，结果发现看错了题目……只是要我z形排序。</p><p>然后官方题解特别简洁</p><p>它先是创建了一个列表，这个列表的长度代表了z字形需要被分成的行数（n = 3时候list.length = 3）</p><p>列表里面装的元素类型是stringBuffer，把每行会被输出的内容拼接在一起，如图：</p><p><center><img src="http://pictures.aimasa.club/static/images/z字形变换/example.png"></center><br><code>flag</code>就是一个布尔（Boolean）值，用来判断z字形输出的走向，应该往上走还是往下走。它控制的是list存储里面应该往上存储还是向下存储，换句话来说就是<code>list&lt;StringBuffer&gt;.get(i)</code>中的<code>i</code>是增加还是还是减少。</p><p>最后再把里面的<code>list</code>里面的<code>stringBuffer</code>循环输出进行拼接，最后返回正确的值。</p><p>所以超简单，但是我就是没想到。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p><a href="https://github.com/aimasa/exercise_demo/tree/tablebookexercise/src/exercise/demo/convert" target="_blank" rel="noopener">代码</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。&lt;/p&gt;
&lt;p&gt;比如输入字符串为 “LEETCODEISHIRING” 行数为 3 时，排列如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;L   C   I   R
E T O E S I I G
E   D   H   N
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：”LCIRETOESIIGEDHN”。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/zigzag-conversion&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;力扣（LeetCode）&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://aimasa.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="z字形变换" scheme="http://aimasa.github.io/categories/%E7%AE%97%E6%B3%95/z%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2/"/>
    
    
      <category term="算法" scheme="http://aimasa.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>正则匹配</title>
    <link href="http://aimasa.github.io/2019/07/08/%E6%AD%A3%E5%88%99%E5%8C%B9%E9%85%8D/"/>
    <id>http://aimasa.github.io/2019/07/08/正则匹配/</id>
    <published>2019-07-08T07:38:24.000Z</published>
    <updated>2019-10-17T01:01:44.573Z</updated>
    
    <content type="html"><![CDATA[<p>看代码时候看到正则这块，而且我对它也一直搞不明白，这次干脆写篇博客，让自己对它理解更深一点。</p><a id="more"></a><h1 id="关于对一些正则公式的理解"><a href="#关于对一些正则公式的理解" class="headerlink" title="关于对一些正则公式的理解"></a>关于对一些正则公式的理解</h1><p><code>(?:pattern)</code>:在我参考的博客里面解释的是非获取匹配，也就是只负责匹配，但不会获取匹配结果进行输出，提升了效率</p><p><code>\s</code>：匹配空白字符</p><p><code>\t</code>：制表符</p><p><code>\r</code>：回车符</p><p><code>\n</code>：换行符</p><p><code>[]</code>:括号里面代表或</p><p><code>*</code>:跟在字符后面代表可以有0个或多个这个字符</p><p><code>?</code>：表达前面的表达式可以出线0次或1次</p><p><code>(?&lt;=exp)</code>：匹配最左边的exp表达式能匹配的值。eg:remember (?&lt;=re) 返回的结果就是member</p><h1 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h1><p><a href="https://tool.oschina.net/uploads/apidocs/jquery/regexp.html" target="_blank" rel="noopener">关于正则的公式的解析</a></p><p><a href="https://blog.csdn.net/jusang486/article/details/42122837" target="_blank" rel="noopener">关于正则公式的匹配</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;看代码时候看到正则这块，而且我对它也一直搞不明白，这次干脆写篇博客，让自己对它理解更深一点。&lt;/p&gt;
    
    </summary>
    
      <category term="java语法" scheme="http://aimasa.github.io/categories/java%E8%AF%AD%E6%B3%95/"/>
    
      <category term="正则匹配" scheme="http://aimasa.github.io/categories/java%E8%AF%AD%E6%B3%95/%E6%AD%A3%E5%88%99%E5%8C%B9%E9%85%8D/"/>
    
    
      <category term="java语法" scheme="http://aimasa.github.io/tags/java%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>HMM隐马尔可夫模型</title>
    <link href="http://aimasa.github.io/2019/07/03/HMM%E9%9A%90%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E6%A8%A1%E5%9E%8B/"/>
    <id>http://aimasa.github.io/2019/07/03/HMM隐马尔可夫模型/</id>
    <published>2019-07-03T12:02:29.000Z</published>
    <updated>2019-10-17T00:59:50.001Z</updated>
    
    <content type="html"><![CDATA[<p>emm学长让我看看命名实体识别，解释牵涉到HMM隐马尔可夫模型和条件随机场，我先看看，顺便记笔记，写博客。</p><a id="more"></a><h1 id="关于熵（Entropy）"><a href="#关于熵（Entropy）" class="headerlink" title="关于熵（Entropy）"></a>关于熵（Entropy）</h1><p>熵在这里被用来表征系统的无序程度，熵越大，系统越无序。</p><p>负熵是物质系统有序化，组织化，复杂化状态的一种度量。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.cnblogs.com/skyme/p/4651331.html" target="_blank" rel="noopener">隐马尔可夫模型解释</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;emm学长让我看看命名实体识别，解释牵涉到HMM隐马尔可夫模型和条件随机场，我先看看，顺便记笔记，写博客。&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://aimasa.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="隐马尔可夫模型" scheme="http://aimasa.github.io/categories/%E7%AE%97%E6%B3%95/%E9%9A%90%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E6%A8%A1%E5%9E%8B/"/>
    
    
      <category term="算法" scheme="http://aimasa.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Mockito使用</title>
    <link href="http://aimasa.github.io/2019/06/24/Mockito%E4%BD%BF%E7%94%A8/"/>
    <id>http://aimasa.github.io/2019/06/24/Mockito使用/</id>
    <published>2019-06-24T11:59:21.000Z</published>
    <updated>2019-09-09T06:34:34.908Z</updated>
    
    <content type="html"><![CDATA[<p>关于Mockito的使用，跟着文档边看边试着那些用法。</p><ul><li>来一段从官网搞出来的话</li></ul><blockquote><p>Mockito is a mocking framework that tastes really good. It lets you write beautiful tests with a clean &amp; simple API. Mockito doesn’t give you hangover because the tests are very readable and they produce clean verification errors. </p></blockquote><ul><li>翻译</li></ul><blockquote><p>Mockito是一个体感非常好的mocking框架，它能够让你用简洁干净的API写出漂亮的测试方法……</p></blockquote><p>好了后面的不翻译了，我看了一下，简而言之就是这个测试框架非常好用，特别好用，快来用吧</p><a id="more"></a><h1 id="Mockito使用"><a href="#Mockito使用" class="headerlink" title="Mockito使用"></a>Mockito使用</h1><h2 id="创建mock对象"><a href="#创建mock对象" class="headerlink" title="创建mock对象"></a>创建mock对象</h2><p>刚开始我是<code>mock()</code>一个对象：</p><pre><code>UserPersonService mockedUserPerson = Mockito.mock(UserPersonService.class);</code></pre><p>ps:其中<code>UserPersonService</code>是我想调通的service类。</p><p>然后发现可以用<code>@Mock</code>然后<code>private</code>这个类，然后就很方便的创建了一个Mock对象了：</p><pre><code>@Mockprivate UserPersonService userPersonService;</code></pre><h2 id="验证行为"><a href="#验证行为" class="headerlink" title="验证行为"></a>验证行为</h2><p>这里就是验证方法是否真的被调用，或者调用了多少次。</p><pre><code>List mockedList = mock(List.class);//using mock object 使用mock对象mockedList.add(&quot;one&quot;);mockedList.clear();//verification 验证verify(mockedList).add(&quot;one&quot;);verify(mockedList).clear();</code></pre><p>里面是验证</p><h2 id="做测试桩"><a href="#做测试桩" class="headerlink" title="做测试桩"></a>做测试桩</h2><p>打桩就是对调用的方法给它模拟返回值。然后再后面对这个方法进行调用，输入与之前设定的一样的输入值时候，如果那个方法响应了就会把自己之前模拟的返回值返回出来。这时候我们就能用输出到控制台语句去观摩一下是不是自己预期设定的结果。</p><pre><code>LinkedList mockedList = mock(LinkedList.class); //stubbing // 测试桩 when(mockedList.get(0)).thenReturn(&quot;first&quot;); when(mockedList.get(1)).thenThrow(new RuntimeException());</code></pre><p>这是官网给出来的使用方法，里面当<code>mockedList.get(0)</code>时候返回的是自己设定好的<code>first</code>这个值，然后<code>mockedList.get(1)</code>时候返回的就是自己设定好的抛异常<code>new RuntimeException()</code></p><p>当然，如果自己没有对某个输入参数进行打桩的话，输出就会默认<code>null</code>。</p><p>这个方法也就是看能不能调通这个方法，看是否会响应，会的话就会输出期望值，还能查看这个方法被调用了多少次。</p><h1 id="使用心得"><a href="#使用心得" class="headerlink" title="使用心得"></a>使用心得</h1><p>我试着用<code>@Mock</code>去注解一个类，然后打桩，但是发现打完桩，还是不能返回我打桩时候设定的返回值。</p><p>然后问大佬们，他们给我说用<code>@MockBean</code>，之后就成功了，所以在看<code>@Mock</code>和<code>@MockBean</code>两个注解的区别</p><h2 id="Mock"><a href="#Mock" class="headerlink" title="@Mock"></a>@Mock</h2><p>它们允许模拟类或接口，并记录和验证其上的行为。</p><p>将字段标记为模拟。</p><p>允许速记模拟创建。<br>最小化重复的模拟创建代码。<br>使测试类更具可读性。<br>使验证错误更容易阅读，因为字段名称用于标识模拟。</p><h2 id="MockBean"><a href="#MockBean" class="headerlink" title="@MockBean"></a>@MockBean</h2><p>就是对不需要验证的类加上这个注解，然后它会自动将这个类代入测试的<code>controller</code>中的被<code>@Autowired</code>注解的类。然后返回自己打桩时候设置的值</p><p>Not only will @MockBean provide you with a mock, it will also add that mock as a bean (as the name suggests) within the ApplicationContext, and override any existing beans either by name or by type</p><p>————————<a href="https://gooroo.io/GoorooTHINK/Article/16943/Spring-Boot-14--MockBean-and-SpyBean/24301#.XRQk2egzaM8" target="_blank" rel="noopener">摘自博文</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于Mockito的使用，跟着文档边看边试着那些用法。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;来一段从官网搞出来的话&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;Mockito is a mocking framework that tastes really good. It lets you write beautiful tests with a clean &amp;amp; simple API. Mockito doesn’t give you hangover because the tests are very readable and they produce clean verification errors. &lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;翻译&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;Mockito是一个体感非常好的mocking框架，它能够让你用简洁干净的API写出漂亮的测试方法……&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;好了后面的不翻译了，我看了一下，简而言之就是这个测试框架非常好用，特别好用，快来用吧&lt;/p&gt;
    
    </summary>
    
      <category term="spring相关" scheme="http://aimasa.github.io/categories/spring%E7%9B%B8%E5%85%B3/"/>
    
      <category term="Mockito使用" scheme="http://aimasa.github.io/categories/spring%E7%9B%B8%E5%85%B3/Mockito%E4%BD%BF%E7%94%A8/"/>
    
    
      <category term="spring相关" scheme="http://aimasa.github.io/tags/spring%E7%9B%B8%E5%85%B3/"/>
    
  </entry>
  
  <entry>
    <title>机器学习之线性回归</title>
    <link href="http://aimasa.github.io/2019/06/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/"/>
    <id>http://aimasa.github.io/2019/06/21/机器学习之线性回归/</id>
    <published>2019-06-21T01:34:22.000Z</published>
    <updated>2019-10-17T01:01:05.436Z</updated>
    
    <content type="html"><![CDATA[<p>在机器学习中，我听了吴恩达老师的几节课，一节是来介绍机器学习里面的监督学习，监督学习里面以回归分析和分类为代表，然后吴恩达老师介绍了回归算法，在此做笔记。</p><a id="more"></a><p>会用到的表达符号：</p><ul><li>m：培训的样本的数量（prince in 1000’s有47列:m=47）</li></ul><ul><li>x：输入变量，也称为‘特征’(Size in feet^2)</li></ul><ul><li>y：输出变量，也叫‘目标变量’（prince in 1000’s）</li></ul><ul><li>‘#’ ：训练样本的“个数”缩写</li></ul><ul><li>$\theta_{i}\,=\,$：模型参数</li></ul><h1 id="回归算法"><a href="#回归算法" class="headerlink" title="回归算法"></a>回归算法</h1><p>计算函数最小值：求导 = 0（因为求某数导是求的在当前这个数时候的切线斜率，只有在数值达到峰值时候，切线斜率才会为0）</p><p>回归算法分线性回归和非线性回归，这里先讨论线性回归。</p><h2 id="线性回归"><a href="#线性回归" class="headerlink" title="线性回归"></a>线性回归</h2><p>就是一条直线，有两个未知数（x和y）</p><p>公式：$h<em>{\theta }(x)=\theta </em>{0}x+\theta_{1}$</p><h2 id="拟合"><a href="#拟合" class="headerlink" title="拟合"></a>拟合</h2><p>拟合就是把平面上的点,用一条光滑的曲线连接起来,因为这条曲线有无数种可能,就有了各种拟合方法.</p><p>拟合误差（即总残差）</p><h2 id="绝对值的导数不存在的推导"><a href="#绝对值的导数不存在的推导" class="headerlink" title="绝对值的导数不存在的推导"></a>绝对值的导数不存在的推导</h2><p>函数可导必要条件是：在此点连续(也就是左连续必须和右连续相同)</p><p>这里是别人对绝对值的导数可能不存在而写出的证明：</p><p><center><img src="http://pictures.aimasa.club/static/images/机器学习之线性回归/proof.png"></center></p><h2 id="最小二乘法"><a href="#最小二乘法" class="headerlink" title="最小二乘法"></a>最小二乘法</h2><p><code>最小二乘法</code>是一种数学优化技术，就是可以求到一些未知的数据，并且使这些求得的数据和实际数据间的误差的平方和为最小</p><h2 id="损失函数（loss-function）"><a href="#损失函数（loss-function）" class="headerlink" title="损失函数（loss function）"></a>损失函数（loss function）</h2><p>就是真实值和理论值的偏差。</p><p>因为实际应用中会受到诸多因素的制约</p><h2 id="效用函数"><a href="#效用函数" class="headerlink" title="效用函数"></a>效用函数</h2><p>百度里说：效用函数通常是用来表示消费者在消费中所获得的效用与所消费的商品组合之间数量关系的函数，以衡量消费者从消费既定的商品组合中所获得满足的程度。</p><h2 id="残差平方和"><a href="#残差平方和" class="headerlink" title="残差平方和"></a>残差平方和</h2><p>百度里解释的是：把数据点和它和回归直线上的预估点的差异数据称为残差，然后，所有的残差的平方和被称为残差平方和。它表示随机误差的效应，一组数据的残差平方和越小，它的拟合度也就越好。    </p><h2 id="拟合-1"><a href="#拟合-1" class="headerlink" title="拟合"></a>拟合</h2><p>就是自己通过方程拟出来的曲线和已知的数据相吻合，这个过程叫做拟合</p><h2 id="代价函数"><a href="#代价函数" class="headerlink" title="代价函数"></a>代价函数</h2><p>在单变量线性回归函数（例）：$h<em>{\theta }(x)=\theta </em>{0}x+\theta<em>{1}$中的$\theta</em>{1}$和$\theta_{0}$(就是模型参数)这两个未知数可以有很多种组合，从而得出不同的线性函数，拟合出不同的曲线。</p><p>但是为了能够让拟合出来的曲线和已知数据尽最大程度吻合，挑选$\theta<em>{1}$和$\theta</em>{0}$很重要。</p><p>所以就有了求平均误差的公式：$J(\theta <em>{0} \,,\, \theta </em>{1} \, )=\frac{1}{2m}\sum<em>{i=1}^{m}(h</em>{\theta }(x^{(i)})-y^{(i)}))^{2}$</p><p>这个公式是用来衡量设置出来的$\theta<em>{1}$和$\theta</em>{0}$的值拟合的曲线和真实的数据的吻合度，所以这个公式得出来的结果越小越好。</p><blockquote><p>其中的$\frac{1}{2}$这是在尝试减小平均误差</p></blockquote><p>于是其中：minimize $J(\theta <em>{0} \,,\, \theta </em>{1} \, )$，就是这个线性函数的代价函数</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://baike.baidu.com/item/拟合" target="_blank" rel="noopener">拟合解释</a></p><p><a href="https://math.stackexchange.com/questions/991475/why-is-the-absolute-value-function-not-differentiable-at-x-0/991559" target="_blank" rel="noopener">绝对值的导数不存在的原因</a></p><p>[参考视频为吴恩达老师的机器学习的入门视频]</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在机器学习中，我听了吴恩达老师的几节课，一节是来介绍机器学习里面的监督学习，监督学习里面以回归分析和分类为代表，然后吴恩达老师介绍了回归算法，在此做笔记。&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://aimasa.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="机器学习" scheme="http://aimasa.github.io/categories/%E7%AE%97%E6%B3%95/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="线性回归算法" scheme="http://aimasa.github.io/categories/%E7%AE%97%E6%B3%95/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://aimasa.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="机器学习" scheme="http://aimasa.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>最长回文串</title>
    <link href="http://aimasa.github.io/2019/06/18/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E4%B8%B2/"/>
    <id>http://aimasa.github.io/2019/06/18/最长回文串/</id>
    <published>2019-06-18T12:08:52.000Z</published>
    <updated>2019-10-17T01:01:53.951Z</updated>
    
    <content type="html"><![CDATA[<p>终于弄懂了最长回文串，在做题的时候，总是在暴力破解的思路里出不去，总想着两个for循环，空间复杂度为o($n^{2}$)然后解题思路里面讲了Manacher’s algorithm这个算法，把复杂度降低到了o(n)。</p><a id="more"></a><p>首先看张图（我为了图方便，都先预处理了字符串，不是按官方给的判断回文子串的奇偶方法）</p><center><img src="http://pictures.aimasa.club/static/images/最长回文串/time.png"></center>上面那行是我用暴力破解用的时间，下面那行是用Manacher's algorithm这个算法花的时间，可以很明显的看到emm差距。（想说一点[题外话]：记得老师说以空间换时间和以时间换空间的这句话，所以我们需要在时间和空间中找到一个平衡点以达到我们想要的效率）# 暴力破解这个算法很简单，就是简单粗暴的双循环，接着判断是不是回文串，再判断是不是最长的回文串。我用的是先预处理字符串，在字符串中间加入"#"号，字符串首尾也加上这个eg：abcd  =====> #a#b#c#d#这样就能保证字符串长度一定为奇数了（如果字符串原长3，那么就需要插入4个"#"，那么奇数加偶数一定是奇数了）然后根据循环到的位置，扩散开来判断是否是回文串，是的话同时记录长度和下标，就能够寻找到最长的回文串了。# Manacher's algorithm## 预处理首先预处理字符串，让字符串保证长度为奇数eg：aba  =====> #a#b#a### 主要思路先假设**当前最长回文串**<center><img src="http://pictures.aimasa.club/static/images/最长回文串/table.png"></center><p>里面的p[i]是指当前回文串的半径（其实p[i] - 1就是当前回文串的真实长度）</p><p>所以，p[j]是最后得出最长回文串的关键。</p><p>所以我们需要求出p[j]（ci的位置就是为p[i]服务的）</p><p>先假设ci是<strong>当前</strong>最长回文串的中心点，那么由它开始往外扩展，判断这个最长回文串里面是否有新的回文串，如果有的话，首先判断新的回文串是不是被这个最大回文串包含了。</p><p>从j=0开始往后遍历，同时开始判断当前最长的回文串，然后ci的位置根据最长回文串的最右边界的位置而开始发生改变。</p><p>接着就要开始讨论关于j的位置处于最长回文串的笼罩范围内的情况了：</p><p><center><img src="http://pictures.aimasa.club/static/images/最长回文串/lenth.png"></center><br>这里列举的是j存在的回文串<strong>处于最长回文串笼罩的范围内的情况</strong>。</p><p>在这里我们没有必要去一个个比较去判断在最长回文串内的i的情况，我们可以直接对j对应ci的另一边的j的映射（我们称为i，i = 2* ci - j）i的p[i]的长度，如果p[i]的回文串长度如上图所示的话，那么p[j]=p[i],然后跳出循环，去遍历下一个j</p><p>除了刚刚那种情况，那就还有剩下的一种情况了：j存在的回文串<strong>长于最长回文串笼罩的范围内的情况</strong></p><p><center><img src="http://pictures.aimasa.club/static/images/最长回文串/overLenth.png"></center><br>其中j的回文子串的右边比ci所对应的回文串的最右边长（如图），那么我们就需要判断一下j对应的i的回文字符串有多长，所以首先我们要知道l的长度，因为对应的i的那个部分是回文字符串，所以在没有超出ci的最长回文串的最右边界的部分，j的那段一定是回文字符串，所以我们就需要在基于l长度的回文字符串的基础下，继续往后比较。</p><p><center><img src="http://pictures.aimasa.club/static/images/最长回文串/final.png"></center><br>如果j的回文串的最右边界超出了ci原本对应的最长回文串的边界</p><p><center><img src="http://pictures.aimasa.club/static/images/最长回文串/realFinal.png"></center><br>那么就令ci的值变成j的值。</p><p>当然，在对ci做改变时候，要记住随时记录p[j]的值，并且随时记录p[j]里面的最大值。</p><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>所以最后就根据p[j]的最大值找到对应的字符子串，这个子串就是最大回文串</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/solution/zhong-xin-kuo-san-dong-tai-gui-hua-by-liweiwei1419/" target="_blank" rel="noopener">参考官方资料</a></p><p><a href="https://github.com/aimasa/exercise_demo/tree/master/src/exercise/demo/longestpalindrome" target="_blank" rel="noopener">本文代码</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;终于弄懂了最长回文串，在做题的时候，总是在暴力破解的思路里出不去，总想着两个for循环，空间复杂度为o($n^{2}$)然后解题思路里面讲了Manacher’s algorithm这个算法，把复杂度降低到了o(n)。&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://aimasa.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="最长回文串" scheme="http://aimasa.github.io/categories/%E7%AE%97%E6%B3%95/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E4%B8%B2/"/>
    
    
      <category term="算法" scheme="http://aimasa.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>寻找两个有序数组的中位数</title>
    <link href="http://aimasa.github.io/2019/06/10/%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/"/>
    <id>http://aimasa.github.io/2019/06/10/寻找两个有序数组的中位数/</id>
    <published>2019-06-10T13:58:46.000Z</published>
    <updated>2019-10-17T01:01:18.160Z</updated>
    
    <content type="html"><![CDATA[<p>给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。</p><p>请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。</p><p>你可以假设 nums1 和 nums2 不会同时为空。</p><pre><code>nums1 = [1, 3]nums2 = [2]</code></pre><p>中位数是：2.0</p><a id="more"></a><p>我自己的解法是用的归并排序，先把两个有序数组排好序放到另一个数组中，再用位运算找到中位，求解，然后结果是运行速度极慢。</p><p>就去看了官方的结题思路</p><p>因为官方有直接的答案，我就在这写写我的理解(ps：其中一些公式什么的是直接从官网复制黏贴来的，图片也是直接截的，手打太费事了)【简要概述】：</p><h1 id="结题思路"><a href="#结题思路" class="headerlink" title="结题思路"></a>结题思路</h1><p>把nums1和nums2都分成两个部分，然后nums1左边的部分和nums2左边的部分，nums1右边的部分nums2右边的部分放在一块，最后左边的部分总数要和右边部分的总数一样多,如下图：</p><p><center><img src="http://pictures.aimasa.club/static/images/寻找两个有序数组的中位数/part.png"></center><br>根据这张图里面的左边和右边的部分，我们假设已知$\,i\,$和$\,m\,$还有$\,n\,$的值，然后用公式把$\,j\,$表示出来,其中：</p><ul><li>$len(left_part)=len(right_part)$</li><li>$\max(\text{left_part}) \leq \min(\text{right_part})max(left_part)≤min(right_part)$</li></ul><p>为了保证数据不溢出，所以要保证nums1的长度要小于nums2，这样先对nums1选中i的指向位置后，根据公式算出j的时候就不会发生j指向的nums2数据溢出了。</p><p>这个题目的本质就是，把这两个数组统一分成两部分，前面那个部分都要比后面的部分小，所以，我们必须确保：</p><p>B[j−1]≤A[i] 以及 $\text{A}[i-1] \leq \text{B}[j],A[i−1]≤B[j]$</p><p>然后i和j的算法公式：</p><p>$ i=0∼m, j=\frac{m+n+1}{2}−i$</p><p>所以，得出i和j之后，我们就可以根据nums1[]和nums2[]这两个有序数组的大小去寻找中位数了。</p><p>其中m+n+1是为了保证中位数落在分割线的左边，如果中位数在中位线的右边的话，很容易因为数据溢出而报错。</p><p>因为很多时候，i会等于nums1[].lenth()，或者j会等于nums2[].lenth()，所以我们在循环保证i的指向是我们想要的地方之后（或者刚好溢出后），进入判断环节。</p><p>如果i等于nums1[].lenth()，那么则意味着j的指向的数字是我们所需要的中位数之一（之所以说是之一，是因为这两个数组长度加在一起是奇数，不然i是不会等于nums1[].lenth()），j也是这样。</p><p>如果i等于0的时候，那么意味着j现在指向的就是中位数，而不需要继续去寻找中位数了。j等于0的时候也是如此。（i或者j指向0，这种情况在两个数组长度为奇数或者偶数的情况下都会出现）</p><p>讲的有点零散，所以我决定直接把代码连接放出来！<br><a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/xun-zhao-liang-ge-you-xu-shu-zu-de-zhong-wei-shu-b/" target="_blank" rel="noopener">见官网</a></p><p><a href="https://github.com/aimasa/exercise_demo/tree/master/src/exercise/demo/findmediansortedarrays" target="_blank" rel="noopener">和我github上面的代码实现</a></p><h1 id="题目来源"><a href="#题目来源" class="headerlink" title="题目来源"></a>题目来源</h1><p><a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays" target="_blank" rel="noopener">力扣（LeetCode）</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。&lt;/p&gt;
&lt;p&gt;请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。&lt;/p&gt;
&lt;p&gt;你可以假设 nums1 和 nums2 不会同时为空。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;nums1 = [1, 3]
nums2 = [2]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;中位数是：2.0&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://aimasa.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="寻找两个有序数组的中位数" scheme="http://aimasa.github.io/categories/%E7%AE%97%E6%B3%95/%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/"/>
    
    
      <category term="算法" scheme="http://aimasa.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>SpringCloud学习</title>
    <link href="http://aimasa.github.io/2019/06/05/SpringCloud%E5%AD%A6%E4%B9%A0/"/>
    <id>http://aimasa.github.io/2019/06/05/SpringCloud学习/</id>
    <published>2019-06-05T06:28:23.000Z</published>
    <updated>2019-06-05T08:33:47.760Z</updated>
    
    <content type="html"><![CDATA[<p>之前我写的代码都是单架构模式，就是把多个功能放在同一个应用里面，就像之前写的小程序后台一样</p><p>修改了部分代码，就得整体再重新打包编译，没有修改的部分，甚至不需要使用到这部分代码的功能也因为重新打包编译而全部不能使用……</p><p>所以要通过分布式和集群的方式把单架构模式改造一下</p><a id="more"></a><h1 id="微服务概念"><a href="#微服务概念" class="headerlink" title="微服务概念"></a>微服务概念</h1><p>一个springboot就是一个微服务，而且这个springboot做的事情很单一。在我的理解里面，就是把之前的一个整体的分层架构的springboot分成controller、service、dao这三个部分，</p><h1 id="微服务注册"><a href="#微服务注册" class="headerlink" title="微服务注册"></a>微服务注册</h1><p>虽然把springboot分了三部分，但这三部分应该怎么建立连接，相互之间应该怎么进行联络，所以就要引入一个微服务注册中心的概念了。这个微服务注册中心在 springcloud 里就叫做 eureka server, 通过它把就可以把微服务注册起来，以供将来调用。</p><h1 id="微服务访问"><a href="#微服务访问" class="headerlink" title="微服务访问"></a>微服务访问</h1><p>一个服务通过微服务注册中心定位并访问另外一个微服务。</p><h1 id="分布式概念"><a href="#分布式概念" class="headerlink" title="分布式概念"></a>分布式概念</h1><p>博客里介绍：本来一个spring boot就能完成的任务现在分布在多个spring boot里面做。<br>就是不同的部分的微服务可以由不同的团队去开发，耦合度低。</p><h1 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h1><p>就是同样的功能，但是用的端口不一样，如果8080挂了，我可以用8081这个端口的这个功能的微服务，这叫高可用==。</p><h1 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h1><p><a href="http://how2j.cn/k/springcloud/springcloud-distribution/2037.html" target="_blank" rel="noopener">Spring Cloud入门（对这篇博客做的笔记）</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前我写的代码都是单架构模式，就是把多个功能放在同一个应用里面，就像之前写的小程序后台一样&lt;/p&gt;
&lt;p&gt;修改了部分代码，就得整体再重新打包编译，没有修改的部分，甚至不需要使用到这部分代码的功能也因为重新打包编译而全部不能使用……&lt;/p&gt;
&lt;p&gt;所以要通过分布式和集群的方式把单架构模式改造一下&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Cloud学习（一）" scheme="http://aimasa.github.io/categories/Spring-Cloud%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    
      <category term="微服务的概念" scheme="http://aimasa.github.io/categories/Spring-Cloud%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%A6%82%E5%BF%B5/"/>
    
    
      <category term="Spring Cloud" scheme="http://aimasa.github.io/tags/Spring-Cloud/"/>
    
  </entry>
  
  <entry>
    <title>springBootTest注入失败</title>
    <link href="http://aimasa.github.io/2019/06/05/springBootTest%E6%B3%A8%E5%85%A5%E5%A4%B1%E8%B4%A5/"/>
    <id>http://aimasa.github.io/2019/06/05/springBootTest注入失败/</id>
    <published>2019-06-05T01:26:51.000Z</published>
    <updated>2019-06-05T01:41:11.417Z</updated>
    
    <content type="html"><![CDATA[<p>在用测试测dao层时候，虽然都有用注解:dao层用注解@Repository标记，Test类里面注入用@Autowired标记。</p><p>但是还是显示注入失败。</p><a id="more"></a><p>查了半天方法，最后去了spring boot的运行类里面加上了指定包扫描@ComponentScan(basePackages = {“扫描的包的共有的包名部分”})</p><p>然后刚刚发现，之所以扫不出来是因为我包名的命名错误</p><img src="http://pictures.aimasa.club/static/images/springBootTest注入失败/package.png">]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在用测试测dao层时候，虽然都有用注解:dao层用注解@Repository标记，Test类里面注入用@Autowired标记。&lt;/p&gt;
&lt;p&gt;但是还是显示注入失败。&lt;/p&gt;
    
    </summary>
    
      <category term="spring相关" scheme="http://aimasa.github.io/categories/spring%E7%9B%B8%E5%85%B3/"/>
    
      <category term="Test" scheme="http://aimasa.github.io/categories/spring%E7%9B%B8%E5%85%B3/Test/"/>
    
      <category term="SpringBootTest注入失败" scheme="http://aimasa.github.io/categories/spring%E7%9B%B8%E5%85%B3/Test/SpringBootTest%E6%B3%A8%E5%85%A5%E5%A4%B1%E8%B4%A5/"/>
    
    
      <category term="运行error" scheme="http://aimasa.github.io/tags/%E8%BF%90%E8%A1%8Cerror/"/>
    
  </entry>
  
  <entry>
    <title>态势感知</title>
    <link href="http://aimasa.github.io/2019/05/31/%E6%80%81%E5%8A%BF%E6%84%9F%E7%9F%A5/"/>
    <id>http://aimasa.github.io/2019/05/31/态势感知/</id>
    <published>2019-05-31T09:31:11.000Z</published>
    <updated>2019-09-09T06:34:34.911Z</updated>
    
    <content type="html"><![CDATA[<p>在找研究方向时候，有人推荐我看看态势感知，所以记个笔记</p><p>我对态势感知的理解就是：对网络里来往的流量进行分析，排除噪声，通过各种手段通过分析得出安全情况，然后进行防护。</p><p>网络安全态势感知NSSA（network security situation awareness）<br><a id="more"></a></p><h1 id="态势感知"><a href="#态势感知" class="headerlink" title="态势感知"></a>态势感知</h1><p> 态势是各种状态的综合，是一个整体和全局的概念。它强调的是系统和系统对象之间的关系,下图是态势感知的系统要素内容（我jio的就是单纯的流程，就是从收集到的原始数据，然后进行处理得到的数据，再从这些数据里面用技术去分析，得到相关不同的进行了的活动，再去针对不同的活动进行不同的分析，最后的状态评估，进行预测，不同的活动会对系统中的各个对象产生的作用）</p><center><img src="http://pictures.aimasa.club/static/images/态势感知/struct.png"></center>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在找研究方向时候，有人推荐我看看态势感知，所以记个笔记&lt;/p&gt;
&lt;p&gt;我对态势感知的理解就是：对网络里来往的流量进行分析，排除噪声，通过各种手段通过分析得出安全情况，然后进行防护。&lt;/p&gt;
&lt;p&gt;网络安全态势感知NSSA（network security situation awareness）&lt;br&gt;
    
    </summary>
    
      <category term="态势感知相关" scheme="http://aimasa.github.io/categories/%E6%80%81%E5%8A%BF%E6%84%9F%E7%9F%A5%E7%9B%B8%E5%85%B3/"/>
    
      <category term="态势感知" scheme="http://aimasa.github.io/categories/%E6%80%81%E5%8A%BF%E6%84%9F%E7%9F%A5%E7%9B%B8%E5%85%B3/%E6%80%81%E5%8A%BF%E6%84%9F%E7%9F%A5/"/>
    
    
      <category term="态势感知" scheme="http://aimasa.github.io/tags/%E6%80%81%E5%8A%BF%E6%84%9F%E7%9F%A5/"/>
    
  </entry>
  
</feed>

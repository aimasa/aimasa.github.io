<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>最长回文串</title>
      <link href="/2019/06/18/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E4%B8%B2/"/>
      <url>/2019/06/18/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<p>终于弄懂了最长回文串，在做题的时候，总是在暴力破解的思路里出不去，总想着两个for循环，空间复杂度为o($n^{2}$)然后解题思路里面讲了Manacher’s algorithm这个算法，把复杂度降低到了o(n)。</p><a id="more"></a><p>首先看张图（我为了图方便，都先预处理了字符串，不是按官方给的判断回文子串的奇偶方法）</p><center><img src="http://pictures.aimasa.club/static/images/最长回文串/time.png"></center><p>上面那行是我用暴力破解用的时间，下面那行是用Manacher’s algorithm这个算法花的时间，可以很明显的看到emm差距。</p><p>（想说一点[题外话]：记得老师说以空间换时间和以时间换空间的这句话，所以我们需要在时间和空间中找到一个平衡点以达到我们想要的效率）</p><h1 id="暴力破解"><a href="#暴力破解" class="headerlink" title="暴力破解"></a>暴力破解</h1><p>这个算法很简单，就是简单粗暴的双循环，接着判断是不是回文串，再判断是不是最长的回文串。</p><p>我用的是先预处理字符串，在字符串中间加入”#”号，字符串首尾也加上这个</p><p>eg：abcd  =====&gt; #a#b#c#d#</p><p>这样就能保证字符串长度一定为奇数了（如果字符串原长3，那么就需要插入4个”#”，那么奇数加偶数一定是奇数了）</p><p>然后根据循环到的位置，扩散开来判断是否是回文串，是的话记录长度，就能够寻找到最长的回文串了。</p><h1 id="Manacher’s-algorithm"><a href="#Manacher’s-algorithm" class="headerlink" title="Manacher’s algorithm"></a>Manacher’s algorithm</h1><h2 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h2><p>首先预处理字符串，让字符串保证长度为奇数<br>eg：aba  =====&gt; #a#b#a#</p><h2 id="主要思路"><a href="#主要思路" class="headerlink" title="主要思路"></a>主要思路</h2><p>先假设<strong>当前最长回文串</strong></p><center><img src="http://pictures.aimasa.club/static/images/最长回文串/table.png"></center><p>里面的p[i]是指当前回文串的半径（其实p[i] - 1就是当前回文串的真实长度）</p><p>所以，p[i]是最后得出最长回文串的关键。</p><p>所以我们需要求出p[i]（ci的位置就是为p[i]服务的）</p><p>先假设ci是<strong>当前</strong>最长回文串的中心点，那么由它开始往外扩展，判断这个最长回文串里面是否有新的回文串，如果有的话，首先判断新的回文串是不是被这个最大回文串包含了。</p><p>从i=0开始往后遍历，同时开始判断当前最长的回文串，然后ci的位置根据最长回文串的最右边界的位置而开始发生改变。</p><p>接着就要开始讨论关于i的位置处于最长回文串的笼罩范围内的情况了：</p><center><img src="http://pictures.aimasa.club/static/images/最长回文串/lenth.png"></center><p>这里列举的是i存在的回文串<strong>处于最长回文串笼罩的范围内的情况</strong>。</p><p>在这里我们没有必要去一个个比较去判断在最长回文串内的i的情况，我们可以直接对i对应ci的另一边的i的映射（我们称为j，j = 2* ci - i）j的p[j]的长度，如果p[j]的回文串长度如上图所示的话，那么p[i]=p[j],然后跳出循环，去遍历下一个i</p><p>除了刚刚那种情况，那就还有剩下的一种情况了：i存在的回文串<strong>长于最长回文串笼罩的范围内的情况</strong></p><center><img src="http://pictures.aimasa.club/static/images/最长回文串/overLenth.png"></center><p>其中j的回文子串的右边比ci所对应的回文串的最右边长（如图），那么我们就需要判断一下j对应的i的回文字符串有多长，所以首先我们要知道l的长度，因为对应的j的那个部分是回文字符串，所以在没有超出ci的最长回文串的最右边界的部分，i的那段一定是回文字符串，所以我们就需要在基于l长度的回文字符串的基础下，继续往后比较。</p><center><img src="http://pictures.aimasa.club/static/images/最长回文串/final.png"></center><p>如果i的回文串的最右边界超出了ci原本对应的最长回文串的边界</p><center><img src="http://pictures.aimasa.club/static/images/最长回文串/realFinal.png"></center><p>那么就令ci的值变成i的值。</p><p>当然，在对ci做改变时候，要记住随时记录p[i]的值，并且随时记录p[i]里面的最大值。</p><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>所以最后就根据p[i]的最大值找到对应的字符子串，这个子串就是最大回文串</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/solution/zhong-xin-kuo-san-dong-tai-gui-hua-by-liweiwei1419/" target="_blank" rel="noopener">参考官方资料</a></p><p><a href="https://github.com/aimasa/exercise_demo/tree/master/src/exercise/demo/longestpalindrome" target="_blank" rel="noopener">本文代码</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 最长回文串 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>寻找两个有序数组的中位数</title>
      <link href="/2019/06/10/%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/"/>
      <url>/2019/06/10/%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。</p><p>请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。</p><p>你可以假设 nums1 和 nums2 不会同时为空。</p><pre><code>nums1 = [1, 3]nums2 = [2]</code></pre><p>中位数是：2.0</p><a id="more"></a><p>我自己的解法是用的归并排序，先把两个有序数组排好序放到另一个数组中，再用位运算找到中位，求解，然后结果是运行速度极慢。</p><p>就去看了官方的结题思路</p><p>因为官方有直接的答案，我就在这写写我的理解(ps：其中一些公式什么的是直接从官网复制黏贴来的，图片也是直接截的，手打太费事了)【简要概述】：</p><h1 id="结题思路"><a href="#结题思路" class="headerlink" title="结题思路"></a>结题思路</h1><p>把nums1和nums2都分成两个部分，然后nums1左边的部分和nums2左边的部分，nums1右边的部分nums2右边的部分放在一块，最后左边的部分总数要和右边部分的总数一样多,如下图：</p><center><img src="http://pictures.aimasa.club/static/images/寻找两个有序数组的中位数/part.png"></center><p>根据这张图里面的左边和右边的部分，我们假设已知$\,i\,$和$\,m\,$还有$\,n\,$的值，然后用公式把$\,j\,$表示出来,其中：</p><ul><li>$len(left_part)=len(right_part)$</li><li>$\max(\text{left_part}) \leq \min(\text{right_part})max(left_part)≤min(right_part)$</li></ul><p>为了保证数据不溢出，所以要保证nums1的长度要小于nums2，这样先对nums1选中i的指向位置后，根据公式算出j的时候就不会发生j指向的nums2数据溢出了。</p><p>这个题目的本质就是，把这两个数组统一分成两部分，前面那个部分都要比后面的部分小，所以，我们必须确保：</p><p>B[j−1]≤A[i] 以及 \text{A}[i-1] \leq \text{B}[j]A[i−1]≤B[j]</p><p>然后i和j的算法公式：</p><p>$ i=0∼m, j=\frac{m+n+1}{2}−i$</p><p>所以，得出i和j之后，我们就可以根据nums1[]和nums2[]这两个有序数组的大小去寻找中位数了。</p><p>其中m+n+1是为了保证中位数落在分割线的左边，如果中位数在中位线的右边的话，很容易因为数据溢出而报错。</p><p>因为很多时候，i会等于nums1[].lenth()，或者j会等于nums2[].lenth()，所以我们在循环保证i的指向是我们想要的地方之后（或者刚好溢出后），进入判断环节。</p><p>如果i等于nums1[].lenth()，那么则意味着j的指向的数字是我们所需要的中位数之一（之所以说是之一，是因为这两个数组长度加在一起是奇数，不然i是不会等于nums1[].lenth()），j也是这样。</p><p>如果i等于0的时候，那么意味着j现在指向的就是中位数，而不需要继续去寻找中位数了。j等于0的时候也是如此。（i或者j指向0，这种情况在两个数组长度为奇数或者偶数的情况下都会出现）</p><p>讲的有点零散，所以我决定直接把代码连接放出来！<br><a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/xun-zhao-liang-ge-you-xu-shu-zu-de-zhong-wei-shu-b/" target="_blank" rel="noopener">见官网</a></p><h1 id="题目来源"><a href="#题目来源" class="headerlink" title="题目来源"></a>题目来源</h1><p><a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays" target="_blank" rel="noopener">力扣（LeetCode）</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 寻找两个有序数组的中位数 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud学习</title>
      <link href="/2019/06/05/SpringCloud%E5%AD%A6%E4%B9%A0/"/>
      <url>/2019/06/05/SpringCloud%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>之前我写的代码都是单架构模式，就是把多个功能放在同一个应用里面，就像之前写的小程序后台一样</p><p>修改了部分代码，就得整体再重新打包编译，没有修改的部分，甚至不需要使用到这部分代码的功能也因为重新打包编译而全部不能使用……</p><p>所以要通过分布式和集群的方式把单架构模式改造一下</p><a id="more"></a><h1 id="微服务概念"><a href="#微服务概念" class="headerlink" title="微服务概念"></a>微服务概念</h1><p>一个springboot就是一个微服务，而且这个springboot做的事情很单一。在我的理解里面，就是把之前的一个整体的分层架构的springboot分成controller、service、dao这三个部分，</p><h1 id="微服务注册"><a href="#微服务注册" class="headerlink" title="微服务注册"></a>微服务注册</h1><p>虽然把springboot分了三部分，但这三部分应该怎么建立连接，相互之间应该怎么进行联络，所以就要引入一个微服务注册中心的概念了。这个微服务注册中心在 springcloud 里就叫做 eureka server, 通过它把就可以把微服务注册起来，以供将来调用。</p><h1 id="微服务访问"><a href="#微服务访问" class="headerlink" title="微服务访问"></a>微服务访问</h1><p>一个服务通过微服务注册中心定位并访问另外一个微服务。</p><h1 id="分布式概念"><a href="#分布式概念" class="headerlink" title="分布式概念"></a>分布式概念</h1><p>博客里介绍：本来一个spring boot就能完成的任务现在分布在多个spring boot里面做。<br>就是不同的部分的微服务可以由不同的团队去开发，耦合度低。</p><h1 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h1><p>就是同样的功能，但是用的端口不一样，如果8080挂了，我可以用8081这个端口的这个功能的微服务，这叫高可用==。</p><h1 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h1><p><a href="http://how2j.cn/k/springcloud/springcloud-distribution/2037.html" target="_blank" rel="noopener">Spring Cloud入门（对这篇博客做的笔记）</a></p>]]></content>
      
      
      <categories>
          
          <category> Spring Cloud学习（一） </category>
          
          <category> 微服务的概念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Cloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springBootTest注入失败</title>
      <link href="/2019/06/05/springBootTest%E6%B3%A8%E5%85%A5%E5%A4%B1%E8%B4%A5/"/>
      <url>/2019/06/05/springBootTest%E6%B3%A8%E5%85%A5%E5%A4%B1%E8%B4%A5/</url>
      
        <content type="html"><![CDATA[<p>在用测试测dao层时候，虽然都有用注解:dao层用注解@Repository标记，Test类里面注入用@Autowired标记。</p><p>但是还是显示注入失败。</p><a id="more"></a><p>查了半天方法，最后去了spring boot的运行类里面加上了指定包扫描@ComponentScan(basePackages = {“扫描的包的共有的包名部分”})</p><p>然后刚刚发现，之所以扫不出来是因为我包名的命名错误</p><img src="http://pictures.aimasa.club/static/images/springBootTest注入失败/package.png">]]></content>
      
      
      <categories>
          
          <category> spring相关 </category>
          
          <category> Test </category>
          
          <category> SpringBootTest注入失败 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 运行error </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>态势感知</title>
      <link href="/2019/05/31/%E6%80%81%E5%8A%BF%E6%84%9F%E7%9F%A5/"/>
      <url>/2019/05/31/%E6%80%81%E5%8A%BF%E6%84%9F%E7%9F%A5/</url>
      
        <content type="html"><![CDATA[<p>在找研究方向时候，有人推荐我看看态势感知，所以记个笔记</p><p>我对态势感知的理解就是：对网络里来往的流量进行分析，排除噪声，通过各种手段通过分析得出安全情况，然后进行防护。</p><p>网络安全态势感知NSSA（network security situation awareness）<br><a id="more"></a></p><h1 id="态势感知"><a href="#态势感知" class="headerlink" title="态势感知"></a>态势感知</h1><p> 态势是各种状态的综合，是一个整体和全局的概念。它强调的是系统和系统对象之间的关系,下图是态势感知的系统要素内容（我jio的就是单纯的流程，就是从收集到的原始数据，然后进行处理得到的数据，再从这些数据里面用技术去分析，得到相关不同的进行了的活动，再去针对不同的活动进行不同的分析，最后的状态评估，进行预测，不同的活动会对系统中的各个对象产生的作用）</p><center><img src="http://pictures.aimasa.club/static/images/态势感知/struct.png"></center><h2 id="数据融合"><a href="#数据融合" class="headerlink" title="数据融合"></a>数据融合</h2>]]></content>
      
      
      <categories>
          
          <category> 态势感知相关 </category>
          
          <category> 态势感知 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 态势感知 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件上传到mongdb的方法</title>
      <link href="/2019/05/23/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%88%B0mongdb%E7%9A%84%E6%96%B9%E6%B3%95/"/>
      <url>/2019/05/23/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%88%B0mongdb%E7%9A%84%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>思路：先构造一个请求体，然后获取文件类型，进行比对，如果不是excel类型拒绝，是则存入请求体.</p><p>把文件内容转成输入流，再从输入流中读取转成二进制byteArray类型</p><p>对这个二进制数组做哈希</p>]]></content>
      
      
      <categories>
          
          <category> spring相关 </category>
          
          <category> mongodb存储 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mongodb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一种基于结构划分概率的口令攻击方法</title>
      <link href="/2019/05/10/%E4%B8%80%E7%A7%8D%E5%9F%BA%E4%BA%8E%E7%BB%93%E6%9E%84%E5%88%92%E5%88%86%E6%A6%82%E7%8E%87%E7%9A%84%E5%8F%A3%E4%BB%A4%E6%94%BB%E5%87%BB%E6%96%B9%E6%B3%95/"/>
      <url>/2019/05/10/%E4%B8%80%E7%A7%8D%E5%9F%BA%E4%BA%8E%E7%BB%93%E6%9E%84%E5%88%92%E5%88%86%E6%A6%82%E7%8E%87%E7%9A%84%E5%8F%A3%E4%BB%A4%E6%94%BB%E5%87%BB%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>这是一种基于结构划分概率的口令攻击方法研究，里面牵涉到了上下文无关文法</p><p>它分析了现在存储用户口令的方法，然后优化了对口令的攻击方法，节约了很多时间</p><a id="more"></a><h1 id="论文大体介绍"><a href="#论文大体介绍" class="headerlink" title="论文大体介绍"></a>论文大体介绍</h1><p>现在的系统大部分是保存口令的Hash值，用户登录时候，会通过<strong>单向函数</strong>（单向函数给定输入值进行输出很简单，但是很难从输出值去推算回输入值）对输入的口令进行运算，再把得到的Hash值去和存储的哈希值进行对比，如果相等，那么就登录成功了。</p><p>也有一些系统是采用加盐值（就是给你的密码加一串随机数，然后再进行哈希运算，得出一串哈希值，这样对于去破解密码的人来说，运算量很大，很难被破解）的方法去进一步保证系统的安全性。</p><p>因为攻击难度提高了，所以攻击者换了个角度，开始从人对口令的记忆方面去思考攻击方法，提高攻击效率。</p><p>这篇论文是重在考虑基于口令划分概率的口令攻击方法。它和另一个方法相比提高了百分之二十到百分之三十的命中率</p><p>这个方法也具有学习功能，能够根据攻击结果更新使用的字典，提高攻击效率。</p><h1 id="近来口令分析简介"><a href="#近来口令分析简介" class="headerlink" title="近来口令分析简介"></a>近来口令分析简介</h1><ul><li><p>结合词典，根据刚开始定义的变形规则去改变刚开始的单词，生成口令。</p><ul><li>但是变形规则简单，数量有限，要人工自己编写</li><li>口令搜索空间有限，它依赖于已经有的字典和变形规则，变形规则简单，虽然可以根据攻击者自己想变形规则去形成复杂口令，但效率不高。</li></ul></li><li><p>基于马尔科夫链的时间存储折中攻击</p><ul><li>（没看）</li></ul></li><li><p>基于概率上下文无关文法口令攻击方法</p><ul><li>用概率上下文无关文法去定义口令结构，就分块定义，然后对每个块的密码内容进行概率排序，然后产生半终端结构（就是比如我分块是A、B、C、D三个块，A概率最大的值是1，那么按A概率排的半终端结构就是1BCD）</li><li>各个块进行概率排序，然后各个按概率大小组合在一起，形成的结构再按概率插入队列</li><li>有了更多的变形规则，搜索空间更大了</li><li>据统计，高概率的具体结构长度大部分都小于等于3（就分的块小于等于分出了三个块）</li><li>命中率低（但相对于前面的，已经提高了命中率）</li></ul></li></ul><h1 id="口令结构分析"><a href="#口令结构分析" class="headerlink" title="口令结构分析"></a>口令结构分析</h1><p>详细数据表明，大部分人都会把口令只划分为一个部分（也就是比较单一）当然还有少部分会使用其他结构</p><p>对口令按具体结构进行初次划分时候，不会把口令结构划分的很小。</p><p>根据数据分析，虽然结构长的口令比较难被攻击者猜测出来，但是很少有用户会选择结构长的口令。</p><h1 id="基于结构划分概率的方法"><a href="#基于结构划分概率的方法" class="headerlink" title="基于结构划分概率的方法"></a>基于结构划分概率的方法</h1><p>所以该文决定对高概率的口令组合结构根据用户习惯进行再次划分</p><p>主要步骤：</p><ul><li>预处理</li><li>口令攻击阶段</li></ul><h2 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h2><ul><li>具体结构：就是根据用户设置的口令而划分的结构（没有被处理过的那种）</li><li>抽取子结构：就是从具体结构中划分出来的小结构再分类别归类，从而形成了抽取子结构。eg:A（字母）、D（数字），具体结构是：ADAD =&gt; {AA，DD}（分类别归类），其中抽取子结构为：$\bar{A}\, =\, AA\,$</li><li>再对具体结构根据它对应的抽取子结构进行归类，再计算该结构的使用概率。</li></ul><p>论文中使用了一种概率统计方法：</p><p>$p\, =\frac{NUM_{ss_{i}}} {NUM_{es_{j}}}$ </p><p>其中分母表示的是具有这个抽取子结构的数目，分子是对应的具有此划分子结构数目（就是对具体子结构分类别归类后，不同结构组成同一抽取子结构的结构）</p><p>$\,ss_{i}\,$表示第i个划分子结构,$\,es_{j}\,$表示二对应的第j个抽取子结构.</p><p>由论文总结的数据可以得知：用户口令单一结构的组成占大多数。</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1] 邹静,林东岱,郝春辉.一种基于结构划分概率的口令攻击方法[J].计算机学报,2014,37(05):1206-1215.</p>]]></content>
      
      
      <categories>
          
          <category> 数学导论 </category>
          
          <category> 上下文无关文法 </category>
          
          <category> 论文赏析（只有赏） </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学导论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习爬虫（一）：安装selenium和ChromeDriver</title>
      <link href="/2019/05/10/%E5%AD%A6%E4%B9%A0%E7%88%AC%E8%99%AB%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%AE%89%E8%A3%85selenium%E5%92%8CChromeDriver/"/>
      <url>/2019/05/10/%E5%AD%A6%E4%B9%A0%E7%88%AC%E8%99%AB%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%AE%89%E8%A3%85selenium%E5%92%8CChromeDriver/</url>
      
        <content type="html"><![CDATA[<p>关于爬虫的学习，先从selenium这个库开始学。</p><a id="more"></a><h1 id="关于selenium"><a href="#关于selenium" class="headerlink" title="关于selenium"></a>关于selenium</h1><p>先是</p><pre><code>pip install selenium</code></pre><p>安装完这个，我以为就odk了，然后在pycharm编译器里面跟着网上给的代码敲了一段</p><pre><code>from selenium import webdriverbrowser = webdriver.Chrome()browser.get(&#39;https://www.baidu.com&#39;)</code></pre><p>结果报错了</p><pre><code>This inspection detects names that should resolve but don&#39;t. Due to dynamic dispatch and duck typing, this is possible in a limited but useful number of cases. Top-level and class-level items are supported better than instance items.</code></pre><p>大体意思就是模块不存在，然后我以为是pip install时候出错了，就回去再pip install一遍，结果发现，还是没有用。</p><p>然后上网找解决方案，跟着网上的教程去看了pycharm这个IDE里面设置的python环境的路径：</p><ul><li><strong>File &gt; settings &gt; project:xxxxxxx(你导入pycharm的文件夹)  &gt; project Interpreter</strong></li></ul><p>就发现我pip install下载下来的selenium库地址和之前设置在IDE里面python环境的地址不一样，所以没法找到selenium这个模块。</p><p>然后去对这个IDE里面的python路径进行更改。</p><h2 id="更改"><a href="#更改" class="headerlink" title="更改"></a>更改</h2><center><img src="http://pictures.aimasa.club/static/images/学习爬虫（一）：安装selenium和ChromeDriver/pycharm.png"></center><p>点<strong>show all……</strong></p><p>接着</p><center><img src="http://pictures.aimasa.club/static/images/学习爬虫（一）：安装selenium和ChromeDriver/add.png"></center><p>找到对应python-pip的相关python目录所在地，然后更改IDE依赖环境目录。</p><h2 id="查找目录所在地"><a href="#查找目录所在地" class="headerlink" title="查找目录所在地"></a>查找目录所在地</h2><p>我是再次pip install selenium，然后看到了selenium存的位置，再根据这个位置找到相关信息。</p><h1 id="ChromeDriver"><a href="#ChromeDriver" class="headerlink" title="ChromeDriver"></a>ChromeDriver</h1><p>我弄好了，发现不再显示该模块不存在的信息了之后，运行了一遍，发现还是报错了。</p><pre><code>Service chromedriver unexpectedly exited</code></pre><p>出现了这个报错信息。</p><h2 id="装插件"><a href="#装插件" class="headerlink" title="装插件"></a>装插件</h2><p>所以我去安装chromedriver驱动<a href="http://npm.taobao.org/mirrors/chromedriver/" target="_blank" rel="noopener">下载地址</a></p><p>下载好了之后，解压，再新建一个文件夹，里面只放解压出来的exe文件，再去控制面板里面配置环境path</p><p>然后再运行，成功调出了Chrome浏览器，并且让它自动进入百度搜索页面。</p><h1 id="browser-get"><a href="#browser-get" class="headerlink" title="browser.get()"></a>browser.get()</h1><p>browser.get()括号里面的字符串必须填写完整的网址，不然会显示无效网址的错误提示。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://blog.csdn.net/qq_41188944/article/details/79039690" target="_blank" rel="noopener">参考资料</a></p>]]></content>
      
      
      <categories>
          
          <category> 爬虫、python </category>
          
          <category> 安装selenium和ChromeDriver </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git出错（一）</title>
      <link href="/2019/05/09/git%E5%87%BA%E9%94%99%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2019/05/09/git%E5%87%BA%E9%94%99%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>报错：src refspec master does not match any</p><a id="more"></a><h1 id="操作过程"><a href="#操作过程" class="headerlink" title="操作过程"></a>操作过程</h1><pre><code>git initgit commit -m &quot;first commit&quot;git remote add origin git@github.com:aimasa/xxxxxxxxgit push -u origin master</code></pre><p>然后再回车的时候，git bash就报错了</p><pre><code>src refspec master does not match any</code></pre><h1 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h1><p>我没有提交任何内容，我的本地库（.git）是空的，所以第一次push是提交一个空项目，里面没有任何东西，所以报错了</p><h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p>把代码提交到本地，然后再推送一次</p><pre><code>git add .git commit -m &quot;xxxx&quot;git push -u origin master</code></pre><p>推送成功</p>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
          <category> git出错 </category>
          
          <category> src refspec master does not match any. </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git出错 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>背包问题</title>
      <link href="/2019/05/09/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
      <url>/2019/05/09/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>背包问题（Knapsack problem）典型的KP问题描述是：从n个具有价值与重量的物品中选择若干个装入一个具有载重限制的背包,如何选择物品使得装入物品的重量之和在不超过背包载重前提下价值之和达到最大。</p><a id="more"></a><p>有空再看把，暂时搁着，笔记等看完了再来记</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> KP(背包问题) </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>七牛云把测试域名替换成已备份域名</title>
      <link href="/2019/05/08/%E4%B8%83%E7%89%9B%E4%BA%91%E6%8A%8A%E6%B5%8B%E8%AF%95%E5%9F%9F%E5%90%8D%E6%9B%BF%E6%8D%A2%E6%88%90%E5%B7%B2%E5%A4%87%E4%BB%BD%E5%9F%9F%E5%90%8D/"/>
      <url>/2019/05/08/%E4%B8%83%E7%89%9B%E4%BA%91%E6%8A%8A%E6%B5%8B%E8%AF%95%E5%9F%9F%E5%90%8D%E6%9B%BF%E6%8D%A2%E6%88%90%E5%B7%B2%E5%A4%87%E4%BB%BD%E5%9F%9F%E5%90%8D/</url>
      
        <content type="html"><![CDATA[<p>之前把图片放在七牛云的图床上，结果因为我的测试域名到期了，一定要绑定一个域名，才能继续用。接着我去阿里云买了个服务器，绑定了一个域名，并且去做了备案【千万考虑清楚，因为我买的是学生机，所以比较便宜。然后开始在思考我为什么那么冲动，买了服务器不知道干啥用，好浪费,所以打算开始学爬虫……】</p><a id="more"></a><h1 id="step"><a href="#step" class="headerlink" title="step"></a>step</h1><p>进入控制台去对域名进行绑定</p><center><img src="http://pictures.aimasa.club/static/images/七牛云把测试域名替换成已备份域名/one.png"></center><p>进入了控制台，然后点击绑定域名。</p><center><img src="http://pictures.aimasa.club/static/images/七牛云把测试域名替换成已备份域名/two.png"></center><p>输入已经备案好了的域名，选择http协议，如果选择https的话就要花钱（购买证书把大概）</p><center><img src="http://pictures.aimasa.club/static/images/七牛云把测试域名替换成已备份域名/three.png"></center><p><strong>提示</strong>：里面已备份域名填你的二级域名就好了。</p><p>然后其他的我都是默认设置，最后点创建。</p><p>创建完了之后，点进融合SDN去找管理域名</p><center><img src="http://pictures.aimasa.club/static/images/七牛云把测试域名替换成已备份域名/four.png"></center><p>然后把鼠标移到我标红的这块会有“复制CNAME”，点击。</p><center><img src="http://pictures.aimasa.club/static/images/七牛云把测试域名替换成已备份域名/five.png"></center><p>接着就去购买的服务器那里对这个二级域名进行解析</p><p>登录进阿里云，点进管理控制台，进入域名，点击域名列表</p><center><img src="http://pictures.aimasa.club/static/images/七牛云把测试域名替换成已备份域名/six.png"></center><p>然后在你购买的那个域名旁边点解析</p><center><img src="http://pictures.aimasa.club/static/images/七牛云把测试域名替换成已备份域名/seven.png"></center><p>点击添加记录</p><center><img src="http://pictures.aimasa.club/static/images/七牛云把测试域名替换成已备份域名/add.png"></center><p>按照图示填写信息。</p><p>再然后就等你的</p><center><img src="http://pictures.aimasa.club/static/images/七牛云把测试域名替换成已备份域名/five.png"></center><p>状态变成成功了。</p><p>再然后去你博客配置文件里面更改之前的配置：</p><center><img src="http://pictures.aimasa.club/static/images/七牛云把测试域名替换成已备份域名/final.png"></center><p>把我马克了的地方改成你二级域名，就好了。</p><h1 id="二级域名"><a href="#二级域名" class="headerlink" title="二级域名"></a>二级域名</h1><p>比如你购买的域名是aimasa.com，那么你的二级域名就可以是：{自定义}.aimasa.com。但是这只是一般称谓，一般叫它子域名，因为按维基百科上来说，一级域名是顶级域名，是域名的最后一个部分，二级域名是靠近顶级域名的左边一个部分。然后以此类推可以推出三级域名，四级域名等等。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.jianshu.com/p/88c8ba682ac7" target="_blank" rel="noopener">二级域名是什么的博客，我觉得解释的比大多数博客好太多了</a></p>]]></content>
      
      
      <categories>
          
          <category> hexo更新配置 </category>
          
          <category> 七牛云把测试域名替换成已备份域名 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于接口</title>
      <link href="/2019/05/05/%E5%85%B3%E4%BA%8E%E6%8E%A5%E5%8F%A3/"/>
      <url>/2019/05/05/%E5%85%B3%E4%BA%8E%E6%8E%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>java打包供maven使用</title>
      <link href="/2019/04/28/java%E6%89%93%E5%8C%85%E4%BE%9Bmaven%E4%BD%BF%E7%94%A8/"/>
      <url>/2019/04/28/java%E6%89%93%E5%8C%85%E4%BE%9Bmaven%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>因为之前老师说好的说让我自己试试怎么对项目打包，然后把包封装成相关依赖，这样可以直接在maven里面添加依赖，然后对包进行调用。</p><a id="more"></a><h1 id="把项目打包"><a href="#把项目打包" class="headerlink" title="把项目打包"></a>把项目打包</h1><p>用的是fatjar对项目进行的打包，又快又方便。</p><p>我用的是eclipse4.4版本，对项目右键会有build FatJar的选项，然后点进去，选择好生成jar包的位置【注意：包存放的文件夹名中间不能有空格，不然包转成依赖语句会报错】，然后jar包就生成了。</p><h1 id="把包转换成依赖"><a href="#把包转换成依赖" class="headerlink" title="把包转换成依赖"></a>把包转换成依赖</h1><p>首先win+R进入cmd命令行，然后cd到该jar包存放的位置，再然后输入以下命令行</p><pre><code>mvn install:install-file -Dfile=jar包的位置 -DgroupId=上面的groupId -DartifactId=上面的artifactId -Dversion=上面的version -Dpackaging=jar</code></pre><p>—————————————————-<a href="https://blog.csdn.net/u012759397/article/details/53437502" target="_blank" rel="noopener">摘自博客</a></p><p>然后回车，一顿操作猛如虎，再新建一个项目，添加：</p><pre><code>&lt;dependency&gt;&lt;groupId&gt;com.qrcode&lt;/groupId&gt;&lt;!--DgroupId等于的参数值--&gt;&lt;artifactId&gt;qr&lt;/artifactId&gt;&lt;!--DartifactId等于的参数值--&gt;&lt;version&gt;0.1&lt;/version&gt;&lt;!--Dversion等于的参数值--&gt;&lt;/dependency&gt;</code></pre><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://blog.csdn.net/u012759397/article/details/53437502" target="_blank" rel="noopener">博客</a></p>]]></content>
      
      
      <categories>
          
          <category> java语法 </category>
          
          <category> java打包供maven使用 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>java版本太低</title>
      <link href="/2019/04/28/java%E7%89%88%E6%9C%AC%E5%A4%AA%E4%BD%8E/"/>
      <url>/2019/04/28/java%E7%89%88%E6%9C%AC%E5%A4%AA%E4%BD%8E/</url>
      
        <content type="html"><![CDATA[<p>导入一个本来是没有语法错误的项目，然后IDE到处报错，说是jdk版本太高，要更改成低版本。</p><a id="more"></a><p>对着被导入的项目点击右键-&gt; properties-&gt;java build path</p><p>然后双击JRE System Library，然后更换jre的版本号（和本地装的jre的版本号一致）</p><center><img src="http://pictures.aimasa.club/static/images/java版本太低/confi.png"></center><p>然后成功</p>]]></content>
      
      
      <categories>
          
          <category> 运行error </category>
          
          <category> java版本太低 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 运行error </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vim的使用心得</title>
      <link href="/2019/04/23/vim%E7%9A%84%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97/"/>
      <url>/2019/04/23/vim%E7%9A%84%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97/</url>
      
        <content type="html"><![CDATA[<p>因为最近不是b站后台源码被泄露了嘛，然后它用的是go语言，我又不想在windows系统里面装go语言的IDE，然后就在虚拟机里面配置go语言的环境，过程中在里面我用到了一些对vim的操作，在这里特地记录一下。</p><a id="more"></a><h1 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h1><p>直接按<strong>s</strong>键，然后又可以插入，也可以对其中的内容进行修改。</p><h1 id="保存并且推出"><a href="#保存并且推出" class="headerlink" title="保存并且推出"></a>保存并且推出</h1><ul><li>保存：按住esc键，然后输入<strong>:w</strong></li><li>退出：按住esc键，然后输入<strong>:q</strong></li><li>保存且退出：按住esc键，然后输入<strong>:wq</strong></li></ul><h1 id="目前只用到了这些操作方法，所以暂时如此记录"><a href="#目前只用到了这些操作方法，所以暂时如此记录" class="headerlink" title="目前只用到了这些操作方法，所以暂时如此记录"></a>目前只用到了这些操作方法，所以暂时如此记录</h1>]]></content>
      
      
      <categories>
          
          <category> ubuntu的使用 </category>
          
          <category> vim的使用心得 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 关于ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>eclipse调字体大小</title>
      <link href="/2019/04/23/eclipse%E8%B0%83%E5%AD%97%E4%BD%93%E5%A4%A7%E5%B0%8F/"/>
      <url>/2019/04/23/eclipse%E8%B0%83%E5%AD%97%E4%BD%93%E5%A4%A7%E5%B0%8F/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>关于maven</title>
      <link href="/2019/04/18/%E5%85%B3%E4%BA%8Emaven/"/>
      <url>/2019/04/18/%E5%85%B3%E4%BA%8Emaven/</url>
      
        <content type="html"><![CDATA[<p>之前一直只是单纯的知道maven是用来加载库的，然后去代码里面调用它。里面<dependencies>&lt;/dependencies&gt;这里面是存放需要被调用的库的依赖。但是maven里面包括的内容除了<dependencies></dependencies>还有别的，所以就去查了一些资料，然后总结在这。</dependencies></p><a id="more"></a><p>Maven 主要帮助用户完成以下 3 个方面的工作：</p><ul><li>生命周期管理，便捷的构建过程；</li><li>依赖管理，方便引入所需依赖 Jar 包；</li><li>仓库管理，提供统一管理所有 Jar 包的工具；</li></ul><p>————-(<a href="https://www.jianshu.com/p/b4ef9978d85d" target="_blank" rel="noopener">摘自博客</a>)</p><p>在建了一个maven项目之后，会发现在项目里面有一个pom.xml文档</p><h1 id="什么是pom"><a href="#什么是pom" class="headerlink" title="什么是pom"></a>什么是pom</h1><p>项目对象模型或POM是Maven的基本工作单元。 它是一个XML文件，其中包含有关Maven用于构建项目的项目和配置详细信息的信息。 它包含大多数项目的默认值。 这方面的例子是：target是构建目录;构建源目录是src / main / java; src / test / java是测试源目录。执行任务时，Maven在当前目录中查找POM。 它读取POM，获取所需的配置信息，然后执行目标。</p><p>maven install时候，会自动把pom里面添加的依赖下载下来。</p><h1 id="maven的生命周期"><a href="#maven的生命周期" class="headerlink" title="maven的生命周期"></a>maven的生命周期</h1><p>maven内部有三个构建生命周期：分别是：clean, default, site</p><p>我在那个博客里面找到了这张展示default构建生命周期核心阶段的图：</p><center><img src="http://pictures.aimasa.club/static/images/关于maven/life.png"></center><p>当执行mvn install时候，maven就会自动执行生命周期中的validate, compile, test, package, verify, install这些阶段，并将 package 生成的包发布到本地仓库中。</p><p>Maven 将构建过程定义为 default lifecycle</p><h2 id="阶段和插件的关系"><a href="#阶段和插件的关系" class="headerlink" title="阶段和插件的关系"></a>阶段和插件的关系</h2><p>就像上面说的那样，maven把构建过程定义成default lifecycle，并且将它里面的一个个阶段划分为phase，但是这些phase只是规定执行顺序，对于每个阶段做什么工作，就要看pom.xml里面的插件（plugins）了。</p><p>pom.xml里面有这么个元素叫<plugins>，它是用来把phase和做的目标<goal>绑定在一起，当要执行某个<phase>时候，就会调用插件来完成绑定的目标，一个阶段里面可以绑定好多个目标，也可以不绑定目标。</phase></goal></plugins></p><p>但是不配置<plugins>也可以，因为maven有默认的<plugins>。</plugins></plugins></p><p>在输出日志里面，会有一系列的 插件(plugin):版本号:<goal>(phase) 输出，可以根据日志里面的这种输出去观察哪些阶段会调用插件去完成那些<goal>了。</goal></goal></p><h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><p>在<dependencies></dependencies>里面的依赖一般都是这种形式出现：</p><pre><code>    &lt;dependency&gt;    &lt;groupId&gt;mysql&lt;/groupId&gt;    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;    &lt;scope&gt;runtime&lt;/scope&gt;    &lt;/dependency&gt;</code></pre><h2 id="关于maven整体"><a href="#关于maven整体" class="headerlink" title="关于maven整体"></a>关于maven整体</h2><p>| groupId|一般用该项目的组织或团体的域名来标识，例如:org.apache.maven.plugins  |</p><p>| artifactId | 代表唯一的工程名 |</p><p>|version| 版本号|</p><p>|packaging| 标识打包的类型，例如有:jar, war, tar |</p><p>|dependencies| 该工程内依赖的其他 jar 包|</p><h2 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h2><p>如果 Maven 在中央仓库中也找不到依赖的库文件，它会停止构建过程并输出错误信息到控制台。为避免这种情况，Maven 提供了远程仓库的概念，它是开发人员自己定制仓库，包含了所需要的代码库或者其他工程中用到的 jar 文件。</p><h2 id=""><a href="#" class="headerlink" title=""></a><respositories></respositories></h2><p>我的理解就是可以通过这个repositories节点，去访问给出的url地址上的这个仓库，去下载自己需要的库，因为这个库在可能是自己的远程仓库里面，就没法从中央仓库里面下载到这个库，所以就使用这个节点，里面配置各种你可能需要用到的远程库。</p><pre><code>&lt;repositories&gt;    &lt;repository&gt;        &lt;id&gt;spring-snapshots&lt;/id&gt;        &lt;name&gt;Spring Snapshots&lt;/name&gt;        &lt;url&gt;https://repo.spring.io/snapshot&lt;/url&gt;        &lt;snapshots&gt;            &lt;enabled&gt;true&lt;/enabled&gt;        &lt;/snapshots&gt;    &lt;/repository&gt;</code></pre><h2 id="Maven-依赖搜索顺序"><a href="#Maven-依赖搜索顺序" class="headerlink" title="Maven 依赖搜索顺序"></a>Maven 依赖搜索顺序</h2><p>当我们执行 Maven 构建命令时，Maven 开始按照以下顺序查找依赖的库：</p><ul><li>步骤 1 － 在本地仓库中搜索，如果找不到，执行步骤 2，如果找到了则执行其他操作。</li><li>步骤 2 － 在中央仓库中搜索，如果找不到，并且有一个或多个远程仓库已经设置，则执行步骤 4，如果找到了则下载到本地仓库中已被将来引用。</li><li>步骤 3 － 如果远程仓库没有被设置，Maven 将简单的停滞处理并抛出错误（无法找到依赖的文件）。</li><li>步骤 4 － 在一个或多个远程仓库中搜索依赖的文件，如果找到则下载到本地仓库已被将来引用，否则 Maven 将停止处理并抛出错误（无法找到依赖的文件）。</li></ul><p>———————————<a href="https://wiki.jikexueyuan.com/project/maven/repositories.html" target="_blank" rel="noopener">摘自极客学院maven教程</a></p><h1 id="关于-xxx-version"><a href="#关于-xxx-version" class="headerlink" title="关于${xxx.version}"></a>关于${xxx.version}</h1><p>一般，会经常看到官网上放出的写maven依赖中有个语句是</p><pre><code>&lt;version&gt;${xxx.version}&lt;version&gt;</code></pre><p>但是maven总是报错，是因为你这里没有指明这个添加的依赖的版本，maven是不会自动给你找到相关依赖的最新版本的包并且去下载的，所以你需要在<properties></properties>里面加上  </p><pre><code>&lt;xxx.version&gt;1.3.0.Final&lt;/xxx.version&gt;</code></pre><p>这样的话，就是<strong>${xxx.version}</strong>的值就是对应给出的<strong>1.3.0.Final</strong>了。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.jianshu.com/p/b4ef9978d85d" target="_blank" rel="noopener">maven入门</a></p><p><a href="https://www.jianshu.com/p/fd43b3d0fdb0" target="_blank" rel="noopener">maven生命周期</a></p><p><a href="https://wiki.jikexueyuan.com/project/maven/repositories.html" target="_blank" rel="noopener">极客学院maven教程</a></p>]]></content>
      
      
      <categories>
          
          <category> maven </category>
          
      </categories>
      
      
        <tags>
            
            <tag> maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开始学习spring（五）：连接数据库</title>
      <link href="/2019/04/17/%E5%BC%80%E5%A7%8B%E5%AD%A6%E4%B9%A0spring%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9A%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
      <url>/2019/04/17/%E5%BC%80%E5%A7%8B%E5%AD%A6%E4%B9%A0spring%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9A%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<p>因为这边都用的是jooq框架来对数据库进行操作，然后我就开始学jooq框架惹==。我暑假还是想好好的活着，不想再像上个暑假一样痛苦。</p><p>不过刚开始接触这个框架，坑也没少踩，我会在下面分别列出来。</p><p>用的是maven</p><a id="more"></a><h1 id="第一步：装依赖"><a href="#第一步：装依赖" class="headerlink" title="第一步：装依赖"></a>第一步：装依赖</h1><p>在jooq的官网看，首先第一步，在pom中要加上这三个依赖</p><pre><code>    &lt;dependency&gt;        &lt;groupId&gt;org.jooq&lt;/groupId&gt;        &lt;artifactId&gt;jooq&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.jooq&lt;/groupId&gt;        &lt;artifactId&gt;jooq-meta&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.jooq&lt;/groupId&gt;        &lt;artifactId&gt;jooq-codegen&lt;/artifactId&gt;    &lt;/dependency&gt;</code></pre><ul><li>jooq ：核心包，CRUD（增删查改）核心类所在大本营。</li><li>jooq-meta ：数据管理和操作的核心代码。</li><li>jooq-codegen ：负责数据库代码生成，主要负责JOOQ的代码生成功能。</li></ul><h1 id="第二步：加插件"><a href="#第二步：加插件" class="headerlink" title="第二步：加插件"></a>第二步：加插件</h1><pre><code>        &lt;plugin&gt;            &lt;groupId&gt;org.jooq&lt;/groupId&gt;            &lt;artifactId&gt;jooq-codegen-maven&lt;/artifactId&gt;            &lt;executions&gt;                &lt;execution&gt;                    &lt;goals&gt;                        &lt;goal&gt;generate&lt;/goal&gt;                    &lt;/goals&gt;                &lt;/execution&gt;            &lt;/executions&gt;            &lt;dependencies&gt;                &lt;dependency&gt;                    &lt;groupId&gt;mysql&lt;/groupId&gt;                    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;                    &lt;version&gt;5.1.39&lt;/version&gt;                &lt;/dependency&gt;            &lt;/dependencies&gt;            &lt;configuration&gt;                &lt;jdbc&gt;                    &lt;driver&gt;com.mysql.jdbc.Driver&lt;/driver&gt;                    &lt;url&gt;jdbc:mysql://localhost:3306/exercise_test?useSSL=true&lt;/url&gt;                    &lt;user&gt;root&lt;/user&gt;                    &lt;password&gt;&lt;/password&gt;                &lt;/jdbc&gt;                &lt;generator&gt;                    &lt;database&gt;                        &lt;name&gt;org.jooq.util.mysql.MySQLDatabase&lt;/name&gt;                        &lt;includes&gt;.*&lt;/includes&gt;                        &lt;excludes&gt;&lt;/excludes&gt;                        &lt;inputSchema&gt;exercise_test&lt;/inputSchema&gt;                        &lt;forcedTypes&gt;                            &lt;forcedType&gt;                                &lt;userType&gt;java.util.Date&lt;/userType&gt;                                &lt;converter&gt;com.example.util.DateConverter&lt;/converter&gt;                                &lt;types&gt;datetime&lt;/types&gt;                            &lt;/forcedType&gt;                        &lt;/forcedTypes&gt;                    &lt;/database&gt;                    &lt;target&gt;                        &lt;!-- The destination package of your generated classes (within the                             destination directory) --&gt;                        &lt;packageName&gt;com.example.pojo&lt;/packageName&gt;                        &lt;!-- The destination directory of your generated classes --&gt;                        &lt;directory&gt;/src/main/java&lt;/directory&gt;                    &lt;/target&gt;                    &lt;generate&gt;                        &lt;pojos&gt;true&lt;/pojos&gt;                        &lt;daos&gt;true&lt;/daos&gt;                        &lt;deprecated&gt;false&lt;/deprecated&gt;                    &lt;/generate&gt;                &lt;/generator&gt;            &lt;/configuration&gt;        &lt;/plugin&gt;</code></pre><p>这一部分是用来生成数据库映射代码的插件。</p><p>里面是对数据库的信息进行配置：</p><pre><code>            &lt;configuration&gt;                &lt;jdbc&gt;                    &lt;driver&gt;com.mysql.jdbc.Driver&lt;/driver&gt;                    &lt;url&gt;jdbc:mysql://localhost:3306/exercise_test?useSSL=true&lt;/url&gt;                    &lt;user&gt;root&lt;/user&gt;                    &lt;password&gt;&lt;/password&gt;                &lt;/jdbc&gt;                &lt;generator&gt;                    &lt;database&gt;                        &lt;name&gt;org.jooq.util.mysql.MySQLDatabase&lt;/name&gt;                        &lt;includes&gt;.*&lt;/includes&gt;&lt;!--点后面的所有文件--&gt;                        &lt;excludes&gt;&lt;/excludes&gt;                        &lt;!--映射的数据库的架构名（就是你的表是放在哪个架构下的）--&gt;                        &lt;inputSchema&gt;exercise_test&lt;/inputSchema&gt;                        &lt;forcedTypes&gt;                            &lt;forcedType&gt;                                &lt;userType&gt;java.util.Date&lt;/userType&gt;                                &lt;converter&gt;com.example.util.DateConverter&lt;/converter&gt;                                &lt;types&gt;datetime&lt;/types&gt;                            &lt;/forcedType&gt;                        &lt;/forcedTypes&gt;                    &lt;/database&gt;                    &lt;target&gt;                        &lt;!-- 你数据库映射出来的表打算放在代码里面的哪个包下 --&gt;                        &lt;packageName&gt;com.example.pojo&lt;/packageName&gt;                        &lt;!-- 这个包是应该在哪个class下面 --&gt;                        &lt;directory&gt;/src/main/java&lt;/directory&gt;                    &lt;/target&gt;                    &lt;generate&gt;                        &lt;pojos&gt;true&lt;/pojos&gt;                        &lt;daos&gt;true&lt;/daos&gt;                        &lt;deprecated&gt;false&lt;/deprecated&gt;                    &lt;/generate&gt;                &lt;/generator&gt;            &lt;/configuration&gt;</code></pre><p>这里面配置这段就是把数据库中的表映射出来的。</p><pre><code>                         &lt;forcedTypes&gt;                            &lt;forcedType&gt;                                &lt;userType&gt;java.util.Date&lt;/userType&gt;                                &lt;converter&gt;com.example.util.DateConverter&lt;/converter&gt;                                &lt;types&gt;datetime&lt;/types&gt;                            &lt;/forcedType&gt;                        &lt;/forcedTypes&gt;</code></pre><p>这段代码是用来映射时间戳的，其中</p><pre><code>&lt;converter&gt;com.example.util.DateConverter&lt;/converter&gt;</code></pre><p>是放有映射方法的包，没有放映射方法的话，那这段无效==。可以按ctrl进去，查看这个包，如果无法查看的话，那么说明这个包不是需要的。</p><h1 id="数据库的架构"><a href="#数据库的架构" class="headerlink" title="数据库的架构"></a>数据库的架构</h1><p>放张图就很详细了：</p><center><img src="http://pictures.aimasa.club/static/images/开始学习spring（五）：连接数据库/schema.jpg"></center><h1 id="出错地方"><a href="#出错地方" class="headerlink" title="出错地方"></a>出错地方</h1><p>这样配置完成后，我的这个项目名旁边跟了一个红<strong>×</strong>，所以就右键项目，选中<strong>maven</strong>，出现子目录，选中<strong>update project</strong>，点击，如果配置没有错误的话，红<strong>×</strong>会自然消失。</p><p>然后就是maven install的问题了，显示BUILD FAILED失败，里面有一句话，翻译过来是问我有没有配置错jdk，所以我就去perferences里面的 java-&gt;install JREs看了看里面的包是不是配置的jdk包，如果不是，点击add-&gt;Standard VM-&gt;next-&gt;选择jdk的包</p><p>再然后maven install就没有再出问题了，同时，也将我数据库里的表转换成了pojo的包里的java类了。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="http://www.mysunshinedreams.com/orm%E7%9A%84%E5%B0%8F%E6%B8%85%E6%96%B0-jooq/" target="_blank" rel="noopener">参考博客</a></p>]]></content>
      
      
      <categories>
          
          <category> spring相关 </category>
          
          <category> 连接数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring相关 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开始学习spring（四）：Junit测试</title>
      <link href="/2019/04/10/%E5%BC%80%E5%A7%8B%E5%AD%A6%E4%B9%A0spring%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9AJunit%E6%B5%8B%E8%AF%95/"/>
      <url>/2019/04/10/%E5%BC%80%E5%A7%8B%E5%AD%A6%E4%B9%A0spring%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9AJunit%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<p>跟着<a href="http://blog.didispace.com/spring-boot-learning-1/" target="_blank" rel="noopener">博客</a>开始学怎么用Junit对写出的部分代码进行单元测试。</p><a id="more"></a><h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><p>跟着它给的代码：</p><pre><code>@RunWith(SpringJUnit4ClassRunner.class)@SpringBootTest(classes=MockServletContext.class)@WebAppConfigurationpublic class DemoApplicationTests {    private MockMvc mvc;    @Before    public void Setup() throws Exception {        mvc = MockMvcBuilders.standaloneSetup(new exampleController()).build();    }    @Test    public void contextLoads() throws Exception{        mvc.perform(MockMvcRequestBuilders.get(&quot;/&quot;).accept(MediaType.APPLICATION_JSON))                .andExpect(status().isOk())                .andExpect(content().string(equalTo(&quot;index&quot;))).andDo(print());    }}</code></pre><p>但是很奇怪的是一直在</p><pre><code> .andExpect(content().string(equalTo(&quot;index&quot;))).andDo(print());</code></pre><p>这个部分报错，说<strong>The method content()/equalTo() is ambiguous for the type DemoApplicationTests</strong></p><p>结果我发现在我直接敲入这段代码时候，eclipse会直接帮忙自动导入对应的包：</p><pre><code>import static org.hamcrest.CoreMatchers.equalTo;import static org.hamcrest.Matchers.equalTo;import static org.springframework.test.web.client.match.MockRestRequestMatchers.content;import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;</code></pre><p>里面会有不同包里面的同名称的类文件，在这里我们选用：</p><pre><code>import static org.hamcrest.Matchers.equalTo;import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;</code></pre><h1 id="讲解"><a href="#讲解" class="headerlink" title="讲解"></a>讲解</h1><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><h3 id="MockMvcBuilders"><a href="#MockMvcBuilders" class="headerlink" title="MockMvcBuilders"></a>MockMvcBuilders</h3><p>这个是用来构造MockMvc的构造器，主要是有两种实现，分别是StandaloneMockMvcBuilder和DefaultMockMvcBuilder一种是独立安装和集成Web环境测试（此种方式并不会集成真正的web环境，而是通过相应的Mock API进行模拟测试，无须启动服务器）。</p><p>较新版的Spring Boot取消了@SpringApplicationConfiguration这个注解，用@SpringBootTest就可以了</p><h3 id="集成web环境测试"><a href="#集成web环境测试" class="headerlink" title="集成web环境测试"></a>集成web环境测试</h3><p>MockMvcBuilders.webAppContextSetup(WebAppContext webAppContext):指定的webAPPContext会从<strong>上下文中去获取相应的控制器</strong>并得到相应的MockMvc</p><p>怎么获取呢？所以就在测试的程序前面加上@ContextConfiguration(classes = xxx.class)（xxx.class是自己定义的配置类，继承WebMvcConfigurerAdapter 这个类的类，新版spring boot不用继承这类再去使用了，会报错，它改成直接用接口形式implements这个类，并且去使用，还有一个方法来着去使用这个类，但是我忘了，可以直接谷歌一下，WebMvcConfigurerAdapter配置类其实是Spring内部的一种配置方式，采用JavaBean的形式来代替传统的xml配置文件形式进行针对框架个性化定制，它是对需要进行拦截的地方是要使用的拦截器配好对）。</p><p>（拦截器是什么：拦截器相当于把一部分会需要经常改动的代码提取出来，然后对一些固有操作执行前进行拦截，去运行在不同情况下需要运行的代码。减少代码的冗余度，提高重用率。也就是AOP的一种运用。）</p><p>如果没有@ContextConfiguration是会报错的。</p><p>@WebAppConfiguration：测试环境使用，用来表示测试环境使用的ApplicationContext将是WebApplicationContext类型的；value指定web应用的根；</p><p>@Autowired WebApplicationContext wac:注入web环境的applicationContext容器；</p><p>然后通过MockMvcBuilders.webAppContextSetup(this.wac).build();创建一个MockMvc去测试。</p><h3 id="独立测试方式"><a href="#独立测试方式" class="headerlink" title="独立测试方式"></a>独立测试方式</h3><p>这个MockMvcBuilders.standaloneSetup(Object… controllers)可以通过参数去指定一组或者一个控制器，而不需要上下文获取了。</p><p>只需两个步骤：创建相应的控制器，然后注入相应的依赖；通过MockMvcBuilders.standaloneSetup(Object… controllers).bulid()去获取一个MockMvc去测试。</p><h2 id="RequestBuilder"><a href="#RequestBuilder" class="headerlink" title="RequestBuilder"></a>RequestBuilder</h2><p>RequestBuilder这个是用来存放模拟输入的命令的。比如在这里我要测试控制层的输出结果是不是我想要的，然后我会用RequestBuilder.get/post/put…(/网址/).param()…这样去模拟数据输入，进而测试程序有没有错误。</p><pre><code>        request = get(&quot;/users/&quot;);</code></pre><p>RequestBuilder执行完这一步之后，里面会存放如下参数：</p><center><img src="http://pictures.aimasa.club/static/images/开始学习spring（四）：Junit测试/RequestBuilder.png"></center><p>可以从图中看到里面有我刚开始设置进去的网址”/users”,然后其他值设置之类地方都是显示null，或者[]或者{}。</p><h1 id="关于content-string-equalTo-xxx"><a href="#关于content-string-equalTo-xxx" class="headerlink" title="关于content().string(equalTo(xxx))"></a>关于content().string(equalTo(xxx))</h1><p>跟着敲完对控制层的测试类之后，一直报错，我debug发现，不是程序里面的问题，是我参数出的问题。</p><p>我里面的参数不是少了对字符串的外标的双引号，就是字符串的排列顺序不对</p><p>我设置的返回值是对User实例化后的字符串的值的返回</p><pre><code>public class User {    private String name;    private long id;    private Integer age;}</code></pre><p>里面按照顺序需要：name 、 id 、 age这个顺序返回值，然后碰到字符串时候，需要上标双引号，但是因为本身我就是设置它需要根据我给出的字符串去比较是不是我想要的结果，所以在content().string(equalTo(xxx))里面，xxx这个字符串中的双引号需要转义字符：\”</p><pre><code>content().string(equalTo(&quot;[{\&quot;name\&quot;:\&quot;nana\&quot;,\&quot;id\&quot;:1,\&quot;age\&quot;:12}]&quot;))).andDo(print())</code></pre><h2 id="测试部分"><a href="#测试部分" class="headerlink" title="测试部分"></a>测试部分</h2><p>perform：执行一个RequestBuilder请求，会自动执行SpringMVC的流程并映射到相应的控制器执行处理；</p><p>andExpect：添加ResultMatcher验证规则，验证控制器执行完成后结果是否正确；</p><p>andDo：添加ResultHandler结果处理器，比如调试时打印结果到控制台；</p><p>andReturn：最后返回相应的MvcResult；然后进行自定义验证/进行下一步的异步处理；</p><p>accept：接收的返回的信息格式，这里是接收的是json类型数据。</p><p>ContentResultMatchers content()：得到响应内容验证器；</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://blog.csdn.net/cankingapp/article/details/7626566" target="_blank" rel="noopener">关于拦截器讲解比较详细的博客</a></p><p><a href="https://www.cnblogs.com/lyy-2016/p/6122144.html" target="_blank" rel="noopener">关于测试部分讲解详细的博客</a></p>]]></content>
      
      
      <categories>
          
          <category> spring相关 </category>
          
          <category> Junit测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring相关 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开始学习spring（三）：注解2</title>
      <link href="/2019/04/08/%E5%BC%80%E5%A7%8B%E5%AD%A6%E4%B9%A0spring%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E6%B3%A8%E8%A7%A32/"/>
      <url>/2019/04/08/%E5%BC%80%E5%A7%8B%E5%AD%A6%E4%B9%A0spring%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E6%B3%A8%E8%A7%A32/</url>
      
        <content type="html"><![CDATA[<p>虽然明白注解是怎么一回事了，但是还是好奇它的反射机制是怎么实现的，所以谷歌了一下，之后可能会试着自己看看源码。</p><p>注：在 Spring 中，构成应用程序主干并由Spring IoC容器管理的对象称为bean。bean是一个由Spring IoC容器实例化、组装和管理的对象。</p><p><a href="https://www.awaimai.com/2596.html" target="_blank" rel="noopener">关于IoC(控制反转)</a></p><a id="more"></a><h1 id="RequestMapping"><a href="#RequestMapping" class="headerlink" title="RequestMapping"></a>RequestMapping</h1><p>这个是用来处理请求地址映射的注解，它的注解有六个属性：</p><h2 id="value"><a href="#value" class="headerlink" title="value"></a>value</h2><p><strong>value</strong>：指定请求的实际地址</p><p><strong>method</strong>： 指定请求的method类型， GET、POST、PUT、DELETE等；</p><center><img src="http://pictures.aimasa.club/static/images/开始学习spring（三）：注解2/method.png"></center><p><strong>consumes</strong>：指定处理请求的提交内容类型（Content-Type），例如application/json, text/html;</p><p><strong>produces</strong>: 指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回；</p><p><strong>params</strong>： 指定request中必须包含某些参数值是，才让该方法处理。</p><p><strong>headers</strong>： 指定request中必须包含某些指定的header值，才能让该方法处理请求。</p><h2 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h2><p>对服务类进行注解标记，让@componentScan将这些类装载注入到Spring的bean容器中，或者如果没有@ComponentScan这个注解的话，spring会自动去扫描Application这个类所在的包列表下面的类，如果含有@Service标注，那么被看做是服务类被装入spring的bean容器里面。</p><h2 id="Repository"><a href="#Repository" class="headerlink" title="Repository"></a>Repository</h2><p>@Repository标记该类为数据层，Dao层。</p><h2 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h2><p>@Controller层用于标记该类为控制层。</p><h2 id="Autowired"><a href="#Autowired" class="headerlink" title="Autowired"></a>Autowired</h2><p>———————-<a href="https://blog.csdn.net/walkerJong/article/details/7994326" target="_blank" rel="noopener">摘自博客</a>等我用了一遍再回来补充。</p><h2 id="ResponseStatus"><a href="#ResponseStatus" class="headerlink" title="@ResponseStatus"></a>@ResponseStatus</h2><p>@ResponseStatus这个注解是做异常处理的，然后可以自定义异常。当我们的Controller抛出异常，并且没有被处理的时候，他将返回HTTP STATUS 为指定值的 HTTP RESPONSE.</p>]]></content>
      
      
      <categories>
          
          <category> spring相关 </category>
          
          <category> 注解 </category>
          
          <category> spring注解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring相关 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开始学习spring（三）：注解</title>
      <link href="/2019/04/04/%E5%BC%80%E5%A7%8B%E5%AD%A6%E4%B9%A0spring%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E6%B3%A8%E8%A7%A3/"/>
      <url>/2019/04/04/%E5%BC%80%E5%A7%8B%E5%AD%A6%E4%B9%A0spring%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E6%B3%A8%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>因为spring Boot项目里面一直要用到注解，所以我特地开了一篇文章来介绍元注解和自定义注解。关于@ResponseMapping这类经常用到的注解可能会零开一篇去写。</p><p>现有的spring提供了大量的注解，而且点进去会发现它的源码很短，注解中用到的Annotations元注解其实只是元数据，和业务逻辑一点关系都没有，既然和业务逻辑没有关系，那么就必须有人来实现这些逻辑。Annotations仅仅提供它定义的属性(类/方法/包/域)的信息.</p><p>当我们使用Java的标注Annotations(例如@Override)时，JVM就是一个用户，它在字节码层面工作。</p><p>bean 是组件的意思。</p><a id="more"></a><h1 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h1><p>一共有以下个元注解</p><ul><li>@Document</li><li>@Target</li><li>@Retention</li><li>@Inherited</li></ul><h2 id="Target"><a href="#Target" class="headerlink" title="@Target"></a>@Target</h2><p>它是用来约束注解的使用范围的，可以用ElementType类型去给它定义使用范围，一下是它的源代码：</p><pre><code>public enum ElementType {    /** Class, interface (including annotation type), or enum declaration */    TYPE,    /** Field declaration (includes enum constants) */    FIELD,    /** Method declaration */    METHOD,    /** Formal parameter declaration */    PARAMETER,    /** Constructor declaration */    CONSTRUCTOR,    /** Local variable declaration */    LOCAL_VARIABLE,    /** 用于另外一个注解上 */    ANNOTATION_TYPE,    /** Package declaration */    PACKAGE,    /**     * Type parameter declaration     *     * @since 1.8     */    TYPE_PARAMETER,    /**     * Use of a type     *     * @since 1.8     */    TYPE_USE}</code></pre><p>如果这个注解中@Target没有被申明，那么意思是它可以被应用在任何元素之上。</p><h1 id="Retention"><a href="#Retention" class="headerlink" title="@Retention"></a>@Retention</h1><p>这个元注解是用来约束注解的生命周期的。里面有三个状态，一个是源码级别（source）、一个是类文件级别（class）、还一个是运行时级别（runtime）</p><ul><li>source ： 注解将被编译器丢弃（这个类型的注解信息只保留在源码里面，源码经过编译后，注解信息会被丢弃，不会保留在编译好的class里面。）如java内置注解：@Override、@SuppressWarnning等</li><li>class ： 注解在class文件里可用，但是会被vm（虚拟机）抛弃（这个类型的注解信息只会保存在源码里面和class文件里面，在运行时候，不会载入虚拟机里面），<strong>当注解没有定义Retention的时候，会默认是class</strong>，如java内置注解：</li><li>runtime ： 注解信息将在运行期（JVM）中也保留，因此可以通过反射机制读取注解的信息。（源码、class文件和虚拟机中都有注解的信息。）如SpringMvc中的@Controller、@Autowired、@RequestMapping等，如java内置注解：@Deprecated(用于标明已经过时的方法或类)等。</li></ul><h1 id="Documented"><a href="#Documented" class="headerlink" title="@Documented"></a>@Documented</h1><p>@Documented 被修饰的注解会生成到javadoc中</p><h1 id="Inherited"><a href="#Inherited" class="headerlink" title="@Inherited"></a>@Inherited</h1><p>可以让注解被继承，但这并不是真的继承，只是通过使用@Inherited，可以让子类Class对象使用getAnnotations()获取父类被@Inherited修饰的注解。</p><h1 id="关于自定义注解里面的一些语句"><a href="#关于自定义注解里面的一些语句" class="headerlink" title="关于自定义注解里面的一些语句"></a>关于自定义注解里面的一些语句</h1><pre><code>String name() default &quot;&quot;;//指定义了name这个属性，默认是空字符串。</code></pre><p>声明注解类型时候，不能用包装类型，只能用基本类型去声明</p><pre><code>@Target({ElementType.TYPE})@Retention(RetentionPolicy.RUNTIME)@Documented@Componentpublic @interface Controller {    @AliasFor(annotation = Component.class)    String value() default &quot;&quot;;}</code></pre><p>因为上面除掉元注解外还有@component，说明@controller这个注解属于@component这个注解</p><p>我们定义了自己的注解并将其应用在业务逻辑的方法上。所以就需要我们写一个用户程序调用我们的注解。这里需要使用<strong>反射机制</strong>。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://blog.csdn.net/javazejian/article/details/71860633" target="_blank" rel="noopener">我觉得写得很详细的</a></p><p><a href="http://www.importnew.com/10294.html" target="_blank" rel="noopener">注解是什么</a></p>]]></content>
      
      
      <categories>
          
          <category> spring相关 </category>
          
          <category> 注解 </category>
          
          <category> 注解大体简介 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring相关 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分排序法</title>
      <link href="/2019/04/03/%E4%BA%8C%E5%88%86%E6%8E%92%E5%BA%8F%E6%B3%95/"/>
      <url>/2019/04/03/%E4%BA%8C%E5%88%86%E6%8E%92%E5%BA%8F%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>这是很久前写的一篇博文，现在转移了地址，就一起把这篇博文转过来。</p><p>二分排序法书上的讲解用的是借抓<br>扑克牌这个模式讲的</p><a id="more"></a><h1 id="二分法排序"><a href="#二分法排序" class="headerlink" title="二分法排序"></a>二分法排序</h1><pre><code>public class B {    public void BinarySort(int[] a) {        for (int i = 1; i &lt; a.length; i++) {            int tmp = a[i];            int left = 0;            int right = i - 1;            while (left &lt;= right) {                int mid = (right + left)&gt;&gt;1;                if (a[mid] &gt; tmp) {                    right = mid - 1;                } else {                    left = mid + 1;                }            }            for (int j = i - 1; j &gt;= left; j--) {                a[j + 1] = a[j];            }            a[left] = tmp;        }    }}public class test {    public static void main(String[] args) {        int[] a= {1,24,5,6,3,2,7,8,2};        B b=new B();        b.BinarySort(a);        for(int i=0;i&lt;a.length;i++){        System.out.println(a[i]);}    }}</code></pre><p> 就是先从低位开始排序，从i=1开始大循环，从已经排好序的left和right中折中取中间数，然后再和还未排序的数字进行比较大小，如果是大于中间数的话那么更改left指向位置（指向中间数后一个数据），依次循环，如果right小于left的话终止比较（这样就不会忘记把right指向的数据和需要排序的数据进行比较）。接着就插入，像插入排序那样进行数据交换，把这个未排序的数字插入该插入的地方。</p><p>ps:求left和right之间的mid的等式是：（left+right）&gt;&gt;1！</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 二分排序法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MavenInstall错误类型（一）</title>
      <link href="/2019/04/03/MavenInstall%E9%94%99%E8%AF%AF%E7%B1%BB%E5%9E%8B%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2019/04/03/MavenInstall%E9%94%99%E8%AF%AF%E7%B1%BB%E5%9E%8B%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>工具：STS</p><p>在Maven Install加载pom.xml里面添加的依赖时候，结果出了错误：Failed to execute goal org.apache.maven.plugins:maven-surefire-plugin:2.22.1</p><a id="more"></a><p>我百度了一会，各种方法都试过，却没有用，结果发现是我之前点击Spring Boot App这里让这个项目运行起来了，但是却没有关闭，然后再点击Maven Install，所以报错了。</p>]]></content>
      
      
      <categories>
          
          <category> 运行error </category>
          
          <category> Maven Install错误类型：Failed to execute goal org.apache.maven.plugins:maven-surefire-plugin:2.22.1 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Maven Install error </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开始学习spring（二）：试图搭建一个相关项目</title>
      <link href="/2019/04/02/%E5%BC%80%E5%A7%8B%E5%AD%A6%E4%B9%A0spring%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%AF%95%E5%9B%BE%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%9B%B8%E5%85%B3%E9%A1%B9%E7%9B%AE/"/>
      <url>/2019/04/02/%E5%BC%80%E5%A7%8B%E5%AD%A6%E4%B9%A0spring%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%AF%95%E5%9B%BE%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%9B%B8%E5%85%B3%E9%A1%B9%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<p>看了很多东西，但是概念太多了，脑壳痛，所以先搭一个spring Boot的项目，运行一下，再深入学习一下。在别人推荐下我用的是STS（Spring Tool Suite）去搭建的这个项目。</p><a id="more"></a><h1 id="新建项目"><a href="#新建项目" class="headerlink" title="新建项目"></a>新建项目</h1><center><img src="http://pictures.aimasa.club/static/images/开始学习spring（二）：试图搭建一个相关项目/new.png"></center><p>在新建-&gt;project里面的弹出框选择Spring Starter Project去新建一个project。</p><center><img src="http://pictures.aimasa.club/static/images/开始学习spring（二）：试图搭建一个相关项目/then.png"></center><p>然后我箭头指的地方是我做过些许改动的地方，接着点击Next。</p><center><img src="http://pictures.aimasa.club/static/images/开始学习spring（二）：试图搭建一个相关项目/next.png"></center><p>再在红色框框框住的地方选择自己想要的插件，这样maven会自动在pom.xml里面自动填写相关代码去下载需要的配件的安装包，最后点击Finish，就完成了新建spring Boot的任务。</p><h1 id="添加代码让项目成功运行"><a href="#添加代码让项目成功运行" class="headerlink" title="添加代码让项目成功运行"></a>添加代码让项目成功运行</h1><p>在src/main/java下面新建一个类，命名为xxxcontroller.java，然后在这个类里面写上如下代码：</p><pre><code>@Controllerpublic class exampleControl {    @RequestMapping(&quot;/&quot;)    public String Index(Locale locale, Model model) {        Date date = new Date();        DateFormat dateFormat = DateFormat.getDateTimeInstance(DateFormat.LONG, DateFormat.LONG, locale);        String formatDate = dateFormat.format(date);        model.addAttribute(&quot;serverTime&quot;,formatDate);        return &quot;Index&quot;;    }</code></pre><p>然后再在src/main/resources/templates里面新建一个HTML文件：index.html</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h3&gt;Spring Boot and Spring MVC&lt;/h3&gt;    &lt;P th:text=&quot;&#39;The time on the server is &#39; + ${serverTime}&quot;&gt;&lt;/P&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>接着得记住去原项目根目录下的pom.xml里面添上这样一行:</p><pre><code>    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;    &lt;/dependency&gt;</code></pre><p>Thymeleaf是一个XML/XHTML/HTML5模板引擎，用来渲染页面的。Thymeleaf的主要目标在于提供一种可被浏览器正确显示的、格式良好的模板创建方式，因此也可以用作静态建模。<br>之后就才显示</p><img src="http://pictures.aimasa.club/static/images/开始学习spring（二）：试图搭建一个相关项目/result.png"><p>不然会显示：</p><img src="http://pictures.aimasa.club/static/images/开始学习spring（二）：试图搭建一个相关项目/404.png"><p>在正在运行时的状态下，修改代码是不会直接反馈到浏览器上显示的，所以得停止运行，再重启。</p><h1 id="运行后出现page-no-find"><a href="#运行后出现page-no-find" class="headerlink" title="运行后出现page no find"></a>运行后出现page no find</h1><p>默认情况下spring boot只会扫描启动类当前包和以下的包，在如果配置正确，但是还是没有运行出现自己想要的界面的情况下，可能有原因是在Application.class这个类扫描时候没有扫描到你的controller控制类，所以你可以在你的Application.class这个类里面@SpringBootApplication下面加上@componentscan(controller所在的包。)</p><p>@SpringBootApplication<br>@componentscan(basePackages = “com.didispace.*”)</p><h1 id="关于该项目用到的注解"><a href="#关于该项目用到的注解" class="headerlink" title="关于该项目用到的注解"></a>关于该项目用到的注解</h1><h2 id="Controller"><a href="#Controller" class="headerlink" title="@Controller"></a>@Controller</h2><p>根据代码中给出的解释就是，带了这个注释的类就是控制器，允许通过类路径扫描自动检测实现类，通常与@ResponseMapping这类注释结合使用。</p><p>我刚刚谷歌了一下这方面的知识，用@Controller其实大部分是用来返回字符串，或者是字符串匹配的模板名称，即直接渲染视图，和HTML结合使用的，但是这个前提前后端配合度要高。（单用@Controller并且不做别的处理的话，返回的字符串没有对应的HTML页面的话，就会报错，出现Whitelabel Error Page这个页面）</p><h3 id="在-Controller这个注解里面的-AliasFor"><a href="#在-Controller这个注解里面的-AliasFor" class="headerlink" title="在@Controller这个注解里面的@AliasFor"></a>在@Controller这个注解里面的@AliasFor</h3><pre><code>@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.METHOD)@Documentedpublic @interface AliasFor {    /**     * Alias for {@link #attribute}.     * &lt;p&gt;Intended to be used instead of {@link #attribute} when {@link #annotation}     * is not declared &amp;mdash; for example: {@code @AliasFor(&quot;value&quot;)} instead of     * {@code @AliasFor(attribute = &quot;value&quot;)}.     */    @AliasFor(&quot;attribute&quot;)    String value() default &quot;&quot;;    /**     * The name of the attribute that &lt;em&gt;this&lt;/em&gt; attribute is an alias for.     * @see #value     */    @AliasFor(&quot;value&quot;)    String attribute() default &quot;&quot;;}</code></pre><p>就相当于value的用法和attribute的用法是一样的，值也是一样的，在这里来给注解的属性起别名，使它们互为别名，意义相同</p><h3 id="返回字符串对应的html"><a href="#返回字符串对应的html" class="headerlink" title="返回字符串对应的html"></a>返回字符串对应的html</h3><pre><code>@Controllerpublic class exampleControl {    @RequestMapping(&quot;/&quot;)    public String Index(Locale locale, Model model) {        Date date = new Date();        DateFormat dateFormat = DateFormat.getDateTimeInstance(DateFormat.LONG, DateFormat.LONG, locale);        String formatDate = dateFormat.format(date);        model.addAttribute(&quot;serverTime&quot;,formatDate);        return &quot;index&quot;;    } }</code></pre><center><img src="http://pictures.aimasa.club/static/images/开始学习spring（二）：试图搭建一个相关项目/result.png"></center><h3 id="返回json格式数据"><a href="#返回json格式数据" class="headerlink" title="返回json格式数据"></a>返回json格式数据</h3><p>如果想用@Controller这个注释可以返回json的话，就要在返回json的方法前面加上@ResponseBody，这样就会在浏览器页面输出json的格式。</p><p>user类：</p><pre><code>public class User {    private String name;    public void setName(String name) {        this.name = name;    }    public String getName() {        return this.name;    }}</code></pre><p>controller层：</p><pre><code>@Controllerpublic class exampleControl {    @RequestMapping(&quot;/&quot;)    @ResponseBody    public User userTest() {        User user = new User();        user.setName(&quot;haha&quot;);        return user;    }}</code></pre><center><img src="http://pictures.aimasa.club/static/images/开始学习spring（二）：试图搭建一个相关项目/result2.png"></center><h2 id="RestController"><a href="#RestController" class="headerlink" title="@RestController"></a>@RestController</h2><p>这个注解和@Controller不一样，是由@Controller和@ResponseBody合在一起的，返回的是一个对象（字符串也可，json格式数据也可等等），其实和@Controller放在类上面，然后在需要返回json格式数据的方法上面加一个@ResponseBody的效果一样，只是一个是整体，一个是局部。（这个可以返回Restful风格—-我也不知道什么风格，但是看到还要配置才能用，所以等以后用到了再来补吧。）</p><h1 id="结果输出"><a href="#结果输出" class="headerlink" title="结果输出"></a>结果输出</h1><center><img src="http://pictures.aimasa.club/static/images/开始学习spring（二）：试图搭建一个相关项目/result.png"></center><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.jianshu.com/p/b534b394dc7a" target="_blank" rel="noopener">关于@Controller和@RestController</a><br><a href="http://blog.didispace.com/springbootweb/" target="_blank" rel="noopener">关于spring boot的学习</a></p>]]></content>
      
      
      <categories>
          
          <category> spring相关 </category>
          
          <category> 搭建项目（初级） </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring相关 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开始学习spring（一）：关于一些基础知识点</title>
      <link href="/2019/04/02/%E5%BC%80%E5%A7%8B%E5%AD%A6%E4%B9%A0spring%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%85%B3%E4%BA%8E%E4%B8%80%E4%BA%9B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
      <url>/2019/04/02/%E5%BC%80%E5%A7%8B%E5%AD%A6%E4%B9%A0spring%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%85%B3%E4%BA%8E%E4%B8%80%E4%BA%9B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<p>现在正式开始学spring了，在此打卡（4.2）</p><a id="more"></a><h1 id="什么是POJOs"><a href="#什么是POJOs" class="headerlink" title="什么是POJOs"></a>什么是POJOs</h1><p>POJO, or Plain Old Java Object, is a normal Java object class (that is, not a JavaBean, EntityBean etc.) </p><p>POJO（plain Old Java Object）它是一个正规的、简单的java对象，包含了业务逻辑处理和持久化逻辑等，但不是JavaBean、EntityBean等，<strong>不具有任何特殊角色和不继承不实现任何其他java框架的类或接口。</strong></p><p>POJO里面是可以包含业务逻辑处理和持久化逻辑，也可以包含类似与JavaBean属性和对属性访问的set和get方法的。</p><p>代码示例：</p><pre><code>package com.demo.spring;public class DbHello { //简单的Java类，称之为POJO，不继承，不实现接口    private DictionaryDAO dao;    public void setDao(DictionaryDAO dao) {        this.dao = dao;    }}</code></pre><h1 id="什么是javabean"><a href="#什么是javabean" class="headerlink" title="什么是javabean"></a>什么是javabean</h1><p>一种特殊又简单的类，</p><ul><li>这个类必须具有一个公共的(public)无参构造函数；</li><li>所有属性私有化（private）；</li><li>私有化的属性必须通过public类型的方法（getter和setter）暴露给其他程序，并且方法的命名也必须遵循一定的命名规范。 </li><li>这个类应是可序列化的。（比如可以实现Serializable 接口，用于实现bean的持久性）</li></ul><h1 id="EJB是什么"><a href="#EJB是什么" class="headerlink" title="EJB是什么"></a>EJB是什么</h1><p>Enterprise JavaBean又叫企业级JavaBean(听说很老了，以后如果用到的话再回来补。)</p><h1 id="依赖注入（DI）"><a href="#依赖注入（DI）" class="headerlink" title="依赖注入（DI）"></a>依赖注入（DI）</h1><p>就是减少依赖。里面牵涉到了依赖倒置（IoC）（这个和设计模式相关，我会找个时间把设计模式的笔记补上。）</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://blog.csdn.net/tonny_guan/article/details/2250134" target="_blank" rel="noopener">关于POJOs</a><br><a href="https://blog.csdn.net/chenchunlin526/article/details/69939337" target="_blank" rel="noopener">关于javabean</a></p>]]></content>
      
      
      <categories>
          
          <category> spring相关 </category>
          
          <category> 基础指示点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring相关 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo博客上传图片</title>
      <link href="/2019/03/29/hexo%E5%8D%9A%E5%AE%A2%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87/"/>
      <url>/2019/03/29/hexo%E5%8D%9A%E5%AE%A2%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87/</url>
      
        <content type="html"><![CDATA[<p>因为之前用插件在本地导入图片到博客上这个方法因为别的缘故，不能很稳定的让图片插入进去……<br>这就要从我开始装数学公式的插件说起了，反正我不想再折腾了，听说本地导入图片的方法也会导致项目过大然后会受github项目仓库的限制，所以我干脆卸载了本地导入图片的这个插件，换成了用七牛云去在线导入图片。当然这个过程不太顺畅。特此记录一下。</p><a id="more"></a><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><p>去七牛云注册了一个账号（前不久他们特地打电话过来关怀一下注册了账号就不见人影的我，我还嘚瑟的和他们说我不用你们的产品，真香）</p><p>然后百度教程</p><h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><p>下载插件</p><pre><code>npm install hexo-qiniu-sync --save</code></pre><p>然后去！！！！hexo下面的_config.yml里面加上qiniu的配置！！！！是hexo下面不是next下面</p><pre><code>#plugins:  #- hexo-qiniu-sync（这部分要删掉的，不然会报错）qiniu:  offline: false  sync: true  bucket: bucket_name # 你在七牛上面设置的存储图片的存储空间的名字  access_key: AccessKey # 你在七牛上面账号的密钥管理的key  secret_key: SecretKey # 你在七牛上面账号的密钥管理的key  dirPrefix: static #自动在你七牛的那个存储空间里面新建一个这个文件夹，听说是加个文件夹比较好  urlPrefix: http://7xqb0u.com1.z0.glb.clouddn.com/static    local_dir: xxx # 当你hexo qiniu s时候，这个文件夹的东西会自动上传到你七牛云里头创建的static文件夹里面。  update_exist: true  image:    folder: images    extend:  js:    folder: js  css:    folder: css</code></pre><p>好了，其他详细的说明下面有指路辽==</p><h1 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h1><p>我用的是</p><pre><code>{% qnimg xxx.png %}</code></pre><p>这种语法，其他的我不想看辽，目前也用不到。</p><h1 id="上传图片到七牛云"><a href="#上传图片到七牛云" class="headerlink" title="上传图片到七牛云"></a>上传图片到七牛云</h1><p>先去博客本地生成的存图的文件夹（上面有注解），然后博客文里面对它进行引用。然后上传图片去七牛云本地时候，就用：</p><pre><code>hexo qiniu s</code></pre><p>这个语法即可。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://lwtang.github.io/2018/11/27/qiniu-store-image/" target="_blank" rel="noopener">我觉得很详细的教程</a></p>]]></content>
      
      
      <categories>
          
          <category> hexo更新配置 </category>
          
          <category> hexo插入图片 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为Next主题添加统计阅读量的功能以及开评论</title>
      <link href="/2019/03/29/%E4%B8%BANext%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E7%BB%9F%E8%AE%A1%E9%98%85%E8%AF%BB%E9%87%8F%E7%9A%84%E5%8A%9F%E8%83%BD%E4%BB%A5%E5%8F%8A%E5%BC%80%E8%AF%84%E8%AE%BA/"/>
      <url>/2019/03/29/%E4%B8%BANext%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E7%BB%9F%E8%AE%A1%E9%98%85%E8%AF%BB%E9%87%8F%E7%9A%84%E5%8A%9F%E8%83%BD%E4%BB%A5%E5%8F%8A%E5%BC%80%E8%AF%84%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="需要准备工作"><a href="#需要准备工作" class="headerlink" title="需要准备工作"></a>需要准备工作</h1><p>我先在leancloud注册了一个账号，用来统计阅读量和去Next主题里设置开放评论用。</p><a id="more"></a><h1 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h1><h2 id="开放评论"><a href="#开放评论" class="headerlink" title="开放评论"></a>开放评论</h2><p>注册完这个账号，然后创建项目（企业开发的话要钱，所以选择个人开发）。接着去Next主题里面设置</p><pre><code>valine:  enable: true  appid:  # your leancloud application appid你点进你leancloud账号里新建的项目里面，然后点进设置，会看到项目自动生成的appid，然后复制过来  appkey: # your leancloud application appkey它的位置就在appid下面一行  notify: false # mail notifier , https://github.com/xCss/Valine/wiki通知  verify: false # Verification code验证码（评论前要输入的）  placeholder: Just go go # comment box placeholder评论框提示你输入的话语  avatar: mm # gravatar style默认头像  guest_info: nick,mail # custom comment header评论前要输入的信息  pageSize: 10 # pagination size一页默认展示的评论数</code></pre><p>然后就能开评论了，因为我刚开始设置输入错了appid和appkey，出现了402错误（反正会提示你哪错了，就不做解释辽。）</p><h3 id="给评论加上邮件通知"><a href="#给评论加上邮件通知" class="headerlink" title="给评论加上邮件通知"></a>给评论加上邮件通知</h3><p>这个是跟着<a href="https://github.com/zhaojun1998/Valine-Admin" target="_blank" rel="noopener">这个博客</a>的方法来的，虽然之前的博客教我怎么用leancloud自带的邮件通知功能去提醒别人评论已回复，但是说是因为是正在开发的功能，还不太稳定，同时还会被要求开验证码，觉得很不方便，所以我换了个博客跟着用第三方的邮件提醒功能。</p><p>因为过程有些繁琐，我也只是跟着它的方法来的，所以就只在这放个链接好了。这是个开源项目。</p><h2 id="添加统计阅读量功能"><a href="#添加统计阅读量功能" class="headerlink" title="添加统计阅读量功能"></a>添加统计阅读量功能</h2><p>在你新建的项目的存储里面，新建一个叫Counter的class，ACL权限选择无限制，里面的appid和appkey和上面获取的是一样的，在这里就不讲是怎么去获取的了。</p><pre><code># Show number of visitors to each article.# You can visit https://leancloud.cn get AppID and AppKey.leancloud_visitors:  enable: true  app_id: #AppID  app_key: #AppKey</code></pre><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://notes.doublemine.me/2015-10-21-%E4%B8%BANexT%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E6%96%87%E7%AB%A0%E9%98%85%E8%AF%BB%E9%87%8F%E7%BB%9F%E8%AE%A1%E5%8A%9F%E8%83%BD.html#%E9%85%8D%E7%BD%AELeanCloud" target="_blank" rel="noopener">参考博客(添加统计阅读量功能)</a></p><p><a href="https://valine.js.org/notify.html" target="_blank" rel="noopener">参考博客(添加统计阅读量功能)</a></p><p><a href="https://github.com/xCss/Valine/wiki/Valine-%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E9%82%AE%E4%BB%B6%E6%8F%90%E9%86%92%E8%AE%BE%E7%BD%AE" target="_blank" rel="noopener">参考博客(让博客支持评论功能)</a></p><p><a href="https://github.com/zhaojun1998/Valine-Admin/blob/master/高级配置.md#自定义邮件模板" target="_blank" rel="noopener">第三方邮件回复自带定时器</a></p>]]></content>
      
      
      <categories>
          
          <category> hexo更新配置 </category>
          
          <category> 添加统计阅读量以及打开评论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>bitSet源码解读</title>
      <link href="/2019/03/14/bitSet%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
      <url>/2019/03/14/bitSet%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/</url>
      
        <content type="html"><![CDATA[<p>因为最近在看二维码相关，在github上拉下来的代码里面有用到bitSet库，所以在试着看源码。<br>看了一段时间，发现就算理清了逻辑结构也不明白什么意思，所以就去网上查了一下bitSet是做什么的。</p><p>都说bitSet是用来对大量的数据进行整理，减少内存负担（我是这样理解的），bitSet是用长整型对数据进行存储，比起用二进制用int对数据进行存储的方法相比，确实可以减少许多内存【这里对内存概念不是很清楚，日后补全。</p><a id="more"></a><h1 id="部分源码分析"><a href="#部分源码分析" class="headerlink" title="部分源码分析"></a>部分源码分析</h1><h2 id="定义好的关键词-大概可以这样叫"><a href="#定义好的关键词-大概可以这样叫" class="headerlink" title="定义好的关键词(大概可以这样叫)"></a>定义好的关键词(大概可以这样叫)</h2><pre><code>/* * bitSet被打包为字的数组 * word的大小选择完全取决于它的性能 */private final static int ADDRESS_BITS_PER_WORD = 6;private final static int BITS_PER_WORD = 1 &lt;&lt; ADDRESS_BITS_PER_WORD;private final static int BIT_INDEX_MASK = BITS_PER_WORD - 1;/* Used to shift left or right for a partial word mask */private static final long WORD_MASK = 0xffffffffffffffffL;</code></pre><p>这是该方法中定义的参数，其中ADDRESS_BITS_PER_WORD=6是指在java中long型是占8个字节，64bit（$\,2^{6}\,=\,64byte\,$）所以对应的二进制就是6.</p><pre><code>private long[] words;private transient int wordsInUse = 0;//已使用的范围的下标private transient boolean sizeIsSticky = false;//表示用户是使用默认的words的大小(64bit)还是自定义</code></pre><h2 id="关于wordIndex的定义"><a href="#关于wordIndex的定义" class="headerlink" title="关于wordIndex的定义"></a>关于wordIndex的定义</h2><p>这里是bit下标对应的word下标的计算过程：</p><pre><code>private static int wordIndex(int bitIndex) {    return bitIndex &gt;&gt; ADDRESS_BITS_PER_WORD;}</code></pre><h2 id="bitSet的构造函数-里面有对words这个数组的定义"><a href="#bitSet的构造函数-里面有对words这个数组的定义" class="headerlink" title="bitSet的构造函数(里面有对words这个数组的定义)"></a>bitSet的构造函数(里面有对words这个数组的定义)</h2><p>其中，bitSet的构造函数是：</p><pre><code>public BitSet(int nbits) {    // nbits can&#39;t be negative; size 0 is OK    if (nbits &lt; 0)        throw new NegativeArraySizeException(&quot;nbits &lt; 0: &quot; + nbits);    initWords(nbits);    sizeIsSticky = true;}private void initWords(int nbits) {    words = new long[wordIndex(nbits-1) + 1];}</code></pre><p>这是在初始化时候给bitSet中的long[] words分配大小时候，就会调用这个构造函数，但是如果初始化时候去输入long[] 这个数组的话，相当于直接定义long[] words这个数组。</p><pre><code>private BitSet(long[] words) {    this.words = words;    this.wordsInUse = words.length;//这里wordsInUse表示的是定义的数组的长度，如果没有定义长度的话，那么这个值默认为零。    checkInvariants();}</code></pre><p>然后还有无参构造，这个就是用默认的数组大小64bit</p><pre><code>public BitSet() {    initWords(BITS_PER_WORD);    sizeIsSticky = false;}</code></pre><h2 id="bitSet的clear方法-对words这个数组进行清零"><a href="#bitSet的clear方法-对words这个数组进行清零" class="headerlink" title="bitSet的clear方法(对words这个数组进行清零)"></a>bitSet的clear方法(对words这个数组进行清零)</h2><p>其中wordsInUse在源码中出现频率非常高，这个参数是用来记录word数组中已经使用了的个数。</p><pre><code>public void clear(int bitIndex) {    if (bitIndex &lt; 0)        throw new IndexOutOfBoundsException(&quot;bitIndex &lt; 0: &quot; + bitIndex);    int wordIndex = wordIndex(bitIndex);//计算这个bit下标实际上是第几个word(Long)    if (wordIndex &gt;= wordsInUse) //如果这个下标不在wordsInUse范围内，那么返回，因为没有必要进行别的操作了。        return;    words[wordIndex] &amp;= ~(1L &lt;&lt; bitIndex); //把words[wordIndex]中的值设置为false（就是清零）因为&lt;&lt;这是左移。取反后就全是零了，再进行与运算，就相当于设置该bitIndex这个位为false，也就是将该位清零。    recalculateWordsInUse();    checkInvariants();}</code></pre><h2 id="关于和clear对应的set方法-对words这个数组进行赋值"><a href="#关于和clear对应的set方法-对words这个数组进行赋值" class="headerlink" title="关于和clear对应的set方法(对words这个数组进行赋值)"></a>关于和clear对应的set方法(对words这个数组进行赋值)</h2><p>这是set函数，就是把bitIndex的对应的位置设置为true，然后返回设置了true的地方的下标：</p><pre><code>public void set(int bitIndex) {    if (bitIndex &lt; 0)        throw new IndexOutOfBoundsException(&quot;bitIndex &lt; 0: &quot; + bitIndex);    int wordIndex = wordIndex(bitIndex);    expandTo(wordIndex);//判断是否需要扩容，如果需要，则进行扩容    words[wordIndex] |= (1L &lt;&lt; bitIndex); // 把这个bitIndex位设置为true    checkInvariants();}</code></pre><h2 id="关于clear每次最后都要用到的recalculateWordsInUse-方法"><a href="#关于clear每次最后都要用到的recalculateWordsInUse-方法" class="headerlink" title="关于clear每次最后都要用到的recalculateWordsInUse()方法"></a>关于clear每次最后都要用到的recalculateWordsInUse()方法</h2><p>更新wordsInUse，判断实际存储大小。</p><pre><code>private void recalculateWordsInUse() {    //遍历words这个数组，直到找到一个是true的地方    int i;    for (i = wordsInUse-1; i &gt;= 0; i--)        if (words[i] != 0)            break;    wordsInUse = i+1; // 就是让wordsInUse的大小更改为实际单词存储量}</code></pre><h2 id="clear和set方法中都会出现的checkInvariants-方法"><a href="#clear和set方法中都会出现的checkInvariants-方法" class="headerlink" title="clear和set方法中都会出现的checkInvariants()方法"></a>clear和set方法中都会出现的checkInvariants()方法</h2><p>判断这个word数组是否溢出，是否需要抛出异常。</p><pre><code>private void checkInvariants() {    assert(wordsInUse == 0 || words[wordsInUse - 1] != 0);    assert(wordsInUse &gt;= 0 &amp;&amp; wordsInUse &lt;= words.length);    assert(wordsInUse == words.length || words[wordsInUse] == 0);}</code></pre><h2 id="克隆方法clone"><a href="#克隆方法clone" class="headerlink" title="克隆方法clone()"></a>克隆方法clone()</h2><pre><code>public Object clone() {    if (! sizeIsSticky)        trimToSize();    try {        BitSet result = (BitSet) super.clone();        result.words = words.clone();        result.checkInvariants();        return result;    } catch (CloneNotSupportedException e) {        throw new InternalError(e);    }}</code></pre><p><a href="https://aimasa.github.io/2019/03/11/%E5%AF%B9%E4%BA%8EQR%E7%94%9F%E6%88%90%E7%9A%84%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/">参考深克隆和浅克隆</a></p><h2 id="trimToSize-方法"><a href="#trimToSize-方法" class="headerlink" title="trimToSize()方法"></a>trimToSize()方法</h2><p>当word的长度或者内容是自定义的情况下则调用的<br>    private void trimToSize() {<br>        if (wordsInUse != words.length) {<br>            words = Arrays.copyOf(words, wordsInUse);//把实际用的数据拷贝出来放进words里面<br>            checkInvariants();<br>        }<br>    }</p><h2 id="get-方法"><a href="#get-方法" class="headerlink" title="get()方法"></a>get()方法</h2><pre><code>public boolean get(int bitIndex) {    if (bitIndex &lt; 0)        throw new IndexOutOfBoundsException(&quot;bitIndex &lt; 0: &quot; + bitIndex);    checkInvariants();    int wordIndex = wordIndex(bitIndex);    return (wordIndex &lt; wordsInUse)        &amp;&amp; ((words[wordIndex] &amp; (1L &lt;&lt; bitIndex)) != 0);//判断数据是否是在使用范围内，该bitIndex位是否为0.}</code></pre><p>就是前面的先是判断下标是否在存储完数据使用过的范围内，如果不在就无效。再判断bitIndex对应的数据位是否是零，如果都是的话返回true。</p><h1 id="参考网站"><a href="#参考网站" class="headerlink" title="参考网站"></a>参考网站</h1><p><a href="http://www.voidcn.com/article/p-bqoyhfid-rv.html" target="_blank" rel="noopener">对bitSet内存存储方法进行详细介绍，但其他的写的不太明了</a></p><p><a href="https://www.cnblogs.com/larryzeal/p/7710389.html" target="_blank" rel="noopener">举例说明了bitSet的用法，内容详细</a></p><p><a href="https://www.jianshu.com/p/91d75bf588b8" target="_blank" rel="noopener">对bitSet源码中的重要方法进行解读</a></p><p><a href="https://www.jianshu.com/p/00b38e7ec2f2" target="_blank" rel="noopener">简要介绍了bitSet里面的类</a></p>]]></content>
      
      
      <categories>
          
          <category> java语法 </category>
          
          <category> bitSet部分源码解读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java的~、|、&lt;&lt;、&gt;&gt;、&gt;&gt;&gt;、^</title>
      <link href="/2019/03/14/java%E7%9A%84/"/>
      <url>/2019/03/14/java%E7%9A%84/</url>
      
        <content type="html"><![CDATA[<p>在看BitSet的源码的时候，我看到了这样一段代码</p><pre><code>words[wordIndex] &amp;= ~(1L &lt;&lt; bitIndex);</code></pre><p>其中~(1L&lt;&lt;bitIndex)我不太明白这是什么意思，所以谷歌了一下,就顺便查了一下日常容易被我弄错的逻辑运算符的用法。</p><a id="more"></a><p>其中</p><p>~：是按位取反运算符</p><p>如：~(10010010)=01101101</p><p>所以这句的意思是在1L左移bitIndex位后，对words[wordIndex]这个第一个bit的位清零</p><h1 id="容易混淆的逻辑运算符"><a href="#容易混淆的逻辑运算符" class="headerlink" title="容易混淆的逻辑运算符"></a>容易混淆的逻辑运算符</h1><p>顺便解释一下|这个的意思</p><pre><code>|：这个是按位或运算&gt;&gt; 是带符号右移，若左操作数是正数，则高位补“0”，若左操作数是负数，则高位补“1”.&lt;&lt; 左移，不管正负数左移时候，最高位都不用管，只需要在后面补零就可以了，和&lt;&lt;&lt;不带符号左移一样，所以就没有不带符号左移&gt;&gt;&gt; 是无符号右移，无论左操作数是正数还是负数，在高位都补“0”</code></pre><p>计算机都是用补码存储数据的。所以当一个数带符号右移或者左移，就是单纯的对该数进行除乘。</p><p>所以在带符号右移或者左移时候，为了保证数字在这个安全的距离能够得出想要的正确结果（乘除2的标准结果），所以int设置的可活动的位移是32，就是左右移32位时候，就会恢复数字的原本值，long设置的可活动位移是64.</p><p>emmmm感觉我语言讲述的不是很清楚，所以附上例子把。</p><pre><code>public class test {    public static void main(String[] args) {        long a=-5;        System.out.println((a &lt;&lt; 64));          // output: -5      }}</code></pre><p>这是long的情况，接下来我放int的例子：</p><pre><code>public class test {    public static void main(String[] args) {        int a=-5;        System.out.println((a &lt;&lt; 32));          // output: -5      }}</code></pre><p>恩，就是这样，我是这样理解的。</p><h1 id="关于"><a href="#关于" class="headerlink" title="关于^"></a>关于^</h1><p>^这个是异或运算符。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.jianshu.com/p/0236b51b903f" target="_blank" rel="noopener">位移参考</a></p>]]></content>
      
      
      <categories>
          
          <category> java语法 </category>
          
          <category> java中的&quot;~&quot; </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>eclipse找不到源码</title>
      <link href="/2019/03/13/eclipse%E6%89%BE%E4%B8%8D%E5%88%B0%E6%BA%90%E7%A0%81/"/>
      <url>/2019/03/13/eclipse%E6%89%BE%E4%B8%8D%E5%88%B0%E6%BA%90%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<p>想看看bitSet的源码，但是点进去却显示Source Not Found</p><a id="more"></a><p>点windows—&gt;preference—&gt;java进入如下界面：</p><center><img src="http://pictures.aimasa.club/static/images/eclipse找不到源码/java_jre.png"></center><p>然后用鼠标点击jre一下，使旁边的Edit获得焦点，然后点击Edit，进入如下界面：</p><center><img src="http://pictures.aimasa.club/static/images/eclipse找不到源码/java_Edit.png"></center><p>最后选中jdk中的src.zip,点击确定，应用即可</p>]]></content>
      
      
      <categories>
          
          <category> eclipse故障 </category>
          
          <category> eclipse点进方法找不到源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> eclipse故障 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对于QR生成的java源码学习(一):关于java语法内容</title>
      <link href="/2019/03/11/%E5%AF%B9%E4%BA%8EQR%E7%94%9F%E6%88%90%E7%9A%84%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
      <url>/2019/03/11/%E5%AF%B9%E4%BA%8EQR%E7%94%9F%E6%88%90%E7%9A%84%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>java的一些基本语法在这里，然后QR生成的源码结构非常清晰，值得一读，所以在这里会零零散散记录一些关于源码里面的一些语法的笔记。</p><a id="more"></a><h1 id="Object-与-Objects-的区别"><a href="#Object-与-Objects-的区别" class="headerlink" title="Object 与 Objects 的区别"></a>Object 与 Objects 的区别</h1><p>Object 是 Java 中所有类的基类，位于java.lang包。</p><p>Objects 是 Object 的工具类，位于java.util包。它从jdk1.7开始才出现，被final修饰不能被继承，拥有私有的构造函数。它由一些静态的实用方法组成，这些方法是null-save（空指针安全的）或null-tolerant（容忍空指针的），用于计算对象的hashcode、返回对象的字符串表示形式、比较两个对象。</p><pre><code>Objects.requireNonNull(text);</code></pre><p>其中源码是这样写的：</p><pre><code>public static &lt;T&gt; T requireNonNull(T obj)</code></pre><p>T：obj的相关类型</p><p>obj：要检查是否为空的参数</p><p>return：如果obj不为空就返回obj，如果是空就返回NullPointerException（空指针异常）</p><h1 id="关于Matcher"><a href="#关于Matcher" class="headerlink" title="关于Matcher"></a>关于Matcher</h1><p>源码是这样的：<br>    NUMERIC_REGEX.matcher(text).matches()</p><p>先把text创建一个匹配此模式的给定输入的匹配器。返回的值再去与NUMERIC_REGEX这个模式(源码中定义的final字段)进行匹配</p><pre><code>public Matcher matcher(CharSequence input)Pattern.matcher(CharSequence input)</code></pre><p>input：需要被转换为匹配模式的字符串</p><p>return：返回这个Pattern的新匹配器</p><pre><code>public boolean matches()</code></pre><p>return：当且仅当整个区域序列匹配此匹配器的模式时才返回true</p><h1 id="bitSet"><a href="#bitSet" class="headerlink" title="bitSet"></a>bitSet</h1><p>一个long长64bit，所以</p><pre><code>private final static int ADDRESS_BITS_PER_WORD = 6;private static int wordIndex(int bitIndex) {    return bitIndex &gt;&gt; ADDRESS_BITS_PER_WORD;}</code></pre><p>其中是在计算bitIndex个bit对应的是第几个long</p><h1 id="assert"><a href="#assert" class="headerlink" title="assert"></a>assert</h1><p>assert()对括号中的条件进行判定，如果条件为真则往下继续运行，条件为假则打印完错误信息然后程序停止运行。</p><h1 id="native"><a href="#native" class="headerlink" title="native"></a>native</h1><p>native是c++开发时候用的，java开发是不用它的，它是用来调用操作系统的一些函数的，然而操作系统的函数就是由c++写的，是没有办法看到它的源码的，java对它只能进行调用。是因为这些函数的实现体在DLL中，JDK的源代码中并不包含。</p><p>因为native是底层实现的，所以它的速度非常快。</p><h1 id="cloneable接口和Serializable接口"><a href="#cloneable接口和Serializable接口" class="headerlink" title="cloneable接口和Serializable接口"></a>cloneable接口和Serializable接口</h1><p>扩展<br>Java语言提供的Cloneable接口和Serializable接口的代码非常简单，它们都是空接口，这种空接口也称为标识接口，标识接口中没有任何方法的定义，其作用是告诉JRE这些接口的实现类是否具有某个功能，如是否支持克隆、是否支持序列化等。——摘自<a href="https://www.cnblogs.com/Qian123/p/5710533.html" target="_blank" rel="noopener">论java中的浅克隆和深克隆</a></p><h1 id="关于序列化"><a href="#关于序列化" class="headerlink" title="关于序列化"></a>关于序列化</h1><p>序列化简单来说就保存对象在内存中的状态,也可以说是实例化变量。这是Java提供的用来保存 Object state，一种保存对象状态的机制。只有实现了serializable接口的类的对象才能被实例化。——-摘自<a href="https://blog.csdn.net/u010486679/article/details/81562344" target="_blank" rel="noopener">序列化是什么</a></p><p>然后我谷歌了一会，理解的意思是，序列化就是把实例化的对象状态用二进制保存到一个文件之类的地方，用的时候再取出来。当然，这个接口只是一种申明，说在这里我要实现对某个实例对象进行序列化，而不包含去序列化东西的一个方法，序列化需要自己去实现。在<a href="https://aimasa.github.io/2019/03/14/bitSet%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/">bitSet</a>里面就implement了Serializable这个接口。</p><p>或者又如以下的代码：</p><pre><code>import java.io.*;   public class Box implements Serializable{       private int width;       private int height;   public void setWidth(int width){       this.width = width;   }   public void setHeight(int height){       this.height = height;   }   public static void main(String[] args){       Box myBox = new Box();       myBox.setWidth(50);       myBox.setHeight(30);       try{           FileOutputStream fs = new FileOutputStream(&quot;foo.ser&quot;);           ObjectOutputStream os = new ObjectOutputStream(fs);           os.writeObject(myBox);           os.close();       }catch(Exception ex){           ex.printStackTrace();       }   }   }   </code></pre><p>如果去掉implements Serializable的话，那么下面的writeObject会报错。</p><p>6、相关注意事项 </p><blockquote><ul><li>当一个父类实现序列化，子类自动实现序列化，不需要显式实现Serializable接口； </li><li>当一个对象的实例变量引用其他对象，序列化该对象时也把引用对象进行序列化； </li><li>并非所有的对象都可以序列化，,至于为什么不可以，有很多原因了,比如： <ul><li>安全方面的原因，比如一个对象拥有private，public等field，对于一个要传输的对象，比如写到文件，或者进行rmi传输 等等，在序列化进行传输的过程中，这个对象的private等域是不受保护的。 </li><li>资源分配方面的原因，比如socket，thread类，如果可以序列化，进行传输或者保存，也无法对他们进行重新的资源分 配，而且，也是没有必要这样实现。 </li></ul></li></ul></blockquote><h1 id="关于克隆clone-方法"><a href="#关于克隆clone-方法" class="headerlink" title="关于克隆clone()方法"></a>关于克隆clone()方法</h1><pre><code>public QrSegment(Mode md, int numCh, BitBuffer data) {//numCh=想在二维码中展示的字的长度。    mode = Objects.requireNonNull(md);    Objects.requireNonNull(data);    if (numCh &lt; 0)        throw new IllegalArgumentException(&quot;Invalid value&quot;);    numChars = numCh;    this.data = data.clone();  // 做一个完整的副本（final data）}</code></pre><p>这个clone()方法因为data是BitBuffer这个类，所以调用了BitBuffer这个类里面写的的clone()方法</p><pre><code>public BitBuffer clone() {    try {        BitBuffer result = (BitBuffer)super.clone();//创建并返回这个对象的一个副本，“副本”的准确含义可能依赖于对象的类。        result.data = (BitSet)result.data.clone();//对BitBuffer这个对象里面成员变量再做一次克隆（到BitSet类中的clone()这个方法去了）        return result;    } catch (CloneNotSupportedException e) {        throw new AssertionError(e);    }}</code></pre><p>为了进行深度克隆，第一次调用的clone()方法时java的Object这个对象的类的克隆，那个属于浅克隆。<br>这个克隆方法是用来创建并返回这个对象的一个副本，“副本”的准确含义可能依赖于对象的类。</p><pre><code>类Object：protected native Object clone() throws CloneNotSupportedException;</code></pre><p>浅克隆方法中，如果克隆对象的成员变量是值类型，那么就会把值原原本本复制一份出来，但是如果成员变量是值引用类型，那么复制出来的也会是地址信息，而引用类型的成员对象并没有复制。所以会对引用类型的成员对象再去做一次克隆，让这个复制出来的东西是可以独立于那个克隆对象的东西。</p><pre><code>类BitSet：public Object clone() {    if (! sizeIsSticky)        trimToSize();    try {        BitSet result = (BitSet) super.clone();        result.words = words.clone();        result.checkInvariants();        return result;    } catch (CloneNotSupportedException e) {        throw new InternalError(e);    }}</code></pre><p>其中result.data指向的是BitSet这个被实例化过一个类，所以去对BitSet data进行了一次克隆，然后data的里面有words的引用，所以再对这个值做一次clone().</p><h1 id="关于在一段数据后循环添加0xEC和0x11这两个数"><a href="#关于在一段数据后循环添加0xEC和0x11这两个数" class="headerlink" title="关于在一段数据后循环添加0xEC和0x11这两个数"></a>关于在一段数据后循环添加0xEC和0x11这两个数</h1><pre><code>for (int padByte = 0xEC; bb.bitLength() &lt; dataCapacityBits; padByte ^= 0xEC ^ 0x11)    bb.appendBits(padByte, 8);</code></pre><p>其中0xEC和0x11是8bit8bit循环添加在bb里面的<br>通过padByte ^= 0xEC ^ 0x11异或，来控制每次添加的8bit，先0xEC然后0x11这样去填充数据编码部分，直到值填满（为什么不能16bit一起填进去？如果16bit的话就会导致填到最后悔有溢出的情况。）</p><h1 id="关于QrSegment这个类"><a href="#关于QrSegment这个类" class="headerlink" title="关于QrSegment这个类"></a>关于QrSegment这个类</h1><p>QrSegment这个类被定义后包括的函数</p><pre><code>public final Mode mode;/** The length of this segment&#39;s unencoded data. Measured in characters for * numeric/alphanumeric/kanji mode, bytes for byte mode, and 0 for ECI mode. * Always zero or positive. Not the same as the data&#39;s bit length. */public final int numChars;// The data bits of this segment. Not null. Accessed through getData().final BitBuffer data;</code></pre><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.cnblogs.com/quiet-snowy-day/p/6387321.html" target="_blank" rel="noopener">关于Object和Objects的区别</a></p><p><a href="https://www.jianshu.com/p/91d75bf588b8" target="_blank" rel="noopener">关于bitSet的源码解读</a></p><p><a href="https://blog.csdn.net/youjianbo_han_87/article/details/2586375" target="_blank" rel="noopener">关于native的用法</a></p><p><a href="https://lixh1986.iteye.com/blog/1767076" target="_blank" rel="noopener">关于序列化的详细说明</a></p>]]></content>
      
      
      <categories>
          
          <category> 对于QR生成的java源码学习 </category>
          
          <category> java语法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python下划线</title>
      <link href="/2019/03/07/python%E4%B8%8B%E5%88%92%E7%BA%BF/"/>
      <url>/2019/03/07/python%E4%B8%8B%E5%88%92%E7%BA%BF/</url>
      
        <content type="html"><![CDATA[<p>在python中经常会遇到下划线”_”的情况</p><a id="more"></a><h1 id="单下划线”-”"><a href="#单下划线”-”" class="headerlink" title="单下划线”_”"></a>单下划线”_”</h1><p>就是无关紧要的变量，就用”_”表示，因为这个值不需要再次引用。</p><p>也可以表达python REPL中最接近一根表达式的结果。</p><h1 id="单前导下划线”-var”"><a href="#单前导下划线”-var”" class="headerlink" title="单前导下划线”_var”"></a>单前导下划线”_var”</h1><p>这是命名约定，就是前面加一个下划线就是暗示别人说这里是私有类，用通配符导入模块时候这个方法（或者变量）是不会跟着包一起导入进去的，但是常规方法调用这个方法（或者变量时候）是不受单个下划线命名约定的影响的。</p><h1 id="单后导下划线”var-”"><a href="#单后导下划线”var-”" class="headerlink" title="单后导下划线”var_”"></a>单后导下划线”var_”</h1><p>就是让该变量名（或者方法名）来避免和python关键词产生冲突。</p><h1 id="双前导下划线”-var”"><a href="#双前导下划线”-var”" class="headerlink" title="双前导下划线”__var”"></a>双前导下划线”__var”</h1><p>当在类上下文中使用，会触发”名称修饰”，由python解释器强制执行。就是在这个双下划线前面加上”_[包名]”</p><center><img src="http://pictures.aimasa.club/static/images/python下划线/qiandao.png"></center><h1 id="双前导和双末尾下划线-“var“"><a href="#双前导和双末尾下划线-“var“" class="headerlink" title="双前导和双末尾下划线 “var“"></a>双前导和双末尾下划线 “<strong>var</strong>“</h1><p>表示python语言定义的特殊方法。</p><p>最好避免在自己的程序中使用以双下划线（“dunders”）开头和结尾的名称，以避免与将来Python语言的变化产生冲突。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://zhuanlan.zhihu.com/p/36173202" target="_blank" rel="noopener">参考网页</a></p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
          <category> 下划线 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python用法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>了解二维码(四)：Reed-Solomon code</title>
      <link href="/2019/03/05/RS-code/"/>
      <url>/2019/03/05/RS-code/</url>
      
        <content type="html"><![CDATA[<p>在前面我们学习了有限域和多项式，可是为什么要学习它们呢，是因为这是像Reed-Solomon这样的纠错码的主要见解：我们不是仅仅将消息视为一系列（ASCII）数字，而是将其视为遵循非常明确的有限域算法规则的多项式.</p><p>也就是通过多项式和有限域算法表示数据，我们给数据添加了一个结构，消息的值仍然不变，而且这个结构还能让我们通过它利用定义良好的数学规则对损坏的消息进行修复操作。</p><a id="more"></a><p>与BCH码类似，Reed-Solomon码通过将表示消息的多项式除以不可约的生成多项式来编码，然后余数是RS码，我们将其附加到原始消息。</p><p>我们之前曾说过，BCH码和大多数其他纠错码背后的原理是使用一个缩小的词典，其中包含非常不同的词，以便最大化词之间的距离，而更长的词有更大的距离：这里的原理是相同的，首先是因为我们用增加距离的附加符号（余数）来延长原始信息，其次因为余数几乎是唯一的（由于精心设计的不可约生成多项式），因此可以通过巧妙的算法利用它来推导部分原始消息。</p><p>总结一下，就像加密一样：我们的生成多项式是我们的编码字典，多项式除法是使用字典（生成多项式）将我们的消息转换为RS代码的运算符。（我们的消息是明文，按多项式除法使用编码字典这个算法而转化为RS代码的运算符）</p><blockquote><p>加密：对原来为明文的文件或者数据按照某种算法进行处理，使之变成一段不可读的代码，这段代码一般被叫做密文。只有在输入对应的密钥之后才能显示出本来内容。</p></blockquote><h1 id="RS生成多项式"><a href="#RS生成多项式" class="headerlink" title="RS生成多项式"></a>RS生成多项式</h1><p>RS码使用类似于BCH码的方法去生成多项式，生成多项式是$\,\left (x-a^{n} \right)\,$的乘积，在QR码中从$\,n=0\,$开始，例如：</p><blockquote><p>$\,g_{4}\, =\, \left (x-\alpha ^{0}  \right )\left (x-\alpha ^{1}  \right )\left (x-\alpha ^{2}  \right )\left (x-\alpha ^{3}  \right )=  01 x^{4} + 0f x^{3} + 36 x^{2} + 78 x + 40\,$</p></blockquote><p>这是一个计算了指定n个纠错符号的RS码需要的生成多项式。</p><pre><code>def rs_generator_poly(nsym):    g = [1]    for i in range(0, nsym):        g = gf_poly_mul(g, [1, gf_pow(2, i)])return g</code></pre><p>这个是根据nsym是判断多项式需要nsym个$\,\left (x-a^{n} \right)\,$的乘积</p><h1 id="多项式除法"><a href="#多项式除法" class="headerlink" title="多项式除法"></a>多项式除法</h1><p>除法中</p> <center><img src="http://pictures.aimasa.club/static/images/RS-code/chufa.png"></center><p>其中除数与商之间的乘法就是用的在有限域中的乘法，如果乘积太大，就mod一个不可约多项式（通常是100011101）然后把得出的乘积控制在256的范围内，再继续往下计算。以下是其中一部分的乘法得出的乘积再放进除法公式中继续运算。</p> <center><img src="http://pictures.aimasa.club/static/images/RS-code/chenfa.png"></center><p>于是得出编码信息为12 34 56 37 e6 78 d9。</p><pre><code>def gf_poly_div(dividend, divisor):    &#39;&#39;&#39;Fast polynomial division by using Extended Synthetic Division and optimized for GF(2^p) computations    (doesn&#39;t work with standard polynomials outside of this galois field, see the Wikipedia article for generic algorithm).&#39;&#39;&#39;    # CAUTION: this function expects polynomials to follow the opposite convention at decoding:    # the terms must go from the biggest to lowest degree (while most other functions here expect    # a list from lowest to biggest degree). eg: 1 + 2x + 5x^2 = [5, 2, 1], NOT [1, 2, 5]    msg_out = list(dividend) # Copy the dividend    #normalizer = divisor[0] # precomputing for performance    for i in range(0, len(dividend) - (len(divisor)-1)):# 因为余数得比除数小。所以就让余数的长度比除数小1.        #msg_out[i] /= normalizer # for general polynomial division (when polynomials are non-monic), the usual way of using        # synthetic division is to divide the divisor g(x) with its leading coefficient, but not needed here.        coef = msg_out[i] # precaching        if coef != 0: # log(0) is undefined, so we need to avoid that case explicitly (and it&#39;s also a good optimization).            for j in range(1, len(divisor)): # in synthetic division, we always skip the first coefficient of the divisior,                                          # because it&#39;s only used to normalize the dividend coefficient                if divisor[j] != 0: # log(0) is undefined                    msg_out[i + j] ^= gf_mul(divisor[j], coef) # 这里因为伽罗瓦域中多项式除法的特殊性，所以直接跳过divisor[0]，因为第一个数是为了量定除数需要乘多少去与被除数求余。然后后面的商就依次根据divisor[j]去确定。                    # (but xoring directly is faster): msg_out[i + j] += -divisor[j] * coef# The resulting msg_out contains both the quotient and the remainder, the remainder being the size of the divisor# (the remainder has necessarily the same degree as the divisor -- not length but degree == length-1 -- since it&#39;s# what we couldn&#39;t divide from the dividend), so we compute the index where this separation is, and return the quotient and remainder.    separator = -(len(divisor)-1)    return msg_out[:separator], msg_out[separator:] # 返回商和余数，再在后面的公式把商加在msg_out数组前头</code></pre><p>然后出来了一个高效的编码方法：</p><pre><code>def rs_encode_msg(msg_in, nsym):    &#39;&#39;&#39;Reed-Solomon 主要的编码功能, 用的是多项式长除法 (algorithm Extended Synthetic Division)&#39;&#39;&#39;    if (len(msg_in) + nsym) &gt; 255: raise ValueError(&quot;Message is too long (%i when max is 255)&quot; % (len(msg_in)+nsym))    gen = rs_generator_poly(nsym)    # Init msg_out with the values inside msg_in and pad with len(gen)-1 bytes (which is the number of ecc symbols).    msg_out = [0] * (len(msg_in) + len(gen)-1)    # Initializing the Synthetic Division with the dividend (= input message     polynomial)    msg_out[:len(msg_in)] = msg_in    # Synthetic division main loop    for i in range(len(msg_in)):        # Note that it&#39;s msg_out here, not msg_in. Thus, we reuse the updated     value at each iteration        # (this is how Synthetic Division works: instead of storing in a temporary register the intermediate values,        # we directly commit them to the output).        coef = msg_out[i]        # log(0) is undefined, so we need to manually check for this case. There&#39;s no need to check        # the divisor here because we know it can&#39;t be 0 since we generated it.        if coef != 0:            # in synthetic division, we always skip the first coefficient of the divisior, because it&#39;s only used to normalize the dividend coefficient (which is here useless since the divisor, the generator polynomial, is always monic)            for j in range(1, len(gen)):                msg_out[i+j] ^= gf_mul(gen[j], coef) # equivalent to msg_out[i+j] += gf_mul(gen[j], coef)    # At this point, the Extended Synthetic Divison is done, msg_out contains the quotient in msg_out[:len(msg_in)]    # and the remainder in msg_out[len(msg_in):]. Here for RS encoding, we don&#39;t need the quotient but only the remainder    # (which represents the RS code), so we can just overwrite the quotient with the input message, so that we get    # our complete codeword composed of the message + code.    msg_out[:len(msg_in)] = msg_in    return msg_out</code></pre><p>这段新的代码把编码和长除法功能加在了一起，语句更简短。</p><p>这种算法速度更快，但在实际应用中仍然很慢，特别是在Python中。 有一些方法可以通过使用各种技巧来优化速度，例如内联（而不是gf_mul，替换为操作以避免调用），通过预计算（gen和coef的对数，甚至通过生成乘法表 -  通过使用内存视图（比如通过更改所有列表），使用静态类型构造（将gf_log和gf_exp分配给array.array（’i’，[…]）），但似乎后者在Python中效果不佳 通过使用PyPy运行它，或者将算法转换为Cython或C扩展名</p>]]></content>
      
      
      <categories>
          
          <category> QR </category>
          
          <category> 了解二维码 </category>
          
          <category> 了解二维码(四)：Reed-Solomon code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> QR </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于对数</title>
      <link href="/2019/03/05/%E5%9F%BA%E4%BA%8E%E5%AF%B9%E6%95%B0/"/>
      <url>/2019/03/05/%E5%9F%BA%E4%BA%8E%E5%AF%B9%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>它是在伽罗瓦域中将2的幂次方计算出来并存在相应的表中，随时查找到2的不同的幂次方对应的不同的值，然后让乘法除法更加简单快捷。所以这个不属于位运算，只是一个算法的代码示例，以后等更了解一点这些了，再好好细分，现在就这样吧</p><a id="more"></a><h1 id="基于对数"><a href="#基于对数" class="headerlink" title="基于对数"></a>基于对数</h1><p>其中的gf_mult_noLUT(x, 2, prim)源自<a href="https://aimasa.github.io/2019/02/20/RussianPeasant/">俄罗斯农夫算法</a></p><h2 id="基于对数的乘法（次幂的加法）"><a href="#基于对数的乘法（次幂的加法）" class="headerlink" title="基于对数的乘法（次幂的加法）"></a>基于对数的乘法（次幂的加法）</h2><p>但是我们怎么样才能知道10001001是α的几次幂呢？这个问题被称为<a href="http://aimasa.github.io/2019/02/27/%E7%A6%BB%E6%95%A3%E5%AF%B9%E6%95%B0/">离散对数</a>（离散对数在一些特殊情况下可以快速计算。然而，通常没有具非常效率的方法来计算它们。）</p><pre><code>gf_exp = [0] * 512 # Create list of 512 elements. In Python 2.6+, consider using bytearraygf_log = [0] * 256def init_tables(prim=0x11d):&#39;&#39;&#39;Precompute the logarithm and anti-log tables for faster computation later, using the provided primitive polynomial.&#39;&#39;&#39;    # prim is the primitive (binary) polynomial. Since it&#39;s a polynomial in the binary sense,    # it&#39;s only in fact a single galois field value between 0 and 255, and not a list of gf values.    global gf_exp, gf_log    gf_exp = [0] * 512 # 就是和gf_log相反的表（gf_log值是下标，gf_log的下标是它的值）    gf_log = [0] * 256 # (把2的幂和它对应的幂会生成的值通过这个下标和对应的值的关系连在一起)    # For each possible value in the galois field 2^8, we will pre-compute the logarithm and anti-logarithm (exponential) of this value    x = 1    for i in range(0, 255):        gf_exp[i] = x # compute anti-log for this value and store it in a table        gf_log[x] = i # compute log at the same time        x = gf_mult_noLUT(x, 2, prim)    # If you use only generator==2 or a power of 2, you can use the following which is faster than gf_mult_noLUT():    #x &lt;&lt;= 1 # multiply by 2 (change 1 by another number y to multiply by a power of 2^y)    #if x &amp; 0x100: #类似于x&gt; = 256，但速度要快得多        #(because 0x100 == 256)        #x ^= prim # substract the primary polynomial to the current value (instead of 255, so that we get a unique set made of coprime numbers), this is the core of the tables generation    #优化：反日志表的大小加倍，这样我们就不需要修改255来保持在边界内    #（因为我们主要使用这个表来增加两个GF数，不再增加）。    for i in range(255, 512):        gf_exp[i] = gf_exp[i - 255]    return [gf_log, gf_exp]</code></pre><p>这段代码会生成一个表，这个表里面是0-256对应的2的这些次幂的答案，然后如果要计算乘法的话，对方给出了一个大值然后用gf_log[x]找出对应的次幂，再进行加法运算。最后的一个循环是为了防止运算出来的幂相加的值超过255，所以把上限改成了512.（$\,2^{255}\,=\,00000001$然后又开始新一轮的循环2次幂。）</p><pre><code>def gf_mul(x,y):if x==0 or y==0:    return 0return gf_exp[gf_log[x] + gf_log[y]]#这样就可以不用再多一步%255去防止gf_exp溢出了的运算了。</code></pre><h2 id="基于对数的除法"><a href="#基于对数的除法" class="headerlink" title="基于对数的除法"></a>基于对数的除法</h2><pre><code>def gf_div(x,y):    if y==0:        raise ZeroDivisionError()    if x==0:        return 0    return gf_exp[(gf_log[x] + 255 - gf_log[y])% 255]</code></pre><p>如果x对应的次幂比y对应的要小的话，加上255找到之后对应的幂还是和本身一样，最后求255的模的意思是让幂保持在0-255之间。0-254内的数值与255-510内的值</p><h2 id="基于对数的次幂"><a href="#基于对数的次幂" class="headerlink" title="基于对数的次幂"></a>基于对数的次幂</h2><pre><code>def gf_pow(x, power):    return gf_exp[(gf_log[x] * power) % 255]</code></pre><h2 id="基于对数的导数"><a href="#基于对数的导数" class="headerlink" title="基于对数的导数"></a>基于对数的导数</h2><pre><code>def gf_inverse(x):    return gf_exp[255 - gf_log[x]] # gf_inverse(x) == gf_div(1, x)</code></pre><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://en.wikiversity.org/wiki/Reed%E2%80%93Solomon_codes_for_coders" target="_blank" rel="noopener">参考网页</a></p><p><a href="https://www.felix021.com/blog/read.php?2116" target="_blank" rel="noopener">参考网页</a></p>]]></content>
      
      
      <categories>
          
          <category> 位运算代码示例 </category>
          
          <category> 基于对数乘除法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基于对数乘除法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多项式</title>
      <link href="/2019/03/05/%E5%A4%9A%E9%A1%B9%E5%BC%8F/"/>
      <url>/2019/03/05/%E5%A4%9A%E9%A1%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>其实这个不是位运算，只是把作为多项式的加法和乘法代码示例来进行解释，这是在伽罗瓦域中的加法和乘法，所以其中的加法和乘法均为异或算法。</p><p>其中的乘法是根据基于对数的乘法来进行的计算，是把被乘数转换成2的幂次方，然后将2的幂次方直接进行相加，最后根据得出的幂次方相加的结果去得出的对数表中找到相应的结果。</p><a id="more"></a><h1 id="多项式"><a href="#多项式" class="headerlink" title="多项式"></a>多项式</h1><p>其中gf_mul(p[i], x)该方法源自<a href="https://aimasa.github.io/2019/03/05/%E5%9F%BA%E4%BA%8E%E5%AF%B9%E6%95%B0/">基于对数的乘法</a></p><h2 id="多项式的加法"><a href="#多项式的加法" class="headerlink" title="多项式的加法"></a>多项式的加法</h2><pre><code>def gf_poly_add(p,q):    r = [0] * max(len(p),len(q))    for i in range(0,len(p)):        r[i+len(r)-len(p)] = p[i]        for i in range(0,len(q)):            r[i+len(r)-len(q)] ^= q[i]#让在伽罗瓦域内的q和p两个多项式相加return r</code></pre><p>多项式相加就是幂次相同的系数相加，所以该方法将两个多项式的不同幂的系数均按幂次大小顺序排序，然后按顺序进行相加。</p><h2 id="多项式的乘法（和一个普通系数的乘法）"><a href="#多项式的乘法（和一个普通系数的乘法）" class="headerlink" title="多项式的乘法（和一个普通系数的乘法）"></a>多项式的乘法（和一个普通系数的乘法）</h2><pre><code>def gf_poly_scale(p,x):    r = [0] * len(p)    for i in range(0, len(p)):        r[i] = gf_mul(p[i], x)# 该方法见基于对数的乘法部分内return r</code></pre><p>就是按照普通多项式乘法进行相乘，让x系数和多项式中各级幂的系数在伽罗瓦域内和x相乘</p><h2 id="两个多项式间的乘法"><a href="#两个多项式间的乘法" class="headerlink" title="两个多项式间的乘法"></a>两个多项式间的乘法</h2><pre><code>def gf_poly_mul(p,q):    &#39;&#39;&#39;Multiply two polynomials, inside Galois Field&#39;&#39;&#39;    # Pre-allocate the result array    r = [0] * (len(p)+len(q)-1)    # Compute the polynomial multiplication (just like the outer product of two vectors,    # we multiply each coefficients of p with all coefficients of q)    for j in range(0, len(q)):        for i in range(0, len(p)):            r[i+j] ^= gf_mul(p[i], q[j]) # equivalent to: r[i + j] = gf_add(r[i+j], gf_mul(p[i], q[j]))    # -- you can see it&#39;s your usual polynomial multiplicationreturn r</code></pre><p>就是两个普通的多项式相乘时候，系数分别相乘（比如$\,\left (5x^{2}+4x+1 \right )\cdot \left ( 7x^{2}+9x+1 \right )\,$）其中$\,\left (7x^{2}  \right)  \cdot \left ( 5x^{2}+4x+1  \right )\,$以此类推……</p><p>然后其中i+j的意味着相同次幂的系数，所以在该代码中对他们进行了相加（异或）。</p><p>在该代码中展示的仅仅是在伽罗瓦域中的系数的乘法然后再相加，所以用的是循环i和j，让所有的系数都能互相乘并且相加。</p><h2 id="秦九韶算法"><a href="#秦九韶算法" class="headerlink" title="秦九韶算法"></a>秦九韶算法</h2><p>这也是对多项式求解的一种算法，就是从$\,f \left ( x \right)\,=\,a_{n}x^{n}+a_{n-1}x^{n-1}+…+a_{2}x^{2}+a_{1}x+1 \,$中快速得出$\,f \left ( x \right)\,$的解。 <a href="https://aimasa.github.io/2019/03/04/%E7%A7%A6%E4%B9%9D%E9%9F%B6%E7%AE%97%E6%B3%95/">详细介绍</a></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://en.wikiversity.org/wiki/Reed%E2%80%93Solomon_codes_for_coders" target="_blank" rel="noopener">参考网页</a></p><p><a href="https://www.felix021.com/blog/read.php?2116" target="_blank" rel="noopener">参考网页</a></p>]]></content>
      
      
      <categories>
          
          <category> 位运算代码示例 </category>
          
          <category> 多项式的加法和乘法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多项式的加法和乘法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>秦九韶算法</title>
      <link href="/2019/03/04/%E7%A7%A6%E4%B9%9D%E9%9F%B6%E7%AE%97%E6%B3%95/"/>
      <url>/2019/03/04/%E7%A7%A6%E4%B9%9D%E9%9F%B6%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>用秦九韶算法和普通的计算多项式的算法比起来更为快捷，效率更高<br><a id="more"></a></p><h1 id="算法介绍"><a href="#算法介绍" class="headerlink" title="算法介绍"></a>算法介绍</h1><p>普通方法对于多项式（$\,a_{n}x^{n}+a_{n-1}x^{n-1}+…+a_{2}x^{2}+a_{1}x+1\,$）的解是把x的幂次方得出的结果和a乘起来，最后再相加</p><p>而秦九韶的解法是将多项式中的x一层一层的提取出来：$\left ( \left (\left ( a_{n}x+a_{n-1} \right )x+a_{n-2}  \right )x+… \right )x+1$.</p><p>也就相当于在程序中用递归：</p><blockquote><p>$\,f_{1}\,=\,a_{n}x+a_{n-1}\,$</p><p>$\,f_{2}\,=\,f_{1}x+a_{n-2}\,$</p><p>……</p><p>$\,f_{n-1}=f_{n-2}x+a_{1}\,$</p><p>$\,f_{n}=f_{n-1}x+1\,$ </p></blockquote><p>$\,f_{n}\,$为所求</p><p>自然效率会比普通的算法要快许多。</p><h1 id="代码用例"><a href="#代码用例" class="headerlink" title="代码用例"></a>代码用例</h1><pre><code>def gf_poly_eval(poly, x):    &#39;&#39;&#39;基于有限域的秦九韶算法的代码（所以乘法和加法都是一样的意思--都是异或）.&#39;&#39;&#39;    y = poly[0]    for i in range(1, len(poly)):        y = gf_mul(y, x) ^ poly[i]return y</code></pre><p>代码中的gf_mul(x,y)是基于对数表中的乘法中，见<a href="https://aimasa.github.io/2019/01/23/BCH/">笔记</a>的基于对数表的乘法该处。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://zh.wikipedia.org/wiki/%E7%A7%A6%E4%B9%9D%E9%9F%B6%E7%AE%97%E6%B3%95" target="_blank" rel="noopener">参考维基百科</a></p>]]></content>
      
      
      <categories>
          
          <category> 伽罗瓦域/有限域 </category>
          
          <category> 秦九韶算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 秦九韶算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多源异构数据采集及实体链接算法研究</title>
      <link href="/2019/03/01/%E5%A4%9A%E6%BA%90%E5%BC%82%E6%9E%84%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86%E5%8F%8A%E5%AE%9E%E4%BD%93%E9%93%BE%E6%8E%A5%E7%AE%97%E6%B3%95%E7%A0%94%E7%A9%B6/"/>
      <url>/2019/03/01/%E5%A4%9A%E6%BA%90%E5%BC%82%E6%9E%84%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86%E5%8F%8A%E5%AE%9E%E4%BD%93%E9%93%BE%E6%8E%A5%E7%AE%97%E6%B3%95%E7%A0%94%E7%A9%B6/</url>
      
        <content type="html"><![CDATA[<p>老师叫我帮她整理两个方向的资料，我就边整理边做点笔记好了，多了解一点东西总是好的。</p><a id="more"></a><h1 id="多源异构数据"><a href="#多源异构数据" class="headerlink" title="多源异构数据"></a>多源异构数据</h1><p>就是不同数据库中的数据，在企业信息化建设过程中，因为各业务系统建设和实施数据管理系统的阶段性、技术性和一些其他因素的影响，让企业在发展过程中大量采用不同存储方式的业务数据，而且采用的数据管理系统也不一样，从简单的文件数据库到复杂的网络数据库，它们构成了企业的异构数据源。</p><h1 id="实体链接"><a href="#实体链接" class="headerlink" title="实体链接"></a>实体链接</h1><p>一个实体可以用多个文本表达（多词一义），同一文本可能表达出多个不同的实体（一词多义）。通过进行实体链接，就是让文本中的实体指称和知识库中的实体进行链接。能够让文本中的数据转化为带有实体标注的文本。进而帮助人和计算机理解文本的具体含义。</p><p>个人理解是实体链接就是让文本中的一个词对应一个具体的实体</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://zhuanlan.zhihu.com/p/30940524" target="_blank" rel="noopener">参考博客</a></p><p><a href="https://bbs.csdn.net/topics/390383619" target="_blank" rel="noopener">参考帖子</a></p><p><a href="https://www.1xuezhe.exuezhe.com/Qk/art/585002?dbcode=1&amp;flag=2" target="_blank" rel="noopener">参考文献</a></p>]]></content>
      
      
      <categories>
          
          <category> 多源异构数据采集及实体链接算法研究 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多源异构数据采集及实体链接算法研究 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>markdown插入公式</title>
      <link href="/2019/02/27/markdown%E6%8F%92%E5%85%A5%E5%85%AC%E5%BC%8F/"/>
      <url>/2019/02/27/markdown%E6%8F%92%E5%85%A5%E5%85%AC%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>实测在<a href="https://www.jianshu.com/p/054484d0892a" target="_blank" rel="noopener">该博客</a>中提到的四种在markdown中插入公式的办法</p><a id="more"></a><h1 id="办法1：借助在线公式编辑器"><a href="#办法1：借助在线公式编辑器" class="headerlink" title="办法1：借助在线公式编辑器"></a>办法1：借助<a href="https://www.codecogs.com/latex/eqneditor.php" target="_blank" rel="noopener">在线公式编辑器</a></h1><center><img src="http://pictures.aimasa.club/static/images/markdown插入公式/fangfa1_1.png"></center><center>=======></center><center><img src="http://pictures.aimasa.club/static/images/markdown插入公式/fangfa1_2.png"></center><center><img src="http://pictures.aimasa.club/static/images/markdown插入公式/fangfa1_3.png"></center><h1 id="办法2：借助Google-Chart服务器"><a href="#办法2：借助Google-Chart服务器" class="headerlink" title="办法2：借助Google Chart服务器"></a>办法2：借助Google Chart服务器</h1><p>在需要插入公式的位置键入如下代码，并在“在此插入Latex公式”中改写成公式即可。</p><pre><code>&lt;img src=&quot;http://chart.googleapis.com/chart?cht=tx&amp;chl= 在此插入Latex公式&quot; style=&quot;border:none;&quot;&gt;</code></pre><center><img src="http://pictures.aimasa.club/static/images/markdown插入公式/fangfa2.png"></center><h1 id="办法3：借助forkosh服务器"><a href="#办法3：借助forkosh服务器" class="headerlink" title="办法3：借助forkosh服务器"></a>办法3：借助forkosh服务器</h1><p>与上一方法类似</p><center><img src="http://pictures.aimasa.club/static/images/markdown插入公式/fangfa3.png"></center><h1 id="办法4：借助MathJax引擎！"><a href="#办法4：借助MathJax引擎！" class="headerlink" title="办法4：借助MathJax引擎！"></a>办法4：借助MathJax引擎！</h1><p>在首部添加脚本代码，然后就可以在该文内像在latex中一样书写公式</p><center><img src="http://pictures.aimasa.club/static/images/markdown插入公式/fangfa4.png"></center><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>只有方法1和方法4可行，方法1代码多，但是书写简单，无需记住数学公式的参考代码，但是达不到我想要的效果。方法4简单方便。只要你记住数学公式的书写代码，就没有问题了。</p><p>但是他们都是会让数学公式独占一行，所以我谷歌了一下怎么办，根据<a href="http://stevenshi.me/2017/06/26/hexo-insert-formula/" target="_blank" rel="noopener">这篇博文</a>去更改了我博客hexo框架和next主题的设置</p><p>（还有根着<a href="https://blog.csdn.net/wgshun616/article/details/81019687" target="_blank" rel="noopener">这个博文</a>改了一下渲染什么的，我也不知道有什么用.）</p><h2 id="安装和配置"><a href="#安装和配置" class="headerlink" title="安装和配置"></a>安装和配置</h2><p>下载插件</p><pre><code>$ npm install hexo-math --save</code></pre><p>在站点配置文件 _config.yml 中添加：</p><pre><code>math:  engine: &#39;mathjax&#39; # or &#39;katex&#39;  mathjax:    # src: custom_mathjax_source    config:      # MathJax config</code></pre><p>在 next 主题配置文件中 themes/next-theme/_config.yml 中将 mathJax 设为 true:</p><pre><code># MathJax Supportmathjax:  enable: true  per_page: false  cdn: //cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML</code></pre><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>就是在数学公式的书写代码前面后面各加一个$符号。</p><p>然后弄完了之后我的有些图片能显示有些图片不能，我也不知道为什么，所以我经过激烈的心理斗争，决定，算了，不用这个方法了，前面的方法也挺好用的。</p><h2 id="最后的使用办法"><a href="#最后的使用办法" class="headerlink" title="最后的使用办法"></a>最后的使用办法</h2><p>我找到了<a href="https://blog.csdn.net/emptyset110/article/details/50123231" target="_blank" rel="noopener">这个博客</a><br>根据它里面教我的去执行</p><pre><code>npm install hexo-math --savehexo math install</code></pre><p>然后更改</p><p>用编辑器打开marked.js（在./node_modules/marked/lib/中）</p><p>Step 1:<br>    escape: /^\([\`*{}[]()# +-.!_&gt;])/,</p><p>替换成</p><pre><code>escape: /^\\([`*\[\]()# +\-.!_&gt;])/,</code></pre><p>这一步是在原基础上取消了对\\,\{,\}的转义(escape)</p><p>Step 2:<br>    em: /^\b_((?:<sup><a href="#fn__" id="reffn__">_</a></sup>|__)+?)_\b|^*((?:**|[\s\S])+?)*(?!*)/,</p><p>替换成</p><pre><code>em:/^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,</code></pre><p>这样一来MathJax就能与marked.js共存了。</p><p>就这样，我又能很好地插入数学公式了。</p><h1 id="数学公式"><a href="#数学公式" class="headerlink" title="数学公式"></a>数学公式</h1><p><a href="https://juejin.im/post/5a6721bd518825733201c4a2" target="_blank" rel="noopener">参考文档</a></p><p><a href="https://link.juejin.im/?target=http%3A%2F%2Ffiles.cnblogs.com%2Fhoukai%2FLATEX%25E6%2595%25B0%25E5%25AD%25A6%25E7%25AC%25A6%25E5%258F%25B7%25E8%25A1%25A8.rar" target="_blank" rel="noopener">该文档提供的下载地址</a></p><p>如果该链接打不开，请进入参考文档去寻找正确地址。</p><p><a href="https://ranmaosong.github.io/2017/11/29/hexo-support-mathjax/" target="_blank" rel="noopener">用mathjax对公式进行渲染</a></p><p><a href="https://www.codecogs.com/latex/eqneditor.php" target="_blank" rel="noopener">公式编辑器</a></p>]]></content>
      
      
      <categories>
          
          <category> hexo更新配置 </category>
          
          <category> markdown插入公式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>离散对数(Discrete logarithm)</title>
      <link href="/2019/02/27/%E7%A6%BB%E6%95%A3%E5%AF%B9%E6%95%B0/"/>
      <url>/2019/02/27/%E7%A6%BB%E6%95%A3%E5%AF%B9%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>设g为素数p的模循环群的<a href="https://aimasa.github.io/2019/02/26/%E5%8E%9F%E6%A0%B9/">原根</a>,那就意思是$\, g\, $的循环群的大小$\,=\, \Phi \left ( p \right )$,又因为$\,p\,$是素数，所以循环群大小为：$\, \left ( p\,-\,1 \right )$</p><p>对任意的a，计算： $b=g^{a} mod  p$正推是很容易的，但是在只知道b而去求a的情况下，是非常难的。</p><p>因为a、b均为整数，不像实数那么“连续”，故称离散对数。</p><a id="more"></a><p><a href="https://blog.csdn.net/chen77716/article/details/7106485" target="_blank" rel="noopener">参考博文</a></p><h1 id="加密过程"><a href="#加密过程" class="headerlink" title="加密过程"></a>加密过程</h1><h2 id="加密方法1—标准Diffie-Hellman算法"><a href="#加密方法1—标准Diffie-Hellman算法" class="headerlink" title="加密方法1—标准Diffie-Hellman算法"></a>加密方法1—标准Diffie-Hellman算法</h2><p>A发送消息m（0&lt;m&lt;p）给B</p><p>A选取一个随机数$\, c\, $作为自己的私钥，然后这个随机数$\, 1\, &lt; \, c\, &lt; \, q\, $并且与$\, q\,-\,1\, $互质。接着计算$\,X\, = \, m^{c} \, mod \, q\,$，把X的值发送给A</p><p>B选取一个随机数$\, d\, $作为自己的私钥，这个随机数$\, 1\, &lt; \, c\, &lt; \, q\, $并且与$\, q\,-\,1\, $互质。然后拿着从A处得到的X值进行计算：$\, Y\, = \, X^{b}\, mod \, p\, $，得到Y值（其中可以把公式拆开来变成$ \, m^{cd} \, mod \, q\,$）并且把得到的Y发给A</p><p>A对从B处发来的Y进行计算：$\, Z\, =\, Y^{-c}\, $（可以把公式拆开得到：$ \, m^{cd\left ( -c \right )} \, mod \, q\,$，因为其中$\,cc^{-1}\,≡\,1(mod \,p-1)$，因为(c,p-1)=1，所以逆元素$c^{-1}$必存在。<a href="http://aimasa.github.io/2019/02/18/GaloisFields/">参见群的定义</a>）</p><p>然后把Z值发回给B，让B根据这个值得到被加密的消息m。$z^{d^{-1}}=m^{dd^{-1}}\,mod\,p= m\,$因为m&lt;p-1。$dd^{-1}$与前面$cc^{-1}$同理</p><h2 id="加密方法2—T-ElGamal算法"><a href="#加密方法2—T-ElGamal算法" class="headerlink" title="加密方法2—T. ElGamal算法"></a>加密方法2—T. ElGamal算法</h2><p>因为比较容易懂，所以就不打出来了，直接贴截图把，也可以进<a href="https://blog.csdn.net/chen77716/article/details/7106485" target="_blank" rel="noopener">参考博文</a>直接看。</p><center><img src="http://pictures.aimasa.club/static/images/离散对数/fangfa1.png"></center><p>这里只需要进行两次通信，但是通信的内容和加密方法1比起来要多了一个群元素。</p><h2 id="加密方法3—密钥交换"><a href="#加密方法3—密钥交换" class="headerlink" title="加密方法3—密钥交换"></a>加密方法3—密钥交换</h2><p>它就是相当于两边共享一个秘钥，然后用这个秘钥对信息进行加解密（对称加密）</p><center><img src="http://pictures.aimasa.club/static/images/离散对数/fangfa2.png"></center><p>这个方法比较容易被程序实现。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这个加密算法难被破解的原因在于$b=g^{a} mod  p$在这个公式中，只知道其中的b，p就算知道g，反推a也是非常的难，因为数据量之大，是没办法运算完成的。</p>]]></content>
      
      
      <categories>
          
          <category> 离散对数 </category>
          
          <category> 离散对数加密解密 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 离散对数加密解密 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>双射单射满射</title>
      <link href="/2019/02/26/%E5%8F%8C%E5%B0%84%E5%8D%95%E5%B0%84%E6%BB%A1%E5%B0%84/"/>
      <url>/2019/02/26/%E5%8F%8C%E5%B0%84%E5%8D%95%E5%B0%84%E6%BB%A1%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<p>在数学定义中，单射、满射和双射是指根据其定义域和陪域的关联方式所区分的三类函数。</p><p>单射：指将不同的变量映射到不同的值的函数。(也就是一对一)</p><p>满射：指陪域等于值域的函数。即：对陪域中任意元素，都存在至少一个定义域中的元素与之对应。(每个定义域都有相应的值域与之对应—可多对一或一对一)</p><p>双射（也称一一对应或一一映射）：既是单射又是满射的函数。直观地说，一个双射函数形成一个对应，并且每一个输入值都有正好一个输出值以及每一个输出值都有正好一个输入值。 （每个定义域都有相应的值域与之对应—一对一）</p><a id="more"></a><p><center><img src="http://pictures.aimasa.club/static/images/双射单射满射/she.png"></center></p><p>——————-<a href="https://zh.wikipedia.org/wiki/%E5%8D%95%E5%B0%84%E3%80%81%E5%8F%8C%E5%B0%84%E4%B8%8E%E6%BB%A1%E5%B0%84" target="_blank" rel="noopener">摘自维基百科</a></p>]]></content>
      
      
      <categories>
          
          <category> 数学基础知识 </category>
          
          <category> 双射单射满射 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双射单射满射 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>原根</title>
      <link href="/2019/02/26/%E5%8E%9F%E6%A0%B9/"/>
      <url>/2019/02/26/%E5%8E%9F%E6%A0%B9/</url>
      
        <content type="html"><![CDATA[<p>其中，如果正整数$(a,m)=1$和正整数$\,d\; \left ( d\leqslant m\, -\, 1 \right )$满足$a^{d}\,\equiv 1(mod m)$那么满足这个式子的正整数$\,d\,$最小正整数$\,x\,$，$\,x\,=\,Ord_{m}\left ( a \right )$。如果$\,x\,=\,\Phi \left ( m \right )$那么就说这个$\,a\,$是$\,m\,$的原根<br><a id="more"></a></p><p><a href="https://zh.wikipedia.org/wiki/%E5%8E%9F%E6%A0%B9" target="_blank" rel="noopener">参考定理</a></p><center><img src="http://pictures.aimasa.club/static/images/原根/yuangen.png"></center><p>就是在值最小的时候满足欧拉定理的式子，同时还要和欧拉函数的值一样,才能称作式子中这两个互质的数，一个是模另一个原根。</p><p>所以，对于任意数m可以有很多个原根，也可以一个原根也没有（其中a是可变的）</p><p>存在原根的模乘法群称为循环群。</p><p>原根性质：</p><center><img src="http://pictures.aimasa.club/static/images/原根/xinzhi.png"></center>]]></content>
      
      
      <categories>
          
          <category> 离散对数 </category>
          
          <category> 原根 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原根 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>互质关系</title>
      <link href="/2019/02/22/MutRela/"/>
      <url>/2019/02/22/MutRela/</url>
      
        <content type="html"><![CDATA[<p>互质又称是互素，两个整数的公约数除了它们本身的乘积外只有1，那么称这两个数互质。</p><a id="more"></a><p><a href="http://www.wikiwand.com/zh-sg/%E4%BA%92%E8%B3%AA" target="_blank" rel="noopener">参考资料</a><br>通过观察可以发现在以下的情况下，两个数一定会互质。</p><ul><li>两个不同的素数一定互质。例如，2与7、13与19。</li><li>一个素数，另一个不为它的倍数，这两个数互质。例如，3与10、5与 26。</li><li>1和任何一个自然数都互质。如1和9908。</li><li>2的幂和任何一个奇数都互质。如32和75、256与315。</li><li>相邻两个自然数互质。如15与16。</li><li>相邻两个奇数互质。如49与51。</li><li>较大数是素数，则两个数互质。如97与88。</li><li>两数和是素数，则两个数互质。如52与45。</li><li>两数差是素数，两个数都不是两数差的倍数，则两个数互质。如140与171。</li><li>两数积是无平方数约数的数，则两个数互质。如154与195。</li><li>较大数除以较小数的余数是1或-1，则两个数互质。如440与63。</li><li><strong>辗转相除法</strong>。如255与182。255－182=73，182－（73×2）=36，73－（36×2）=1，则（255，182）=1。故这两数互质。</li><li><p><strong>p是大于1的整数，则p和p-1构成互质关系</strong>，比如57和56。</p></li><li><p><strong>p是大于1的奇数，则p和p-2构成互质关系</strong>，比如17和15。</p></li><li>一个数的素因数都小于某数，另一个数素因数都大于同一个数，则两个数互质。如180与2431、5040与4301。</li><li>两数都是合数（二数差较大），较小数所有的素因数，都不是较大数的因数，这两个数互质。如357与715，357=3×7×17，而3、7和17都不是715的因数，故这两数互质。</li><li>两数都是合数（二数差较小），这两数之差的所有素因数都不是较小数的因数，这两个数互质。如85和78。85－78=7，7不是78的因数，故这两数互质。</li></ul><p><a href="https://zhidao.baidu.com/question/105237827.html" target="_blank" rel="noopener">素因数</a>：一个整数会有很多个因数，其中因数约数只能由1和他本身相乘产生。</p><p><a href="https://zh.wikipedia.org/wiki/%E5%90%88%E6%95%B0" target="_blank" rel="noopener">合数</a>：（又叫合成数）每个大于1的整数如果不是质数就是合数。</p><p>1不是素数，最小的质数是2</p>]]></content>
      
      
      <categories>
          
          <category> RSA公钥加密 </category>
          
          <category> 互质关系（互素关系） </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 互质关系（互素关系） </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>欧拉函数</title>
      <link href="/2019/02/22/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/"/>
      <url>/2019/02/22/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>欧拉函数：</p><p>若正整数 a , n 互质，则  aφ(n) ≡ 1(mod n)   其中 φ(n) 是欧拉函数（1~n) 与 n 互质的数。</p><p>欧拉定理：</p><p>如果两个正整数互质，则n的欧拉函数φ(n) 可以让下面的等式成立</p><a id="more"></a><p><a href="https://www.kancloud.cn/kancloud/rsa_algorithm/48487" target="_blank" rel="noopener">参考资料</a></p><p><a href="https://aimasa.github.io/2019/02/22/MutRela/">互质关系</a></p><h2 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h2><p>用来思考的问题：<br>任意给定正整数n，请问在小于等于n的正整数之中，有多少个与n构成互质关系？（比如，在1到8之中，有多少个数与8构成互质关系？）</p><p>n=1时候，φ(n=1)=1,因为1和任何数互质。</p><p>n为素数的时候，φ(n)=n-1，因为素数和每个小于自己的数都互质。</p><p>n=p^k,p为素数时候，p^k中存在很多和p有倍数关系的数字，1 x p，2 x p，……p^(k-1) x p。由列出的公式看出，一共有p^(k-1)个和p有倍数关系的数字，所以φ(p^k)=p^(k)-p^(k-1)</p><p>如果n能分解成两个互质的整数之积，n=p1 x p2,则φ(n) = φ(p1p2) = φ(p1)φ(p2).(即积的欧拉函数等于各个因子的欧拉函数之积。比如，φ(56)=φ(8×7)=φ(8)×φ(7)=4×6=24。)</p><p>以上这四个方法，可以任意运用来得出自己想要的结果</p><h2 id="欧拉定理"><a href="#欧拉定理" class="headerlink" title="欧拉定理"></a>欧拉定理</h2><p>如果正整数a和n互为质数，那么n的欧拉公式φ(n)可以让下列公式成立：</p><center><img src="http://pictures.aimasa.club/static/images/欧拉函数/Eular.png"></center><p>这样，a^(φ(n))减掉1就能被n整除了。</p><p>而且，欧拉定理的特殊情况就是<a href="https://aimasa.github.io/2019/02/20/discreteLogarithm/">费马小定理</a></p><h2 id="模反元素"><a href="#模反元素" class="headerlink" title="模反元素"></a>模反元素</h2><p>就是正整数a和n互为质数，那么一定存在b使得</p><p>ab ≡ 1(mod n)</p>]]></content>
      
      
      <categories>
          
          <category> RSA公钥加密 </category>
          
          <category> 欧拉函数&amp;欧拉定理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 欧拉函数&amp;欧拉定理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>同余</title>
      <link href="/2019/02/21/%E5%90%8C%E4%BD%99/"/>
      <url>/2019/02/21/%E5%90%8C%E4%BD%99/</url>
      
        <content type="html"><![CDATA[<p>同余是数论中的一种等价关系。符号是≡，有两个正整数，一起除以一个相同的正整数，得出的余数一样的话，那么称这两个正整数同余。</p><a id="more"></a><p><a href="https://zh.wikipedia.org/wiki/%E5%90%8C%E9%A4%98" target="_blank" rel="noopener">参考维基百科</a></p><p>就是，正整数a,b取模c的值是一样的，那么我们可以这样去表示它：</p><pre><code>a ≡ b(mod c)</code></pre><p>可以读作a同余于b模c。</p><h1 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h1><h2 id="整除性"><a href="#整除性" class="headerlink" title="整除性"></a>整除性</h2><pre><code>a ≡ b(mod c) =&gt; cm = a-b =&gt; m | (a-b) [c属于Z]</code></pre><p>m | (a-b): (a-b)是m的倍数</p><h2 id="保持基本运算"><a href="#保持基本运算" class="headerlink" title="保持基本运算"></a>保持基本运算</h2><center><img src="http://pictures.aimasa.club/static/images/同余/gongshi.png"></center><h2 id="传递性"><a href="#传递性" class="headerlink" title="传递性"></a>传递性</h2><pre><code>a ≡ b(mod m) b ≡ d(mod m) =&gt;a ≡ d(mod m)  </code></pre><h2 id="放大缩小模数"><a href="#放大缩小模数" class="headerlink" title="放大缩小模数"></a>放大缩小模数</h2>  <center><img src="http://pictures.aimasa.club/static/images/同余/bigsmall.png"></center><h2 id="除法原理一"><a href="#除法原理一" class="headerlink" title="除法原理一"></a>除法原理一</h2><center><img src="http://pictures.aimasa.club/static/images/同余/chufa.png"></center><h2 id="除法原理二"><a href="#除法原理二" class="headerlink" title="除法原理二"></a>除法原理二</h2><center><img src="http://pictures.aimasa.club/static/images/同余/yuanli.png"></center>]]></content>
      
      
      <categories>
          
          <category> 离散对数 </category>
          
          <category> 同余 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 同余 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RSA算法</title>
      <link href="/2019/02/21/RSA-key/"/>
      <url>/2019/02/21/RSA-key/</url>
      
        <content type="html"><![CDATA[<p>RSA公钥算法是现在非常普遍的存在，因为它的高运算量所以导致难破解，其实最主要的原因是现有的计算机的运算能力还没有那么强，没办法对巨大的加密数进行因式分解。</p><p>目前公开破译的位数是768位，实际使用一般是1024位或是2048位，所以理论上特别的安全。<br><a id="more"></a><br><a href="https://blog.csdn.net/u014044812/article/details/80866759" target="_blank" rel="noopener">证明方法</a></p><p><a href="https://www.zhihu.com/question/25038691" target="_blank" rel="noopener">公私钥生成步骤</a></p><h1 id="公钥私钥生成"><a href="#公钥私钥生成" class="headerlink" title="公钥私钥生成"></a>公钥私钥生成</h1><p>先选取两个质数q,p</p><blockquote><p>n = p * q</p></blockquote><p>然后算出n的 <a href="https://aimasa.github.io/2019/02/22/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/">欧拉函数</a> φ(n)</p><blockquote><p>φ(n)=(p-1)(q-1)</p></blockquote><p>从1-φ(n)中选出一个质数e，这个e要和φ(n)互质</p><p>对e取反模</p><blockquote><p>ed ≡ 1 (mod φ(n))</p></blockquote><p>根据同余的定义，这个式子可以延展为：</p><blockquote><p>ed - 1 = kφ(n)</p></blockquote><p>根据已知的φ(n)和e得出d的值(会有很多组值，取其一即可)<br>以此得出公钥(n,e) 私钥(n,d)</p><h1 id="加密解密"><a href="#加密解密" class="headerlink" title="加密解密"></a>加密解密</h1><h2 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h2><p> m为需要被加密的信息<br> c为会生成的信息</p><p>m^e ≡ c(mod n)</p><h2 id="解密"><a href="#解密" class="headerlink" title="解密"></a>解密</h2><p>c^d ≡ m(mod n)</p><h2 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h2><h3 id="验证解密公式成立"><a href="#验证解密公式成立" class="headerlink" title="验证解密公式成立"></a>验证解密公式成立</h3><p>对解密公式c^d ≡ m(mod n)进行验证</p><p>根据加密公式 </p><blockquote><p>m^e ≡ c(mod n) =&gt; m^e - c =kn =&gt;c = m^e -kn</p></blockquote><p>把c代入我们要证明的解密公式</p><blockquote><p>(m^e - kn)^d ≡ m(mod n) </p></blockquote><p>因为kn能被n整除，所以在拆这种多项式的时候，能被n整除的数可以留下，因为只有不能被n整除的数才能够产生余数。所以得出下面的公式</p><blockquote><p>m^ed ≡ m(mod n)</p></blockquote><p>又因为ed等于kφ(n)+1，故得出如下公式</p><blockquote><p>m^(kφ(n)+1) ≡ m(mod n)</p></blockquote><p>所以，我们只要证明这个公式成立，就证明解密公式的成立，也就证明了RSA算法的成立。</p><h4 id="两部分证明"><a href="#两部分证明" class="headerlink" title="两部分证明"></a>两部分证明</h4><h5 id="m与n互质"><a href="#m与n互质" class="headerlink" title="m与n互质"></a>m与n互质</h5><p>根据<a href="https://aimasa.github.io/2019/02/22/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/">欧拉定理</a>得出如下公式</p><blockquote><p>m^φ(n) ≡ 1(mod n) =&gt; m^φ(n)-1 = kn =&gt;m^φ(n) = kn + 1<br>(m^φ(n))^h = (kn + 1)^h </p></blockquote><p>而对(kn + 1)^h 对n取模为1，可以推出</p><blockquote><p>(kn + 1)^h ≡ 1(mod n) =&gt; (m^φ(n))^h ≡ 1(mod n)<br>=&gt; m^(kφ(n)+1) ≡ m(mod n)</p></blockquote><p>该式子成立</p><h5 id="m与n不互质"><a href="#m与n不互质" class="headerlink" title="m与n不互质"></a>m与n不互质</h5><p>m和n不互质时候，所以n和m一定有除1以外的公因子，又因为n等于质数p和质数q的乘积(<strong>两个质数之积是合数，但该合数只有四个因子，因数除了1和它本身外还有这两个质数因子。</strong>)所以，m必然等于kq或kp。</p><p>以m=kq为例，那么m一定和p互质(<strong>一个素数，另一个数不为它的倍数，那么两个数一定互质</strong>)——&gt;根据<a href="https://aimasa.github.io/2019/02/22/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/">欧拉定理</a>可得出如下公式：</p><blockquote><p>(kq)^φ(p) ≡ 1 (mod p)</p></blockquote><p>因为p为质数，所以</p><blockquote><p>φ(p)= p - 1</p></blockquote><p>可以得出</p><blockquote><p>(kq)^(p - 1) ≡ 1 (mod p)  </p><p>((kq)^(p - 1))^h(q - 1) x kq ≡ kq (mod p) </p><p>(kq)^(hφ(n) + 1) ≡ kq (mod p)</p></blockquote><p>又因为(因为上式中的h可以为任意数字，所以假定h为下式中的h)</p><blockquote><p>ed ≡ 1(modφ(n)) → ed = hφ(n)+1 → ed = h(p−1)(q−1)+1 </p></blockquote><p>故</p><blockquote><p>(kq)^ed ≡ kq (mod p)</p><p>(kq)^ed - kq = tp</p></blockquote><p>因为等式左边对q取模为零，所以右边一定也为零，所以tp中t一定是q的倍数，令t=uq</p><blockquote><p>(kq)^ed - kq = uqp</p></blockquote><p>又因为n = pq, m = kq，所以</p><blockquote><p>m^ed -m = un</p><p>m^ed ≡m(modn)</p></blockquote><p>又因为生成密钥的第五步中我们取e并求了他对φ(n)的模反元素d：</p><blockquote><p>ed≡1(modφ(n))→ed=hφ(n)+1</p></blockquote><p>将ed代入上式得：</p><blockquote><p>m^(hφ(n)+1) ≡ m(modn)</p></blockquote><p>故当m与n不互质时候，证明原式成功。</p>]]></content>
      
      
      <categories>
          
          <category> RSA公钥加密 </category>
          
          <category> RSA算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RSA算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>欧几里得算法（了解了一下贝祖等式）</title>
      <link href="/2019/02/20/Euclidean/"/>
      <url>/2019/02/20/Euclidean/</url>
      
        <content type="html"><![CDATA[<p>它是求最大公约数的算法。<br><a id="more"></a></p><p><a href="https://zh.wikipedia.org/wiki/%E8%BC%BE%E8%BD%89%E7%9B%B8%E9%99%A4%E6%B3%95#%E8%AE%A1%E7%AE%97%E5%95%86%E5%92%8C%E4%BD%99%E6%95%B0" target="_blank" rel="noopener">参考链接</a><br>a x b =c  c是a的倍数，a是c的约数。<br>最大公约数就是能够整除几个自然数中的最大的一个</p><p>欧几里得算法则是用于计算两个整数的最大公约数，它又被叫做最大公约数</p><p>两个整数的最大公约数表示方法：GCD(a,b)</p><p>欧几里得的辗转相除法其实可以用来计算任意多整数的最大公约数。</p><p>算法描述：GCD(a,b)=c时候，除掉小学时候学的分解这两个数，取共有的公约数，然后把它们相乘之外，还可以用另外一种方法把c求出来——就是用a,b两个数中最大的那个数减去最小的那个数，然后那个最大的数就变成得出的差值，以此循环，直到有一个数变成零为止，另一个不为零的数就是它们的最大公约数。</p><p>用辗转相除法算最大公约数效率非常高。</p><p>eg:</p><pre><code>252 105 的最大公约数147 105（252-105）42  105（147-105）42  63 （105-42）42  21 （63-42）21  21 （随便哪边减掉哪边）0   21</code></pre><p>因为在这个辗转相除的过程中，它可以一个数大于另一个数大很多（比如42和105）这时候，105需要减掉2次42才能得到比42更小的数字，所以这里可以考虑除法求余的办法。105 mod 42=21，这样又快又准，还方便。</p><pre><code>252 105（252 mod 105）42  105（105 mod 42）42  21 （42 mod 21）0   21 （正好结果是0，所以21是最大公约数）</code></pre><p>所以，ua+vb的值的集合，都是c的倍数。—-因为a和b的最大公约数是c，即都能被c整除，这个是贝祖等式提出的定义</p><p>a和b的最大公约数叫做a和b的<strong>理想</strong>的生成元素。这个最大公约数的定义导出了两个现代抽象代数的概念：<strong>主理想（由单个元素生成的理想）</strong> 以及<strong>主理想整环（其每一理想都是主理想的整环）</strong>。</p><p>GCD(a,b)=1那么这两个数一定互质</p>]]></content>
      
      
      <categories>
          
          <category> RSA公钥加密 </category>
          
          <category> 欧几里得算法/辗转相除法及贝祖等式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 欧几里得算法/辗转相除法简略介绍及贝祖等式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>费马小定理</title>
      <link href="/2019/02/20/discreteLogarithm/"/>
      <url>/2019/02/20/discreteLogarithm/</url>
      
        <content type="html"><![CDATA[<p>要想清楚的了解费马，就要先了解同余。</p><p>费马小定理：<br>若p为素数，a为整数，(a,p)=1(即两者只有一个公约数1)，则 a^(p-1)≡1（mod p）</p><p>如果n是一个素数（只能被1和自身整除的数字），a是小于n的任意正整数，那么a^n mod n 的结果和a mod n一样。a^(n)≡a（mod n）</p><a id="more"></a><p><a href="http://www.nowamagic.net/librarys/veda/detail/2329" target="_blank" rel="noopener">参考博客</a></p><p><a href="https://zh.wikipedia.org/wiki/%E8%B4%B9%E9%A9%AC%E5%B0%8F%E5%AE%9A%E7%90%86" target="_blank" rel="noopener">维基百科</a></p><p>费马检查：给一个整数n，然后随机取一个a，这个a要小于n，然后计算a取模n的结果并且用它去和a^n mod n的结果相比，如果两个结果不一样，那么这个n一定不是素数，两个结果一样的话，那么这个n几率很大是素数。通过检查越来越多的a值，结果还是一样的话，这个n是素数的可能性也越大。</p><p>费马检测是一个相对可靠的算法，而且在实现大数判断素数时可以提供相对高的效率来工作。</p><p>为什么说它相对可靠呢，是因为有些极其罕见的数字，也具备费马定理的特性，然鹅他们并不是素数。能够骗过费马检查的数称为 Carmichael 数。（科普时间）在 100 000 000 之内有 255 个 Carmichael 数，其中最小的几个是 561、1105、1729、2465、2821 和 6601。</p><p>费马检查却可以在几秒内判断这么大的数的素性。这一事实成为 Rivset、Shamir 和 Adleman (1977) 提出的一种构造“不可摧毁的密码”的技术基础，这一 RSA 算法已经成为提高电子通信安全性的一种使用广泛的技术</p>]]></content>
      
      
      <categories>
          
          <category> 数论 </category>
          
          <category> 费马小定理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>伽罗瓦域_乘法</title>
      <link href="/2019/02/20/GaloisField-mult/"/>
      <url>/2019/02/20/GaloisField-mult/</url>
      
        <content type="html"><![CDATA[ <center><img src="http://pictures.aimasa.club/static/images/GaloisField-mult/multi.png"></center><p>其中，α=0000 0010转回十进制的数值就是2，所以，α^n时候，n每加一就是该二进制往左移一位。如果超了范围的话，就先左移一位，然后再模100011101，让它的值在固定的范围内。</p><p>除零之外的场的每个元素等于α的某个幂。 我们定义的元素α被称为伽罗瓦域的原始元素或生成元。</p>]]></content>
      
      
      <categories>
          
          <category> 伽罗瓦域/有限域 </category>
          
          <category> 乘法表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 伽罗瓦域/有限域 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo deploy不报错但是无法显示</title>
      <link href="/2019/02/20/hexo-err/"/>
      <url>/2019/02/20/hexo-err/</url>
      
        <content type="html"><![CDATA[<pre><code>hexo ghexo shexo d</code></pre><p>错误描述：三步下来，hexo s这一步是没有错的，也能在本地预览已经生成好的静态页面，但是hexo d之后，不报错，但是就是没法正确部署到github page上面。而且还收到github发来的邮件，说是主题不被支持。<br><a id="more"></a></p><p>删掉.deploy_git，然后git clean ,接着hexo d -g重新生成这个文件夹，并且将页面部署到github page中</p>]]></content>
      
      
      <categories>
          
          <category> hexo错误笔记 </category>
          
          <category> hexo deploy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo err类型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>俄罗斯农夫算法</title>
      <link href="/2019/02/20/RussianPeasant/"/>
      <url>/2019/02/20/RussianPeasant/</url>
      
        <content type="html"><![CDATA[<p>  俄罗斯农民乘法是在一个乘数和被乘数之间进行操作，降低运算需要花费的时间。<br>  <a id="more"></a><br><a href="http://www.cnblogs.com/yangqingli/p/4745167.html" target="_blank" rel="noopener">参考博客</a>  </p><p><a href="https://en.wikiversity.org/wiki/Reed%E2%80%93Solomon_codes_for_coders" target="_blank" rel="noopener">参考代码来源</a></p><p>这个算法流程是：乘数和被乘数，一个乘2一个除2，如果被乘数为奇数，则它除以2后去掉余数。如果被乘数是偶数，则继续往下乘除。<br>等被乘数除以2的结果为1的时候，运算结束，把被乘数为奇数的结果所对应的乘数乘以2的结果相加，最终结果为正确乘积。</p><pre><code>  52 x 25  104  12  208   6  416   3  832   1 -----------  52+416+832=1300</code></pre><p>   以下是位运算代码示例： </p><pre><code>def gf_mult_noLUT(x, y, prim=0, field_charac_full=256, carryless=True):&#39;&#39;&#39;Galois Field integer multiplication using Russian Peasant Multiplication algorithm (faster than the standard multiplication + modular reduction).If prim is 0 and carryless=False, then the function produces the result for a standard integers multiplication (no carry-less arithmetics nor modular reduction).&#39;&#39;&#39;    r = 0    while y: # while y is above 0        if y &amp; 1: r = r ^ x if carryless else r + x # y is odd, then add the corresponding x to r (the sum of all x&#39;s corresponding to odd y&#39;s will give the final product). Note that since we&#39;re in GF(2), the addition is in fact an XOR (very important because in GF(2) the multiplication and additions are carry-less, thus it changes the result!).        y = y &gt;&gt; 1 # equivalent to y // 2        x = x &lt;&lt; 1 # equivalent to x*2        if prim &gt; 0 and x &amp; field_charac_full: x = x ^ prim # GF modulo: if x &gt;= 256 then apply modular reduction using the primitive polynomial (we just subtract, but since the primitive number can be above 256 then we directly XOR).return r</code></pre><p>其中y&amp;1是用来判断y是奇数还是偶数，if carryless是用来判断这个是普通乘法还是伽罗瓦乘法，然后做出相应的算法</p><p>prim &gt; 0是判断是不是伽罗瓦乘法，是的话，再对结果进行相应的处理</p><p>x &amp; field_charac_full这个是判断x是否大于field_charac_full，大于的话就模field_charac_full以控制x在相应范围内，小于的话就可以直接输出结果。</p>]]></content>
      
      
      <categories>
          
          <category> 位运算代码示例 </category>
          
          <category> 俄罗斯农夫算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 位运算代码示例 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>位运算_汉明距离</title>
      <link href="/2019/02/19/BitOperation_Hamming/"/>
      <url>/2019/02/19/BitOperation_Hamming/</url>
      
        <content type="html"><![CDATA[<p>汉明距离是用来计算两个不同字符串之间不同的值有多少个。二进制中就是两个二进制相减，结果中1的个数<br><a id="more"></a></p><pre><code>def hamming_weight(x): #不同bit的数量    weight = 0    while x &gt; 0:        weight += x &amp; 1        x &gt;&gt;= 1return weightdef qr_decode_format(fmt):    best_fmt = -1    best_dist = 15    for test_fmt in range(0, 32):        test_code = (test_fmt &lt;&lt; 10) ^ qr_check_format(test_fmt &lt;&lt; 10)#得出（0-2^5）左移10位然后能被生成子整除的5bit编码        &#39;&#39;&#39;         计算汉明距离的公式        &#39;&#39;&#39;        test_dist = hamming_weight(fmt ^ test_code)        if test_dist &lt; best_dist:            best_dist = test_dist            best_fmt = test_fmt        elif test_dist == best_dist: #如多个码字与fmt距离相同，则都不选（就是不止一个与原信息的汉明距离相同）            best_fmt = -1return best_fmt</code></pre><p>用fmt^test_code算出fmt和test_code中二进制的不同，再去统计相减结果为1的个数，最后得出汉明距离。（也可以叫做计算出汉明权重）</p><p>汉明权重：指一个字符串中非零字符的个数；对于二进制串，即其中‘1’的个数。</p>]]></content>
      
      
      <categories>
          
          <category> 位运算代码示例 </category>
          
          <category> 汉明距离 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 位运算代码示例 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>位运算_除法</title>
      <link href="/2019/02/19/BitOperation_divided/"/>
      <url>/2019/02/19/BitOperation_divided/</url>
      
        <content type="html"><![CDATA[<p>这个除法是普通的除法，用来求余的除法。</p><a id="more"></a><center><img src="http://pictures.aimasa.club/static/images/BitOperation_divided/divided.png"></center><p>所以根据<a href="https://en.wikiversity.org/wiki/Reed%E2%80%93Solomon_codes_for_coders" target="_blank" rel="noopener">该链接中的代码</a>举例:</p><pre><code>def qr_check_format(fmt):    g = 0x537    # = 0b10100110111 in python 2.6+    for i in range(4,-1,-1):        if fmt &amp; (1 &lt;&lt; (i+10)): #判断第一位是否为零（二进制除法不需要进位借位）        fmt ^= g &lt;&lt; i #开始计算return fmt</code></pre><p>其中for i in range(4,-1,-1)里面i的范围是[4,0]的原因是：上述例子中举例用的生成器10100110111长度和用于和它进行相除的除数000111101011001长度相差为4，所以设置i的范围为[4,0]<br>（其中生成器做被除数）</p>]]></content>
      
      
      <categories>
          
          <category> 位运算代码示例 </category>
          
          <category> 除法求余 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 位运算代码示例 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>位运算_乘法</title>
      <link href="/2019/02/19/BitOperation_mult/"/>
      <url>/2019/02/19/BitOperation_mult/</url>
      
        <content type="html"><![CDATA[<p>伽罗瓦域的加减法运算都是用异或的方法运算的，所以它的乘法和普通的乘法也是不一样的。<br><a id="more"></a></p><center><img src="http://pictures.aimasa.club/static/images/BitOperation_mult/field_multiplication.png"></center><p>其中乘法运算完成后，结果相加的步骤和普通乘法不一样，它用的是异或</p><p>所以根据<a href="https://en.wikiversity.org/wiki/Reed%E2%80%93Solomon_codes_for_coders" target="_blank" rel="noopener">该链接中的代码</a>举例:</p><pre><code>def cl_mul(x,y):&#39;&#39;&#39;Bitwise carry-less multiplication on integers&#39;&#39;&#39;    z = 0    i = 0    while (y&gt;&gt;i) &gt; 0:        if y &amp; (1&lt;&lt;i): #判断y?=1            z ^= x&lt;&lt;i #判断x乘的是y的第几位        i += 1return z</code></pre>]]></content>
      
      
      <categories>
          
          <category> 位运算代码示例 </category>
          
          <category> 伽罗瓦域的乘法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 位运算的代码示例 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>伽罗瓦域</title>
      <link href="/2019/02/18/GaloisFields/"/>
      <url>/2019/02/18/GaloisFields/</url>
      
        <content type="html"><![CDATA[<p>有限域亦称伽罗瓦域（galois field），是仅含有限个元素的域,它是伽罗瓦(Galois,E.)于18世纪30年代研究代数方程根式求解问题时引出的.（摘自百度百科）<br><a id="more"></a></p><h2 id="群："><a href="#群：" class="headerlink" title="群："></a><strong>群</strong>：</h2><p>其中（D,<em>）是一个群的话，则称G关于运算“ </em> ”形成一个群，*是这个群的运算式。其中，D=<g>那么说明，D这个群是由g这个生成元组成的。</g></p><p>集合+运算=群</p><p>给一个集合中的元素定义一种运算“乘法”（这个“乘法”不是数字运算的乘法，而只是借用了这个名字，因此加上了引号），如果这个集合中的元素和这个“乘法”满足：</p><ul><li><p>封闭性：集合中任两个元素相“乘”的结果在这个集合之内；</p></li><li><p>结合律：这个“乘法”满足(a<em>b)</em>c=a<em>(b</em>c)；</p></li><li><p>单位元：集合中存在某个元素e，对于任意集合中的其它元素a有e<em>a=a</em>e=a，e被称为单位元；</p></li><li><p>逆元：对于集合中任意元素a，一定存在集合中的另外一个元素a^(-1)，使得a<em>a^(-1)=a^(-1)</em>a=e，a与a-1互为逆元。</p></li></ul><p>此时，这个集合与这个运算组合在一起被称为“群”。</p><p>此下是一个来自知乎上<a href="https://zhuanlan.zhihu.com/p/30384157" target="_blank" rel="noopener">一篇笔记</a>的例子</p><center><img src="http://pictures.aimasa.club/static/images/GaloisFields/qunex.png"></center><p>在里面的ab=ac（a^(-1)ab=a^(-1)ac），推出b=c的过程中，用到了<strong>逆元存在</strong>这个概念），还用到了<strong>单位元存在</strong>这个概念</p><p>ba=ca（baa^(-1)=caa^(-1)）推出b=c的过程用到了<strong>结合率</strong>的概念</p><h3 id="交换群"><a href="#交换群" class="headerlink" title="交换群"></a>交换群</h3><p>首先明白这样一个代数结构</p><center><img src="http://pictures.aimasa.club/static/images/GaloisFields/shuangs.png"></center><p><a href="https://aimasa.github.io/categories/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%8F%8C%E5%B0%84%E5%8D%95%E5%B0%84%E6%BB%A1%E5%B0%84/">双射</a>就是值域和定义域一对一的映射，每个定义域都有唯一一个与之对应的值域</p><p>接着这个是交换群的概念</p><center><img src="http://pictures.aimasa.club/static/images/GaloisFields/jiaohuan.png"></center><p>我的理解是，在交换群中，每个数都有它通过相同运算对应的结果，无一例外，就连e也能通过这个运算得到在群内的结果</p><h3 id="循环群"><a href="#循环群" class="headerlink" title="循环群"></a>循环群</h3><p>在讲到循环群的时候，这个<a href="https://zhuanlan.zhihu.com/p/30384157" target="_blank" rel="noopener">笔记</a>里面出现了阶的定理，我目前还不是很清楚阶的定理和循环群的定理有什么关联(如果这个群里面存在阶，就可以称这个群是有限群，否则则成为无限群)</p><center><img src="http://pictures.aimasa.club/static/images/GaloisFields/jie.png"></center><p>我们给它一个符号 o(a)=n</p><p>然后循环群就是每个元素都能写成其中某个元素的i次幂的形式，这个元素就是这个群的生成元。每个循环群都是阿贝尔群</p><center><img src="http://pictures.aimasa.club/static/images/GaloisFields/xunhuan.png"></center><h3 id="子群"><a href="#子群" class="headerlink" title="子群"></a>子群</h3><p>我的理解就是大群里面的小群，然后这个小群有着群需要的一切要素。</p><center><img src="http://pictures.aimasa.club/static/images/GaloisFields/ziqun.png"></center><h2 id="环与域："><a href="#环与域：" class="headerlink" title="环与域："></a><strong>环与域</strong>：</h2><p>在一个集合上定义两种运算“加法”和“乘法”，如果这个集合在这个“加法”下成群，而在这个“乘法”下只满足“封闭性”与“结合律”，则称这个集合与这两种运算构成一个“环”；如果这个集合去除“加法”群下的单位元后形成的新集合在“乘法”下成群，则称这个集合与这两种运算构成一个“域”。显然，“域”是一种特殊的“环”。</p><p>————————————————————————————-<a href="http://blog.sciencenet.cn/blog-409681-1048911.html" target="_blank" rel="noopener">摘自zhaohaotong的博文</a></p><h2 id="有限域GF-p-："><a href="#有限域GF-p-：" class="headerlink" title="有限域GF(p)："></a><strong>有限域GF(p)</strong>：</h2><p>  在密码学中，有限域GF(p)是一个很重要的域，其中p为素数。简单来说，GF(p)就是 mod p，因为一个数模p后，结果在[0, p-1]之间。对于元素a和b，那么(a+b) mod p和(a*b)mod p，其结果都是域中的元素。GF(p)里面的加法和乘法都是平时用的加法和乘法。GF(p)的加法和乘法单位元分别是0和1，元素的加法和乘法逆元都很容易理解和求得.</p><h2 id="有限域GF-2-8-："><a href="#有限域GF-2-8-：" class="headerlink" title="有限域GF(2^8)："></a><strong>有限域GF(2^8)</strong>：</h2><p>现在重点讲一下GF(2^n)，特别是GF(2^8)，因为8刚好是一个字节的比特数。</p><p>前面说到， GF(p)，p得是一个素数，才能保证集合中的所有元素都有加法和乘法逆元(0除外)。但我们却很希望0到255这256个数字也能组成一个域。因为很多领域需要用到。mod 256的余数范围就是0到255，但256不是素数。小于256的最大素数为251，所以很多人就直接把大于等于251的数截断为250。在图像处理中，经常会这样做。但如果要求图像无损的话，就不能截断。</p><p>貌似已经到了死胡同，救星还是有的，那就是GF(p^n)，其中p为素数。在这里我们只需令p为2，n为8，即GF(2^8)。</p><p>——————————————————————————————<a href="https://blog.csdn.net/luotuo44/article/details/41645597" target="_blank" rel="noopener">摘自luotuo44博文</a></p><p>在伽罗瓦域里面，加法和减法都是异或运算，所以两者是相等的，而其他域里面是不会这样的。</p>]]></content>
      
      
      <categories>
          
          <category> 伽罗瓦域/有限域 </category>
          
          <category> 基础定义 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 伽罗瓦域/有限域 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python_左移</title>
      <link href="/2019/01/30/python_ShiftLeft/"/>
      <url>/2019/01/30/python_ShiftLeft/</url>
      
        <content type="html"><![CDATA[<p>都是移位操作，三个符号和两个符号的区别是：</p><a id="more"></a><p>“&gt;&gt;” 右移,高位补符号位</p><p>“&gt;&gt;&gt;” 无符号右移,高位补0；</p><p>“&lt;&lt;” 左移  左移一位表示乘2，二位就表示4，就是2的n次方</p><p>“^”是异或</p><p>a&amp;b时候返回的值是直接赋给a的</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> &lt;&lt;、&gt;&gt;、^、&amp; </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python 语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python_range的用法</title>
      <link href="/2019/01/30/python_rangeUse/"/>
      <url>/2019/01/30/python_rangeUse/</url>
      
        <content type="html"><![CDATA[<p>简单的讲了一下range的用法和array[::]的一些用法<br><a id="more"></a></p><p><a href="www.cnblogs.com/buro79xxd/archive/2011/05/23/2054493.html">参考博文</a><br>array = [1, 2, 5, 3, 6, 8, 4]</p><p><strong>其实这里的顺序标识是</strong></p><p>[1, 2, 5, 3, 6, 8, 4]</p><p>(0，1，2，3，4，5，6)</p><p>(-7,-6,-5,-4,-3,-2,-1)</p><h1 id="情况"><a href="#情况" class="headerlink" title="[::]情况"></a>[::]情况</h1><p>那么两个[::]会是什么那？</p><blockquote><p>array[::2]<br>[1, 5, 6, 4]</p><p>array[2::]<br>[5, 3, 6, 8, 4]</p><p>array[::3]<br>[1, 3, 4]</p><p>array[::4]<br>[1, 6] </p></blockquote><p>如果想让他们颠倒形成reverse函数的效果</p><blockquote><p>array[::-1]<br>[4, 8, 6, 3, 5, 2, 1]</p><p>array[::-2]<br>[4, 6, 5, 1]</p></blockquote><h1 id="情况-1"><a href="#情况-1" class="headerlink" title="[:]情况"></a>[:]情况</h1><p>如果[:]只有一个的时候，那么：</p><blockquote><p>array[:-2]<br>[8, 4]</p><p>array[-2:]<br>[1, 2, 5, 3, 6]</p><p>array[2:]<br>[5, 3, 6，8,4]</p><p>array[:2]<br>[1,2]</p></blockquote><p>(后面的-x是从-1开始计数)</p><p><a href="https://blog.csdn.net/zhenyu5211314/article/details/19069567" target="_blank" rel="noopener">参考博文</a>:<br>函数原型：range（start， end， scan):</p><p>参数含义：</p><ul><li>start:计数从start开始。默认是从0开始。例如range（5）等价于range（0， 5）;</li><li>end:技术到end结束，但不包括end.例如：range（0， 5） 是[0, 1, 2, 3, 4]没有5</li><li>scan：每次跳跃的间距，默认为1。例如：range（0， 5） 等价于 range(0, 5, 1)</li></ul><p><strong>所以，两个冒号时候，array[::]其中第一个数是数列的起始位置，第二个数是数列的最终位置，第三个是从第一位置往下数间隔的长度（如果为负数，则是倒过来往前数字符）</strong></p><p><strong>在range()中，有三个值，第三个值如果是负数则是减少，正数是增加</strong></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> range()&amp;array[::] </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python的用法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>about_blockchain</title>
      <link href="/2019/01/26/about_blockchain/"/>
      <url>/2019/01/26/about_blockchain/</url>
      
        <content type="html"><![CDATA[<h1 id="blockchain"><a href="#blockchain" class="headerlink" title="blockchain"></a>blockchain</h1><blockquote><p>因为之前我没弄懂电子签章的问题，然后问旁边的同学，他很仔细的给了我解释，还帮我找了一篇论文，让我看看前两页，所以在阅读这篇论文时候在此做个笔记。<br> <a id="more"></a></p></blockquote><h2 id="电子签名"><a href="#电子签名" class="headerlink" title="电子签名"></a>电子签名</h2><p>在区块链上生成的签名被称为“数字”而不是“电子”。电子签名是“附加的电子声音，符号或过程，或在逻辑上与合同或其他记录相关联，由有意图的人采用“签署记录“（也就是证明自己是自己的东西，并且赋予认定）（referred to：提到）</p><h1 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h1><p>数字签名是一种特殊的电子签名，它可以加密被签名的文档并并有助于在后续场合验证其身份，它们是在数字环境中创建的，为公钥加密数据库提供验证和传输层（这样拿到这个数字签名的对方，可以用私钥进行解密，得到摘要并且对自己手中的文档进行一次hash算法，对两者进行比对，这样就能判别该文档是否被第三方篡改过，验证其安全性）</p>]]></content>
      
      
      <categories>
          
          <category> blockchain </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blockchain </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>了解二维码(三):BCH解码器</title>
      <link href="/2019/01/23/BCH/"/>
      <url>/2019/01/23/BCH/</url>
      
        <content type="html"><![CDATA[<p>这是一类通用的纠错码，BCH码：现代里德 - 所罗门码的父族，以及有基本的检测和校正机制。<br>格式化信息用BCH码编码，该BCH码允许检测和校正一定数量的比特错误。<br>检查编码信息的过程类似于长除法过程，只是使用异或代替减法（a remainder of zero：余数为零）<br><a id="more"></a></p><h1 id="BCH"><a href="#BCH" class="headerlink" title="BCH"></a>BCH</h1><h2 id="BCH错误检测"><a href="#BCH错误检测" class="headerlink" title="BCH错误检测"></a>BCH错误检测</h2><p>当格式代码被所谓的代码生成器“分割”时，格式代码应产生的余数为零。<br>QR格式代码使用生成器10100110111.</p><p>（ demonstrated：示范）<br>（0x前缀表示该数字是十六进制，0b是二进制）<br>用fmt与生成子相除，返回余数</p><pre><code>def qr_check_format(fmt):    g = 0x537    # = 0b10100110111 in python 2.6+    for i in range(4,-1,-1):        if fmt &amp; (1 &lt;&lt; (i+10)): #判断第一位是否为零（二进制除法不需要进位借位）        fmt ^= g &lt;&lt; i #开始计算return fmt</code></pre><p>其中for i in range(4,-1,-1)里面i的范围是[4,0]的原因是：上述例子中举例用的生成器10100110111长度和用于和它进行相除的除数000111101011001长度相差为4，所以设置i的范围为[4,0]</p><p>1字=2字节(1 word = 2 byte) </p><p>1字节=8位(1 byte = 8bit) </p><p>这个函数可以用于编码生成5bit的编码信息（就是需要被生成器整除的编码信息）</p><pre><code>encoded_format = (format&lt;&lt;10) ^ qr_check_format(format&lt;&lt;10)</code></pre><p>它利用上面的计算余数的函数得出format&lt;&lt;10除以生成器的余数，然后反推出在信息为format&lt;&lt;10的情况下除以生成器时候余数为零的5bit的编码信息。</p><p>如果记格式信息为F，生成子为G，(F&lt;&lt;10)/G的商为Q、余数为R (即F&lt;&lt;10 == Q*G + R)，则最终的编码信息</p><blockquote><p> C = (F &lt;&lt; 10) ^ ((F &lt;&lt; 10) mod G) = (Q<em>G + R) - R = Q</em>G</p></blockquote><p>从而C应当是能够被G整除的。如果收到的C不能被G整除，说明传输出错了。</p><h2 id="BCH纠错"><a href="#BCH纠错" class="headerlink" title="BCH纠错"></a>BCH纠错</h2><p>汉明距离是使用在数据传输差错控制编码里面的，汉明距离是一个概念，它表示两个（相同长度）字对应位不同的数量，我们以d（x,y）表示两个字x,y之间的汉明距离。对两个字符串进行异或运算，并统计结果为1的个数，那么这个数就是汉明距离。</p><pre><code>def qr_check_format(fmt):    g = 0x537    # = 0b10100110111 in python 2.6+    for i in range(4, -1, -1):        if fmt &amp; (1 &lt;&lt; (i+10)):            fmt ^= g &lt;&lt; ireturn fmtdef hamming_weight(x): #不同bit的数量    weight = 0    while x &gt; 0:        weight += x &amp; 1        x &gt;&gt;= 1return weightdef qr_decode_format(fmt):    best_fmt = -1    best_dist = 15    for test_fmt in range(0, 32):        test_code = (test_fmt &lt;&lt; 10) ^ qr_check_format(test_fmt &lt;&lt; 10)#得出（0-2^5）左移10位然后能被生成子整除的5bit编码        test_dist = hamming_weight(fmt ^ test_code)        if test_dist &lt; best_dist:            best_dist = test_dist            best_fmt = test_fmt        elif test_dist == best_dist: #如多个码字与fmt距离相同，则都不选（就是不止一个与原信息的汉明距离相同）            best_fmt = -1return best_fmt</code></pre><p>代码中用fmt ^ test_code，然后统计结果中1的比特的个数，以此来比较fmt和test_code的汉明距离，倘若有多个与fmt的汉明距离一样的test_code，那么就相当于没有可以用于匹配的值，如果只有一个值的话，那么那个最大相似度的值则就是fmt被损坏前的值</p><p>（overflow：溢出；Naively：天真地）</p><blockquote><p>We’d like to define addition, subtraction, multiplication, and division for 8-bit bytes and always produce 8-bit bytes as a result, so as to avoid any overflow. Naively, we might attempt to use the normal definitions for these operations, and then mod by 256 to keep results from overflowing.</p></blockquote><h2 id="伽罗瓦域乘法和减法"><a href="#伽罗瓦域乘法和减法" class="headerlink" title="伽罗瓦域乘法和减法"></a>伽罗瓦域乘法和减法</h2><p>mod2^8就是让加减乘除里面的结果小于2^8，在0-255的区间里面。具体参见笔记<a href="http://www.aimasa.github.io/2019/02/20/GaloisField-mult/" target="_blank" rel="noopener">伽罗瓦域乘法部分</a></p><p>在伽罗瓦域的乘法中，两个数相乘，它的值可能大于2^8，所以在进行乘法后，会对得出的结果进行取模（就是求余），而其中除数为100011101（0x11d）</p><p>100011101（0x11d）是Reed-Solomon代码的<strong>通用</strong>本原多项式。100011101表示8度多项式，其是“不可约的”（意味着它不能表示为两个较小多项式的乘积）。</p><p>素数多项式的附加信息（可以跳过）：什么是素数多项式？ 它相当于素数，但在伽罗瓦域中。 请记住，Galois Field使用的值为2的倍数作为生成器。 当然，在标准算术中，素数不能是2的倍数，但在伽罗瓦域中，它是可能的。 为什么我们需要素数多项式？ 因为要保持在场的边界，我们需要计算Galois场上方任何值的模数。 为什么我们不用Galois Field大小模数？ 因为我们最终会得到许多重复值，并且我们希望在字段中拥有尽可能多的唯一值，因此在使用素数多项式进行模数或XOR时，数字始终只有一个投影。</p><p>另外我们可以发现，用加法也能得出我们想要的结果：$\, 2^{x}\, \cdot \, 2^{y}\, =\, 2^{x+y}\, $</p><h2 id="基于对数的乘法（次幂的加法）"><a href="#基于对数的乘法（次幂的加法）" class="headerlink" title="基于对数的乘法（次幂的加法）"></a>基于对数的乘法（次幂的加法）</h2><p>但是我们怎么样才能知道10001001是α的几次幂呢？这个问题被称为<a href="http://aimasa.github.io/2019/02/27/%E7%A6%BB%E6%95%A3%E5%AF%B9%E6%95%B0/">离散对数</a>（离散对数在一些特殊情况下可以快速计算。然而，通常没有具非常效率的方法来计算它们。）</p><p>   详细内容请看<a href="https://aimasa.github.io/2019/03/05/%E5%9F%BA%E4%BA%8E%E5%AF%B9%E6%95%B0/">基于对数的乘除法</a></p><h2 id="多项式"><a href="#多项式" class="headerlink" title="多项式"></a>多项式</h2><p>维基百科中在介绍RS码前还介绍了伽罗瓦域的多项式，这可能会带来一点混淆，因为伽罗华域的元素本身也是多项式（译注：是系数仅为0、1的多项式）</p><p>—-直接摘自<a href="https://www.felix021.com/blog/read.php?2116" target="_blank" rel="noopener">翻译文档</a></p><p><a href="https://aimasa.github.io/2019/03/05/%E5%A4%9A%E9%A1%B9%E5%BC%8F/">详细介绍代码</a></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://en.wikiversity.org/wiki/Reed%E2%80%93Solomon_codes_for_coders" target="_blank" rel="noopener">参考网页</a></p><p><a href="https://www.felix021.com/blog/read.php?2116" target="_blank" rel="noopener">参考网页</a></p>]]></content>
      
      
      <categories>
          
          <category> QR </category>
          
          <category> 了解二维码 </category>
          
          <category> 了解二维码(三):BCH解码器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> QR </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>了解二维码(二):二维码的编码方式</title>
      <link href="/2019/01/21/QR_detail/"/>
      <url>/2019/01/21/QR_detail/</url>
      
        <content type="html"><![CDATA[<h1 id="了解二维码的编码方式"><a href="#了解二维码的编码方式" class="headerlink" title="了解二维码的编码方式"></a>了解二维码的编码方式</h1><hr><blockquote><p>QR Code码(Quick Response Code)有自动纠错功能，具有超高速识读特点。用CCD二维条码识读设备，每秒可识读30个含有100个字符的QR Code码符号。<a href="http://www.labelmx.com/tech/CodeKown/Code/201207/4637.html" target="_blank" rel="noopener">参考博文链接</a></p></blockquote><a id="more"></a><h2 id="QR码支持的编码内容"><a href="#QR码支持的编码内容" class="headerlink" title="QR码支持的编码内容"></a>QR码支持的编码内容</h2><p><a href="https://blog.csdn.net/dekko/article/details/6121899" title="虽然该博客的图看不到，只有这段话值得看一看" target="_blank" rel="noopener">参考博文链接</a>，<a href="https://www.cnblogs.com/magicsoar/p/4483032.html" target="_blank" rel="noopener">参考博文链接</a>：该链接中有很详细讲二维码的各部分和它的原理，也有很详细的根据一串字符串生成二维码的算法</p><h2 id="数据编码"><a href="#数据编码" class="headerlink" title="数据编码"></a>数据编码</h2><p>针对不同的数据，QR码设计了<strong> 不同的数据编码编码方式 </strong>，我们可以根据数据的种类选择合适的编码方式进行编码。</p><ul><li><p>数字编码（Numeric）        ：可编码0-9，10个数字，如果需要编码的数字的个数不是3的倍数，最后剩下的1或2位数会被转成4或7bits，其它的每3位数字会根据不同版本被编成 10，12，14bits（编成多长还得看二维码的尺寸）</p></li><li><p>字符编码（Alphanumeric) ：可编码0-9,大写的A-Z（没有小写）,以及9个其他的字符(space $ % * + – . / :)编码的过程是把字符两两分组，然后转成下表的45进制，然后转成11bits的二进制，如果最后有一个落单(说明该字符串长度为奇数)的，那就转成6bits的二进制。而编码模式和字符的个数需要根据不同的Version尺寸编成9, 11或13个二进制</p><center><img src="http://pictures.aimasa.club/static/images/QR_detail/Alphanumeric-mode.png"></center></li><li><p>8位字节模式(8-bit Byte)：可编码JIS X 0201的8位Latin/Kana字符集</p></li></ul><p>除此之外，QR还提供了其他的编码方式，每一个编码方式都有其独有的id进行标识，这些标识会记录在数据区的前端，使得解码器可以根据二维码使用的编码方式对数据进行解码</p><center><img src="http://pictures.aimasa.club/static/images/QR_detail/encodeList.png"></center><hr><p>QR码支持编码的内容包括纯数字、数字和字符混合编码、8位字节码和包含汉字在内的多字节字符。其中：</p><ul><li><p>数字：每三个为一组压缩成10bit。</p></li><li><p>字母数字混合:每两个为一组，压缩成11bit。                                  </p></li><li><p>8bit字节数据：无压缩直接保存。</p></li><li><p>多字节字符：每一个字符被压缩成13bit。</p></li></ul><p>在QR的<a href="https://aimasa.github.io/2019/01/21/QR_infor">图像介绍</a>中说过关于QR数据存储有关的知识，在QR中1码字对应8比特。<br>以下是QR码中总比特的计算方法</p><center><img src="http://pictures.aimasa.club/static/images/QR_detail/bit_count.png"></center><h2 id="补齐码"><a href="#补齐码" class="headerlink" title="补齐码"></a>补齐码</h2><p>补齐码不同版本和不同纠错级，所容纳的比特数也不同，不同版本和不同纠错级所容纳的比特数见附录四。而补齐码就是在我们确定好QR码的版本和纠错级后，判断数据编码的比特数在此版本和纠错级下能够容纳的数据编码比特数是否相等。不是的话，那么就补11101100  00010001进行填充，如果一次填充还不足的话，可循环再次填充。直到其与比特数相同</p><p>数据编码=编码模式+字符长度+编码的数据+结束码+凑8bits整+补齐码。</p><p><a href="https://www.jianshu.com/p/8a0dcb2e0427" target="_blank" rel="noopener">摘自简书(稍做修改，便于我理解)</a></p><h2 id="纠错码"><a href="#纠错码" class="headerlink" title="纠错码"></a>纠错码</h2><p>纠错码的等级越高，纠错能力也会越高，这样就会需要更多的纠错码，就会导致能够存储的数据变少。纠错码一共有四个等级，L(7%) 01,M(15%) 00,Q(25%) 11,R(35%) 10  <strong>括号里的百分比是能够修正的字符比例</strong></p><p>因为变脏，变破损的部位不一定只是码字部位，还有别的地方，所以，在QR码中，还是用相对于全部码字的比率来描述纠错率。</p><p>纠错级别的比率，是指全部码字与可以纠错的码字的比率。 </p><p>纠错码可以纠正两种错误：</p><ul><li>（错误码位置已知）拒读错误：就是扫描二维码时候有的字符没扫到或者扫描到了却读取不出来，就需要纠错码上场了，这种错误需要一个纠错码</li><li>（错误位置未知）替代错误：就是有的字符输入错误，但是不知道是哪个字符，所以就需要纠错码的帮助，需要两个纠错码。</li></ul><hr><blockquote><p><a href="https://en.wikiversity.org/wiki/Reed%E2%80%93Solomon_codes_for_coders" target="_blank" rel="noopener">记笔记</a>：虽然纠错码在数学上可能看起来令人生畏，但大多数数学运算都是高等级的（Galois Fields除外，但事实上对于任何程序员来说都是简单和通用的：它只是对整数模运算操作数）。 然而，纠错码背后的数学智慧的复杂性隐藏了非常直观的目标和机制。</p><p>让我们以一种我们可以“猜测”数据是否被破坏的方式构建数据，只需“修复”结构就可以了。在数学上，我们使用来自伽罗瓦域的多项式来实现这种结构。（get corrupted：被破坏）</p><p>纠错码的主要思路是，我们可以使用较小的一组精心挑选的单词，而不是使用整个单词词典，一个“简化的词典”，这样的每个单词都和别的单词都不一样。（我的理解是，这一组单词是没有重复的词汇，所以每个单词都是独一无二的），我们只需在我们的简化字典中查找</p><ul><li>检测哪些单词被破坏（因为它们不在我们的简化字典中）</li><li>通过查找字典中最相似的单词来纠正损坏的单词。</li></ul></blockquote><hr><p>这部分我的理解是可以把需要放进去的消息去掉重复的字符，做成一个简易词典，然后在一些词因为破损而没法顺利读取出来时候，就用这个简易词典里面的字符和这些词进行比对，其中差异最小的词就被自动认定为这个词破损前的样子</p><p>但是如果简化词典里面有this和that两个单词，但是被损坏只能读取出来的部分是th**(precisely:准确的；separability:分离性)</p><p>这个差异，或者更准确地说是我们字典的任何2个单词之间的不同字母的最小数量，被称为我们字典的最大汉明距离。 确保字典的任何2个单词在同一位置仅共享最少数量的字母称为最大可分离性。</p><p>最大可分离性：两个单词之间极少部分相同</p><p>比如：</p><p>请注意，如果词典中的每个单词与其他单词的差异至少为5个字符，因此距离为5.这允许在已知位置中最多4个错误，这些错误称为擦除或未知位置中的2个错误需要更正。【因为如果位置错误有五个的话，就会出现没法用简化词典比对出这个破损的词是什么】</p><p>8字符中6个字符的子集有28个[C(8,6)]，所以遍历28个6字符的子集，因为距离为5，所以只有一个能匹配（在被损坏的单词少于或者等于2的时候）</p><hr><blockquote><p>可以看到冗余在恢复丢失信息方面的优势：冗余字符可帮助您恢复原始数据。 前面的例子显示了粗略的纠错方案如何起作用。 Reed-Solomon的核心思想是类似的，将冗余数据附加到基于Galois Field数学的消息中。 原始纠错解码器类似于上面的错误示例，搜索对应于有效消息的接收消息的子集，并选择具有最多匹配的子集作为纠正消息。 这对于较大的消息是不实际的，因此开发了数学算法以在合理的时间内执行纠错。</p></blockquote><h2 id="格式信息"><a href="#格式信息" class="headerlink" title="格式信息"></a>格式信息</h2><h3 id="掩码"><a href="#掩码" class="headerlink" title="掩码"></a>掩码</h3><p>掩码过程是被用来避免可能会让扫描器混乱的标志特征出现（比如大区域的黑块，让扫描器无法识别其中内容），所以用掩码反转某些模块（让白色变成黑色，黑色变成白色），而那些特定功能的模块则单独存在，不受掩码的影响。</p><p>红色的区域编码了格式信息，并使用了一个固定的掩码模式</p><center><img src="http://pictures.aimasa.club/static/images/QR_detail/masking.png"></center><p>使用异或操作可以轻松应用（或者删除）掩码转换（很多编程语言里面用插入符<br>号^表示）逆时针读取二维码中的左上角的定位器模式，我们能够得到下面的比特序列，白色表示0，黑色表示1。（校正图形盖住的部位不需要读取二进制数）</p><p>所以：<br>Input：101101101001011<br>Mask ：101010000010010<br>output：000111101011001</p><h3 id="格式信息-1"><a href="#格式信息-1" class="headerlink" title="格式信息"></a>格式信息</h3><p>格式信息有两个相同的副本，所以即使其中一份被损坏还是能够有机会识别出来的。第二份副本被分成两部分，放在另外两个定位器周围，并且都还是以逆时针方向读取。</p><p>格式信息的前两比特是用来给出用于消息数据的纠错码的纠错等级信息。</p><center><img src="http://pictures.aimasa.club/static/images/QR_detail/纠错码.png"></center><p>格式信息接下来的三位是选择要在数据区中使用的掩码模式，接下来的这张图把这些掩码模式列出来了，包括了根据位置算出的模块为黑色的数学公式（i和j分别是行号和列号，左上角以0开头）。</p><center><img src="http://pictures.aimasa.club/static/images/QR_detail/Mask_num.png"></center><p>剩下的十位格式化信息用于对格式信息本身的错误校验。</p><p>（duplicate：更正）</p><p>从右下角开始读取数据位，并以Z字形图案向上移动两个右侧列。 前三个字节是01000000 11010010 01110101.接下来的两列是向下读取的，因此下一个字节是01000111.到达底部后，向上读取后面的两列。 以这种上下方式一直到符号的左侧（必要时跳过定位模式）。 这是用十六进制表示法表示出来的完整信息。</p><center><img src="http://pictures.aimasa.club/static/images/QR_detail/unmask.png"></center><p>Message data bytes: 40 d2 75 47 76 17 32 06 27 26 96 c6 c6 96 70 ec<br>Error correction bytes: bc 2a 90 13 6b af ef fd 4b e0</p><h2 id="解码"><a href="#解码" class="headerlink" title="解码"></a>解码</h2><p>最后的步骤是把解读信息比特，把它变成可读的信息。前四个比特指示信息应该怎么解码。QR码使用几种不同的编码模式，以至于不同种类的信息能够有效的被存储。（summarize：总结）在模式指示码之后的是长度字段，告诉解码器有多少字符被存储。这个字符的长度取决于指定的编码方案。</p><center><img src="http://pictures.aimasa.club/static/images/QR_detail/lenth.png"></center><p>[8 bits per character==每个字符八位]上面的长度字段大小仅适用于较小的QR码</p><p>所以可以根据上图得出紧跟着0100后面的8个比特的字符串0000 1101是讲的是该存储信息的长度，表明有十三个字符，所以后面跟的00100111和01010100（分别是”‘“和”T”的ascii码）等等十三个字符。</p><p>在最后一个数据位之后是另一个4位模式指示符，它可以和第一个4位模式指示符不一样，从而允许在一个QR码中混合多个编码方案，如果没有其他数据了，用0000结尾（如果存储空间不够，可以省略这个标记）</p><p>为了使我们的QR码解码器<strong>可靠</strong>，我们需要能够<strong>纠正</strong>错误。 本文的下一部分将描述如何通过构造BCH解码器，更具体地说是Reed-Solomon解码器来纠正错误。</p><p><a href="https://aimasa.github.io/2019/01/23/BCH/">二维码之解码器</a></p>]]></content>
      
      
      <categories>
          
          <category> QR </category>
          
          <category> 了解二维码 </category>
          
          <category> 了解二维码(二):二维码的编码方式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> QR </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>了解二维码(一):二维码的组成部分解释与介绍</title>
      <link href="/2019/01/21/QR_infor/"/>
      <url>/2019/01/21/QR_infor/</url>
      
        <content type="html"><![CDATA[<h1 id="QR图形介绍"><a href="#QR图形介绍" class="headerlink" title="QR图形介绍"></a>QR图形介绍</h1><hr><blockquote><p> 二维码一共有40个尺寸。官方叫版本Version。Version 1是21 x 21的矩阵，Version 2是 25 x 25的矩阵，Version 3是29的尺寸，每增加一个version，就会增加4的尺寸，公式是：<strong> (V-1)x4 + 21（V是版本号）</strong> 最高Version 40，(40-1)*4+21 = 177，所以最高是177 x 177 的正方形。<br><a id="more"></a></p></blockquote><center><img src="http://pictures.aimasa.club/static/images/QR_infor/QR_area.png"></center><h3 id="功能图形起到定位的作用："><a href="#功能图形起到定位的作用：" class="headerlink" title="功能图形起到定位的作用："></a>功能图形起到定位的作用：</h3><p><a href="https://www.cnblogs.com/magicsoar/p/4483032.html" title="参考二维码各部分名称的博客链接" target="_blank" rel="noopener">参考博客链接</a>，<a href="https://blog.csdn.net/kelindame/article/details/45155185" title="参考二维码各部分详细介绍" target="_blank" rel="noopener">参考博客链接</a></p><ul><li>位置探测图形：最大的正方形就是位置探测图形（由三个黑白相间的大正方形嵌套组成，分别位于二维码左上角、右上角、左下角，目的是为了确定二维码的大小和位置。）这个图形的大小是固定的，不会因为二维码的版本而改变。(它的旁边还有八个加七个的由白块组成的白边，为了更好的定位而存在的)</li></ul><center><img src="http://pictures.aimasa.club/static/images/QR_infor/position.jpg"></center><ul><li>定位图形：连接着位置探测图形的有规律的黑白相间的那条线（由<strong>两条</strong>黑白相间的直线组成，便于确定二维码的角度，纠正扭曲。）<strong> 定位符是因为二维码有40个版本尺寸,当尺寸过大后需要有根标准线，不然扫描的时候可能会扫歪。 </strong>，它的长度很容易计算出来，一共两条线，用二维码的长度减掉两个位置探测图形的长度就可以得出每条线的长度了。</li></ul><ul><li>校正图形：和位置探测图形比起来比较小，和定位图形的黑白相间的小正方形比起来要大的正方形（仅在版本2以上存在，由三个黑白相间的小正方形嵌套组成，便于确定中心，纠正扭曲。）<strong> 每个版本的存储数据容量不一样,版本越高就意味着数据容量越大，纠错能力越强 </strong>这个图形的大小是固定的，不会因为二维码的版本而改变。</li></ul><center><img src="http://pictures.aimasa.club/static/images/QR_infor/position2.jpg"></center><p>Alignment Patterns(对齐模式)：也是用于定位，只有version2以上才有用。</p><h3 id="数据区记录了具体的数据信息，纠错信息与版本信息："><a href="#数据区记录了具体的数据信息，纠错信息与版本信息：" class="headerlink" title="数据区记录了具体的数据信息，纠错信息与版本信息："></a>数据区记录了具体的数据信息，纠错信息与版本信息：</h3><ul><li><p>数据和纠错码：把数据码和纠错码的各个8位一组的十进制数（codewords）交替放在一起（跟我的理解是一样的，把数据分组，然后每组数据后面跟一个纠错码），所以就算有图片在二维码中间，二维码还是能扫描出记录在里面的内容(记录了数据信息和相应的纠错码，纠错码的存在使得当二维码的数据出现允许范围内的错误时，也可以正确解码。)<strong> 存储容错级别L(7%),M(15%),Q(25%),R(35%) </strong></p></li><li><p>版本信息：就是记录二维码的规格(仅在<strong>版本7以上</strong>存在，记录具体的版本信息。)需要预留两块3 x 6的区域存放一些版本信息</p></li><li><p>格式信息：记录使用的数据掩码和纠错等级，和额外的自身BCH容错码。一条格式信息有15个bit，还有一条格式信息是这条信息的副本，为了防止格式信息被破坏。</p></li><li><p>Dark Module：这是二维码的标志，每个二维码都有。</p></li></ul><center><img src="http://pictures.aimasa.club/static/images/QR_infor/DarkModule.png"></center><p>此外二维码的外围还留有一圈空白区，主要是为了便于识别而存在。其中在位置探测图形周围有一圈白边（一个单位宽），这是分隔符，位于每个定位标识和编码区域之间用于区分。</p><h3 id="纠错码和编码信息"><a href="#纠错码和编码信息" class="headerlink" title="纠错码和编码信息"></a>纠错码和编码信息</h3><p>除了上述说的这些外，就还只有纠错码和编码了。</p><p>那么，QR是怎么对数据码加上纠错码的？首先，我们需要对数据码进行分组，也就是分成不同的Block，然后对各个Block进行纠错编码。</p><ul><li><p>Number of Error Code Correction Blocks ：需要分多少个块。</p></li><li><p>Error Correction Code Per Blocks：每一个块中的code个数，所谓的code的个数，也就是有多少个8bits的字节。</p></li></ul><p><a href="https://blog.csdn.net/u012611878/article/details/53167009" target="_blank" rel="noopener">参考博文</a></p><p><a href="https://coolshell.cn/articles/10590.html" target="_blank" rel="noopener">参考博文</a></p><p>QR码中，不同版本不同纠错级别都有相对应的数据存储容量，输入的字符越多，那相对应的QR码就要越大。</p><p>以下这个表是根据版本以及纠错级别对应的最佳的输入的数据的字符个数</p><center><img src="http://pictures.aimasa.club/static/images/QR_infor/QR_data.png"></center>]]></content>
      
      
      <categories>
          
          <category> QR </category>
          
          <category> 了解二维码 </category>
          
          <category> 了解二维码(一):二维码的组成部分解释与介绍 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> QR </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
